/*
** Lua binding: LuaBinding
** Generated automatically by 1.0.92+dora on Fri Dec 19 11:32:54 2025.
*/

#include "Const/Header.h"
#include "Lua/ToLua/tolua++.h"
#include "Lua/LuaManual.h"
#include "GUI/ImGuiBinding.h"
using namespace Dora;
using string = std::string;
#define NewVec2(x,y) Vec2{x,y}

/* function to release collected object via destructor */
static int tolua_collect_NVGpaint (lua_State* tolua_S){
  NVGpaint* self = (NVGpaint*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Rect (lua_State* tolua_S){
  Rect* self = (Rect*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Color3 (lua_State* tolua_S){
  Color3* self = (Color3*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Vec2 (lua_State* tolua_S){
  Vec2* self = (Vec2*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Color (lua_State* tolua_S){
  Color* self = (Color*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_BlendFunc (lua_State* tolua_S){
  BlendFunc* self = (BlendFunc*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Platformer__TargetAllow (lua_State* tolua_S){
  Platformer::TargetAllow* self = (Platformer::TargetAllow*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}
static int tolua_collect_Size (lua_State* tolua_S){
  Size* self = (Size*) tolua_tousertype(tolua_S,1,0);
  Mtolua_delete(self);
  return 0;
}

/* function to register type */
static void tolua_reg_types(lua_State* tolua_S){
 tolua_usertype(tolua_S,"Platformer::Behavior::Leaf");
 Mtolua_typeid(tolua_S,Platformer::Behavior::Leaf,"Platformer::Behavior::Leaf");
 tolua_usertype(tolua_S,"Path");
 Mtolua_typeid(tolua_S,Path,"Path");
 tolua_usertype(tolua_S,"Action");
 Mtolua_typeid(tolua_S,Action,"Action");
 tolua_usertype(tolua_S,"Cache");
 Mtolua_typeid(tolua_S,Cache,"Cache");
 tolua_usertype(tolua_S,"Profiler");
 Mtolua_typeid(tolua_S,Profiler,"Profiler");
 tolua_usertype(tolua_S,"Platformer::Unit");
 Mtolua_typeid(tolua_S,Platformer::Unit,"Platformer::Unit");
 tolua_usertype(tolua_S,"Platformer::Data");
 Mtolua_typeid(tolua_S,Platformer::Data,"Platformer::Data");
 tolua_usertype(tolua_S,"Grid");
 Mtolua_typeid(tolua_S,Grid,"Grid");
 tolua_usertype(tolua_S,"HttpClient");
 Mtolua_typeid(tolua_S,HttpClient,"HttpClient");
 tolua_usertype(tolua_S,"Joint");
 Mtolua_typeid(tolua_S,Joint,"Joint");
 tolua_usertype(tolua_S,"Node");
 Mtolua_typeid(tolua_S,Node,"Node");
 tolua_usertype(tolua_S,"BodyDef");
 Mtolua_typeid(tolua_S,BodyDef,"BodyDef");
 tolua_usertype(tolua_S,"Director");
 Mtolua_typeid(tolua_S,Director,"Director");
 tolua_usertype(tolua_S,"Slot");
 Mtolua_typeid(tolua_S,Slot,"Slot");
 tolua_usertype(tolua_S,"ClipNode");
 Mtolua_typeid(tolua_S,ClipNode,"ClipNode");
 tolua_usertype(tolua_S,"Pass");
 Mtolua_typeid(tolua_S,Pass,"Pass");
 tolua_usertype(tolua_S,"WasmRuntime");
 Mtolua_typeid(tolua_S,WasmRuntime,"WasmRuntime");
 tolua_usertype(tolua_S,"Texture2D");
 Mtolua_typeid(tolua_S,Texture2D,"Texture2D");
 tolua_usertype(tolua_S,"Color3");
 Mtolua_typeid(tolua_S,Color3,"Color3");
 tolua_usertype(tolua_S,"Listener");
 Mtolua_typeid(tolua_S,Listener,"Listener");
 tolua_usertype(tolua_S,"ParticleNode");
 Mtolua_typeid(tolua_S,ParticleNode,"ParticleNode");
 tolua_usertype(tolua_S,"NVGpaint");
 Mtolua_typeid(tolua_S,NVGpaint,"NVGpaint");
 tolua_usertype(tolua_S,"Color");
 Mtolua_typeid(tolua_S,Color,"Color");
 tolua_usertype(tolua_S,"BlendFunc");
 Mtolua_typeid(tolua_S,BlendFunc,"BlendFunc");
 tolua_usertype(tolua_S,"Spine");
 Mtolua_typeid(tolua_S,Spine,"Spine");
 tolua_usertype(tolua_S,"DrawNode");
 Mtolua_typeid(tolua_S,DrawNode,"DrawNode");
 tolua_usertype(tolua_S,"Dictionary");
 Mtolua_typeid(tolua_S,Dictionary,"Dictionary");
 tolua_usertype(tolua_S,"MoveJoint");
 Mtolua_typeid(tolua_S,MoveJoint,"MoveJoint");
 tolua_usertype(tolua_S,"Ease");
 Mtolua_typeid(tolua_S,Ease,"Ease");
 tolua_usertype(tolua_S,"Node::Grabber");
 Mtolua_typeid(tolua_S,Node::Grabber,"Node::Grabber");
 tolua_usertype(tolua_S,"Size");
 Mtolua_typeid(tolua_S,Size,"Size");
 tolua_usertype(tolua_S,"SpriteEffect");
 Mtolua_typeid(tolua_S,SpriteEffect,"SpriteEffect");
 tolua_usertype(tolua_S,"Effect");
 Mtolua_typeid(tolua_S,Effect,"Effect");
 tolua_usertype(tolua_S,"Platformer::PlatformCamera");
 Mtolua_typeid(tolua_S,Platformer::PlatformCamera,"Platformer::PlatformCamera");
 tolua_usertype(tolua_S,"Model");
 Mtolua_typeid(tolua_S,Model,"Model");
 tolua_usertype(tolua_S,"Content");
 Mtolua_typeid(tolua_S,Content,"Content");
 tolua_usertype(tolua_S,"Platformer::Bullet");
 Mtolua_typeid(tolua_S,Platformer::Bullet,"Platformer::Bullet");
 tolua_usertype(tolua_S,"View");
 Mtolua_typeid(tolua_S,View,"View");
 tolua_usertype(tolua_S,"Label");
 Mtolua_typeid(tolua_S,Label,"Label");
 tolua_usertype(tolua_S,"EntityGroup");
 Mtolua_typeid(tolua_S,EntityGroup,"EntityGroup");
 tolua_usertype(tolua_S,"RenderTarget");
 Mtolua_typeid(tolua_S,RenderTarget,"RenderTarget");
 tolua_usertype(tolua_S,"Scheduler");
 Mtolua_typeid(tolua_S,Scheduler,"Scheduler");
 tolua_usertype(tolua_S,"Entity");
 Mtolua_typeid(tolua_S,Entity,"Entity");
 tolua_usertype(tolua_S,"Camera2D");
 Mtolua_typeid(tolua_S,Camera2D,"Camera2D");
 tolua_usertype(tolua_S,"FixtureDef");
 Mtolua_typeid(tolua_S,FixtureDef,"FixtureDef");
 tolua_usertype(tolua_S,"EntityObserver");
 Mtolua_typeid(tolua_S,EntityObserver,"EntityObserver");
 tolua_usertype(tolua_S,"ML::QLearner");
 Mtolua_typeid(tolua_S,ML::QLearner,"ML::QLearner");
 tolua_usertype(tolua_S,"EffekNode");
 Mtolua_typeid(tolua_S,EffekNode,"EffekNode");
 tolua_usertype(tolua_S,"Platformer::Behavior::Blackboard");
 Mtolua_typeid(tolua_S,Platformer::Behavior::Blackboard,"Platformer::Behavior::Blackboard");
 tolua_usertype(tolua_S,"Buffer");
 Mtolua_typeid(tolua_S,Buffer,"Buffer");
 tolua_usertype(tolua_S,"Sprite");
 Mtolua_typeid(tolua_S,Sprite,"Sprite");
 tolua_usertype(tolua_S,"Camera");
 Mtolua_typeid(tolua_S,Camera,"Camera");
 tolua_usertype(tolua_S,"AlignNode");
 Mtolua_typeid(tolua_S,AlignNode,"AlignNode");
 tolua_usertype(tolua_S,"Platformer::PlatformWorld");
 Mtolua_typeid(tolua_S,Platformer::PlatformWorld,"Platformer::PlatformWorld");
 tolua_usertype(tolua_S,"Platformer::UnitAction");
 Mtolua_typeid(tolua_S,Platformer::UnitAction,"Platformer::UnitAction");
 tolua_usertype(tolua_S,"JointDef");
 Mtolua_typeid(tolua_S,JointDef,"JointDef");
 tolua_usertype(tolua_S,"Platformer::Decision::AI");
 Mtolua_typeid(tolua_S,Platformer::Decision::AI,"Platformer::Decision::AI");
 tolua_usertype(tolua_S,"Sensor");
 Mtolua_typeid(tolua_S,Sensor,"Sensor");
 tolua_usertype(tolua_S,"Platformer::Decision::Leaf");
 Mtolua_typeid(tolua_S,Platformer::Decision::Leaf,"Platformer::Decision::Leaf");
 tolua_usertype(tolua_S,"Keyboard");
 Mtolua_typeid(tolua_S,Keyboard,"Keyboard");
 tolua_usertype(tolua_S,"DB");
 Mtolua_typeid(tolua_S,DB,"DB");
 tolua_usertype(tolua_S,"VGNode");
 Mtolua_typeid(tolua_S,VGNode,"VGNode");
 tolua_usertype(tolua_S,"Platformer::TargetAllow");
 Mtolua_typeid(tolua_S,Platformer::TargetAllow,"Platformer::TargetAllow");
 tolua_usertype(tolua_S,"Body");
 Mtolua_typeid(tolua_S,Body,"Body");
 tolua_usertype(tolua_S,"Platformer::Visual");
 Mtolua_typeid(tolua_S,Platformer::Visual,"Platformer::Visual");
 tolua_usertype(tolua_S,"Line");
 Mtolua_typeid(tolua_S,Line,"Line");
 tolua_usertype(tolua_S,"AudioBus");
 Mtolua_typeid(tolua_S,AudioBus,"AudioBus");
 tolua_usertype(tolua_S,"Platformer::BulletDef");
 Mtolua_typeid(tolua_S,Platformer::BulletDef,"Platformer::BulletDef");
 tolua_usertype(tolua_S,"Platformer::Face");
 Mtolua_typeid(tolua_S,Platformer::Face,"Platformer::Face");
 tolua_usertype(tolua_S,"HttpServer");
 Mtolua_typeid(tolua_S,HttpServer,"HttpServer");
 tolua_usertype(tolua_S,"SVGDef");
 Mtolua_typeid(tolua_S,SVGDef,"SVGDef");
 tolua_usertype(tolua_S,"Playable");
 Mtolua_typeid(tolua_S,Playable,"Playable");
 tolua_usertype(tolua_S,"Controller");
 Mtolua_typeid(tolua_S,Controller,"Controller");
 tolua_usertype(tolua_S,"Touch");
 Mtolua_typeid(tolua_S,Touch,"Touch");
 tolua_usertype(tolua_S,"Mouse");
 Mtolua_typeid(tolua_S,Mouse,"Mouse");
 tolua_usertype(tolua_S,"Vec2");
 Mtolua_typeid(tolua_S,Vec2,"Vec2");
 tolua_usertype(tolua_S,"Menu");
 Mtolua_typeid(tolua_S,Menu,"Menu");
 tolua_usertype(tolua_S,"CameraOtho");
 Mtolua_typeid(tolua_S,CameraOtho,"CameraOtho");
 tolua_usertype(tolua_S,"AudioSource");
 Mtolua_typeid(tolua_S,AudioSource,"AudioSource");
 tolua_usertype(tolua_S,"TileNode");
 Mtolua_typeid(tolua_S,TileNode,"TileNode");
 tolua_usertype(tolua_S,"Audio");
 Mtolua_typeid(tolua_S,Audio,"Audio");
 tolua_usertype(tolua_S,"Rect");
 Mtolua_typeid(tolua_S,Rect,"Rect");
 tolua_usertype(tolua_S,"MotorJoint");
 Mtolua_typeid(tolua_S,MotorJoint,"MotorJoint");
 tolua_usertype(tolua_S,"Application");
 Mtolua_typeid(tolua_S,Application,"Application");
 tolua_usertype(tolua_S,"Object");
 Mtolua_typeid(tolua_S,Object,"Object");
 tolua_usertype(tolua_S,"Array");
 Mtolua_typeid(tolua_S,Array,"Array");
 tolua_usertype(tolua_S,"DragonBone");
 Mtolua_typeid(tolua_S,DragonBone,"DragonBone");
 tolua_usertype(tolua_S,"PhysicsWorld");
 Mtolua_typeid(tolua_S,PhysicsWorld,"PhysicsWorld");
}

/* get function: EventName of class  Profiler */
static int tolua_get_Profiler_EventName(lua_State* tolua_S){
  tolua_pushslice(tolua_S,(Slice)Profiler::EventName);
 return 1;
}
/* get function: level of class  Profiler */
static int tolua_get_Profiler_level(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Profiler::level);
 return 1;
}
/* set function: level of class  Profiler */
static int tolua_set_Profiler_level(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!tolua_isinteger(tolua_S,3,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Profiler.level'",&tolua_err);
#endif
  TOLUA_TRY
  Profiler::level =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  TOLUA_CATCH
  return 0;
}
/* get function: r of class  Color3 */
static int tolua_get_Color3_r(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'r'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->r);
 return 1;
}
/* set function: r of class  Color3 */
static int tolua_set_Color3_r(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color3.r'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color3.r'",&tolua_err);
#endif
  TOLUA_TRY
  self->r =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: g of class  Color3 */
static int tolua_get_Color3_g(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'g'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->g);
 return 1;
}
/* set function: g of class  Color3 */
static int tolua_set_Color3_g(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color3.g'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color3.g'",&tolua_err);
#endif
  TOLUA_TRY
  self->g =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: b of class  Color3 */
static int tolua_get_Color3_b(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'b'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->b);
 return 1;
}
/* set function: b of class  Color3 */
static int tolua_set_Color3_b(lua_State* tolua_S){
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color3.b'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color3.b'",&tolua_err);
#endif
  TOLUA_TRY
  self->b =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Color3 */
static int tolua_LuaBinding_Color3_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float r =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float g =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float b =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   Color3* tolua_ret = (Color3*)  Mtolua_new((Color3)(r,g,b));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color3>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Color3.new'.",&tolua_err);
 return 0;
#endif
}
/* method: toRGB of class  Color3 */
static int tolua_LuaBinding_Color3_toRGB00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color3"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Color3* self = (Color3*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Color3.toRGB'", NULL);
#endif
  TOLUA_TRY
  {
   uint32_t tolua_ret = (uint32_t)  self->toRGB();
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Color3.toRGB'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Color3 */
static int tolua_LuaBinding_Color3_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  double rgb =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside Color3* tolua_ret = (tolua_outside Color3*)  Color3_create(rgb);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color3>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Color3_new00_local(tolua_S);
}
/* get function: r of class  Color */
static int tolua_get_Color_r(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'r'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->r);
 return 1;
}
/* set function: r of class  Color */
static int tolua_set_Color_r(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color.r'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color.r'",&tolua_err);
#endif
  TOLUA_TRY
  self->r =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: g of class  Color */
static int tolua_get_Color_g(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'g'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->g);
 return 1;
}
/* set function: g of class  Color */
static int tolua_set_Color_g(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color.g'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color.g'",&tolua_err);
#endif
  TOLUA_TRY
  self->g =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: b of class  Color */
static int tolua_get_Color_b(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'b'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->b);
 return 1;
}
/* set function: b of class  Color */
static int tolua_set_Color_b(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color.b'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color.b'",&tolua_err);
#endif
  TOLUA_TRY
  self->b =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: a of class  Color */
static int tolua_get_Color_a(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'a'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->a);
 return 1;
}
/* set function: a of class  Color */
static int tolua_set_Color_a(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color.a'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color.a'",&tolua_err);
#endif
  TOLUA_TRY
  self->a =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: opacity of class  Color */
static int tolua_get_Color_opacity(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'opacity'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getOpacity());
 return 1;
}
/* set function: opacity of class  Color */
static int tolua_set_Color_opacity(lua_State* tolua_S){
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Color.opacity'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Color.opacity'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOpacity(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Color */
static int tolua_LuaBinding_Color_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Color3"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Color3 color = * static_cast< Color3*>(tolua_tousertype(tolua_S,2,0));
  float a =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  TOLUA_TRY
  {
   Color* tolua_ret = (Color*)  Mtolua_new((Color)(color,a));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Color.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Color */
static int tolua_LuaBinding_Color_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float r =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float g =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float b =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float a =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  TOLUA_TRY
  {
   Color* tolua_ret = (Color*)  Mtolua_new((Color)(r,g,b,a));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Color_new00_local(tolua_S);
}
/* method: toColor3 of class  Color */
static int tolua_LuaBinding_Color_toColor300(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Color.toColor3'", NULL);
#endif
  TOLUA_TRY
  {
   Color3 tolua_ret = (Color3)  self->toColor3();
   {
 void* tolua_obj = Mtolua_new((Color3)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color3>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Color.toColor3'.",&tolua_err);
 return 0;
#endif
}
/* method: toARGB of class  Color */
static int tolua_LuaBinding_Color_toARGB00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Color* self = (Color*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Color.toARGB'", NULL);
#endif
  TOLUA_TRY
  {
   uint32_t tolua_ret = (uint32_t)  self->toARGB();
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Color.toARGB'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Color */
static int tolua_LuaBinding_Color_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice argb =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside Color* tolua_ret = (tolua_outside Color*)  Color_create(argb);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Color_new01_local(tolua_S);
}
/* method: new_local of class  Color */
static int tolua_LuaBinding_Color_new03_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  double argb =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside Color* tolua_ret = (tolua_outside Color*)  Color_create(argb);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Color>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Color_new02_local(tolua_S);
}
/* get function: x of class  Vec2 */
static int tolua_get_Vec2_x(lua_State* tolua_S){
  Vec2 self = tolua_tolight(tolua_S,1);
  tolua_pushnumber(tolua_S,(lua_Number)self.x);
 return 1;
}
/* get function: y of class  Vec2 */
static int tolua_get_Vec2_y(lua_State* tolua_S){
  Vec2 self = tolua_tolight(tolua_S,1);
  tolua_pushnumber(tolua_S,(lua_Number)self.y);
 return 1;
}
/* get function: length of class  Vec2 */
static int tolua_get_Vec2_length(lua_State* tolua_S){
  Vec2 self = tolua_tolight(tolua_S,1);
  tolua_pushnumber(tolua_S,(lua_Number)self.length());
 return 1;
}
/* get function: lengthSquared of class  Vec2 */
static int tolua_get_Vec2_lengthSquared(lua_State* tolua_S){
  Vec2 self = tolua_tolight(tolua_S,1);
  tolua_pushnumber(tolua_S,(lua_Number)self.lengthSquared());
 return 1;
}
/* get function: angle of class  Vec2 */
static int tolua_get_Vec2_angle(lua_State* tolua_S){
  Vec2 self = tolua_tolight(tolua_S,1);
  tolua_pushnumber(tolua_S,(lua_Number)self.angle());
 return 1;
}
/* method: operator+ of class  Vec2 */
static int tolua_LuaBinding_Vec2__add00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator+(vec);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.add'.",&tolua_err);
 return 0;
#endif
}
/* method: operator- of class  Vec2 */
static int tolua_LuaBinding_Vec2__sub00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator-(vec);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.sub'.",&tolua_err);
 return 0;
#endif
}
/* method: operator* of class  Vec2 */
static int tolua_LuaBinding_Vec2__mul00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  float value =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator*(value);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.mul'.",&tolua_err);
 return 0;
#endif
}
/* method: operator* of class  Vec2 */
static int tolua_LuaBinding_Vec2__mul01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator*(vec);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Vec2__mul00(tolua_S);
}
/* method: operator* of class  Vec2 */
static int tolua_LuaBinding_Vec2__mul02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator*(size);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Vec2__mul01(tolua_S);
}
/* method: operator/ of class  Vec2 */
static int tolua_LuaBinding_Vec2__div00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  float value =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   Vec2 tolua_ret =  self.operator/(value);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.div'.",&tolua_err);
 return 0;
#endif
}
/* method: distance of class  Vec2 */
static int tolua_LuaBinding_Vec2_distance00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   float tolua_ret =  self.distance(vec);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.distance'.",&tolua_err);
 return 0;
#endif
}
/* method: distanceSquared of class  Vec2 */
static int tolua_LuaBinding_Vec2_distanceSquared00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   float tolua_ret =  self.distanceSquared(vec);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.distanceSquared'.",&tolua_err);
 return 0;
#endif
}
/* method: Vec2::normalize of class  Vec2 */
static int tolua_LuaBinding_Vec2_normalize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret =  Vec2::normalize(self);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.normalize'.",&tolua_err);
 return 0;
#endif
}
/* method: Vec2::perp of class  Vec2 */
static int tolua_LuaBinding_Vec2_perp00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret =  Vec2::perp(self);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.perp'.",&tolua_err);
 return 0;
#endif
}
/* method: Vec2::clamp of class  Vec2 */
static int tolua_LuaBinding_Vec2_clamp00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 from = tolua_tolight(tolua_S,2);
  Vec2 to = tolua_tolight(tolua_S,3);
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret =  Vec2::clamp(self,from,to);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.clamp'.",&tolua_err);
 return 0;
#endif
}
/* method: Vec2::dot of class  Vec2 */
static int tolua_LuaBinding_Vec2_dot00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 self =  tolua_tolight(tolua_S,1);
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   tolua_outside float tolua_ret =  Vec2::dot(self,vec);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.dot'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Vec2 */
static int tolua_LuaBinding_Vec2_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret =  Vec2_create(x,y);
  tolua_pushlight(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Vec2.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Vec2 */
static int tolua_LuaBinding_Vec2_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret =  Vec2_create(size);
  tolua_pushlight(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Vec2_new00_local(tolua_S);
}
/* get function: zero of class  Vec2 */
static int tolua_get_Vec2_zero(lua_State* tolua_S){
  Vec2 tolua_obj =  Vec2::zero;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* get function: width of class  Size */
static int tolua_get_Size_width(lua_State* tolua_S){
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->width);
 return 1;
}
/* set function: width of class  Size */
static int tolua_set_Size_width(lua_State* tolua_S){
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Size.width'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Size.width'",&tolua_err);
#endif
  TOLUA_TRY
  self->width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: height of class  Size */
static int tolua_get_Size_height(lua_State* tolua_S){
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->height);
 return 1;
}
/* set function: height of class  Size */
static int tolua_set_Size_height(lua_State* tolua_S){
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Size.height'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Size.height'",&tolua_err);
#endif
  TOLUA_TRY
  self->height =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Size */
static int tolua_LuaBinding_Size_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Size other = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Size* tolua_ret = (Size*)  Mtolua_new((Size)(other));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Size>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Size.new'.",&tolua_err);
 return 0;
#endif
}
/* method: set of class  Size */
static int tolua_LuaBinding_Size_set00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Size"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Size.set'", NULL);
#endif
  TOLUA_TRY
  {
   self->set(width,height);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Size.set'.",&tolua_err);
 return 0;
#endif
}
/* method: operator== of class  Size */
static int tolua_LuaBinding_Size__eq00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Size"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
  Size other = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Size.operator=='", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->operator==(other);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Size.eq'.",&tolua_err);
 return 0;
#endif
}
/* method: operator* of class  Size */
static int tolua_LuaBinding_Size__mul00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Size"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Size* self = (Size*)  tolua_tousertype(tolua_S,1,0);
  Vec2 vec = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Size.operator*'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->operator*(vec);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Size.mul'.",&tolua_err);
 return 0;
#endif
}
/* get function: zero of class  Size */
static int tolua_get_Size_zero(lua_State* tolua_S){
 void* tolua_obj = Mtolua_new((Size)(Size::zero));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* method: new_local of class  Size */
static int tolua_LuaBinding_Size_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Vec2 vec = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   tolua_outside Size* tolua_ret = (tolua_outside Size*)  Size_create(vec);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Size>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Size_new00_local(tolua_S);
}
/* method: new_local of class  Size */
static int tolua_LuaBinding_Size_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_TRY
  {
   tolua_outside Size* tolua_ret = (tolua_outside Size*)  Size_create(width,height);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Size>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Size_new01_local(tolua_S);
}
/* get function: origin of class  Rect */
static int tolua_get_Rect_origin(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'origin'",NULL);
#endif
  Vec2 tolua_obj =  self->origin;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: origin of class  Rect */
static int tolua_set_Rect_origin(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.origin'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.origin'",&tolua_err);
#endif
  TOLUA_TRY
  self->origin =  tolua_tolight(tolua_S,2);
  TOLUA_CATCH
  return 0;
}
/* get function: size of class  Rect */
static int tolua_get_Rect_size(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'size'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->size));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* set function: size of class  Rect */
static int tolua_set_Rect_size(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.size'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.size'",&tolua_err);
#endif
  TOLUA_TRY
  self->size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: x of class  Rect */
static int tolua_get_Rect_x(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getX());
 return 1;
}
/* set function: x of class  Rect */
static int tolua_set_Rect_x(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.x'",&tolua_err);
#endif
  TOLUA_TRY
  self->setX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: y of class  Rect */
static int tolua_get_Rect_y(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getY());
 return 1;
}
/* set function: y of class  Rect */
static int tolua_set_Rect_y(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.y'",&tolua_err);
#endif
  TOLUA_TRY
  self->setY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: width of class  Rect */
static int tolua_get_Rect_width(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getWidth());
 return 1;
}
/* set function: width of class  Rect */
static int tolua_set_Rect_width(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.width'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.width'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWidth(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: height of class  Rect */
static int tolua_get_Rect_height(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getHeight());
 return 1;
}
/* set function: height of class  Rect */
static int tolua_set_Rect_height(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.height'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.height'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHeight(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: left of class  Rect */
static int tolua_get_Rect_left(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'left'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getLeft());
 return 1;
}
/* set function: left of class  Rect */
static int tolua_set_Rect_left(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.left'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.left'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLeft(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: right of class  Rect */
static int tolua_get_Rect_right(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'right'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getRight());
 return 1;
}
/* set function: right of class  Rect */
static int tolua_set_Rect_right(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.right'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.right'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRight(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: centerX of class  Rect */
static int tolua_get_Rect_centerX(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'centerX'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getCenterX());
 return 1;
}
/* set function: centerX of class  Rect */
static int tolua_set_Rect_centerX(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.centerX'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.centerX'",&tolua_err);
#endif
  TOLUA_TRY
  self->setCenterX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: centerY of class  Rect */
static int tolua_get_Rect_centerY(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'centerY'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getCenterY());
 return 1;
}
/* set function: centerY of class  Rect */
static int tolua_set_Rect_centerY(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.centerY'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.centerY'",&tolua_err);
#endif
  TOLUA_TRY
  self->setCenterY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: bottom of class  Rect */
static int tolua_get_Rect_bottom(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bottom'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getBottom());
 return 1;
}
/* set function: bottom of class  Rect */
static int tolua_set_Rect_bottom(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.bottom'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.bottom'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBottom(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: top of class  Rect */
static int tolua_get_Rect_top(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'top'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getTop());
 return 1;
}
/* set function: top of class  Rect */
static int tolua_set_Rect_top(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.top'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.top'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTop(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: lowerBound of class  Rect */
static int tolua_get_Rect_lowerBound(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'lowerBound'",NULL);
#endif
  Vec2 tolua_obj =  self->getLowerBound();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: lowerBound of class  Rect */
static int tolua_set_Rect_lowerBound(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.lowerBound'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.lowerBound'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLowerBound(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: upperBound of class  Rect */
static int tolua_get_Rect_upperBound(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'upperBound'",NULL);
#endif
  Vec2 tolua_obj =  self->getUpperBound();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: upperBound of class  Rect */
static int tolua_set_Rect_upperBound(lua_State* tolua_S){
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Rect.upperBound'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Rect.upperBound'",&tolua_err);
#endif
  TOLUA_TRY
  self->setUpperBound(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Rect */
static int tolua_LuaBinding_Rect_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Rect* tolua_ret = (Rect*)  Mtolua_new((Rect)());
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Rect>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Rect */
static int tolua_LuaBinding_Rect_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Size"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Vec2 origin = tolua_tolight(tolua_S,2);
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   Rect* tolua_ret = (Rect*)  Mtolua_new((Rect)(origin,size));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Rect>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Rect_new00_local(tolua_S);
}
/* method: new_local of class  Rect */
static int tolua_LuaBinding_Rect_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float width =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  TOLUA_TRY
  {
   Rect* tolua_ret = (Rect*)  Mtolua_new((Rect)(x,y,width,height));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Rect>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Rect_new01_local(tolua_S);
}
/* method: new_local of class  Rect */
static int tolua_LuaBinding_Rect_new03_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Rect other = * static_cast< Rect*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Rect* tolua_ret = (Rect*)  Mtolua_new((Rect)(other));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Rect>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Rect_new02_local(tolua_S);
}
/* method: operator== of class  Rect */
static int tolua_LuaBinding_Rect__eq00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Rect"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
  Rect other = * static_cast< Rect*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Rect.operator=='", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->operator==(other);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect.eq'.",&tolua_err);
 return 0;
#endif
}
/* method: set of class  Rect */
static int tolua_LuaBinding_Rect_set00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
  float x =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float width =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Rect.set'", NULL);
#endif
  TOLUA_TRY
  {
   self->set(x,y,width,height);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect.set'.",&tolua_err);
 return 0;
#endif
}
/* method: containsPoint of class  Rect */
static int tolua_LuaBinding_Rect_containsPoint00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Rect"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
  Vec2 point = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Rect.containsPoint'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->containsPoint(point);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect.containsPoint'.",&tolua_err);
 return 0;
#endif
}
/* method: intersectsRect of class  Rect */
static int tolua_LuaBinding_Rect_intersectsRect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Rect"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Rect* self = (Rect*)  tolua_tousertype(tolua_S,1,0);
  Rect rect = * static_cast< Rect*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Rect.intersectsRect'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->intersectsRect(rect);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect.intersectsRect'.",&tolua_err);
 return 0;
#endif
}
/* get function: zero of class  Rect */
static int tolua_get_Rect_zero(lua_State* tolua_S){
 void* tolua_obj = Mtolua_new((Rect)(Rect::zero));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Rect>());
 return 1;
}
/* get function: frame of class  Application */
static int tolua_get_Application_frame(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'frame'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getFrame());
 return 1;
}
/* get function: bufferSize of class  Application */
static int tolua_get_Application_bufferSize(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bufferSize'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getBufferSize()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* get function: visualSize of class  Application */
static int tolua_get_Application_visualSize(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'visualSize'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getVisualSize()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* get function: devicePixelRatio of class  Application */
static int tolua_get_Application_devicePixelRatio(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'devicePixelRatio'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDevicePixelRatio());
 return 1;
}
/* get function: platform of class  Application */
static int tolua_get_Application_platform(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'platform'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getPlatform());
 return 1;
}
/* get function: version of class  Application */
static int tolua_get_Application_version(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'version'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getVersion());
 return 1;
}
/* get function: deps of class  Application */
static int tolua_get_Application_deps(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'deps'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getDeps());
 return 1;
}
/* get function: deltaTime of class  Application */
static int tolua_get_Application_deltaTime(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'deltaTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDeltaTime());
 return 1;
}
/* get function: elapsedTime of class  Application */
static int tolua_get_Application_elapsedTime(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'elapsedTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getElapsedTime());
 return 1;
}
/* get function: totalTime of class  Application */
static int tolua_get_Application_totalTime(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'totalTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getTotalTime());
 return 1;
}
/* get function: runningTime of class  Application */
static int tolua_get_Application_runningTime(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'runningTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getRunningTime());
 return 1;
}
/* get function: rand of class  Application */
static int tolua_get_Application_rand(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rand'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getRand());
 return 1;
}
/* get function: maxFPS of class  Application */
static int tolua_get_Application_maxFPS(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'maxFPS'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getMaxFPS());
 return 1;
}
/* get function: debugging of class  Application */
static int tolua_get_Application_debugging(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'debugging'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDebugging());
 return 1;
}
/* get function: locale of class  Application */
static int tolua_get_Application_locale(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'locale'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getLocale());
 return 1;
}
/* set function: locale of class  Application */
static int tolua_set_Application_locale(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.locale'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.locale'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLocale(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: themeColor of class  Application */
static int tolua_get_Application_themeColor(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'themeColor'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color)(self->getThemeColor()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
 return 1;
}
/* set function: themeColor of class  Application */
static int tolua_set_Application_themeColor(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.themeColor'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.themeColor'",&tolua_err);
#endif
  TOLUA_TRY
  self->setThemeColor(* static_cast< Color*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: seed of class  Application */
static int tolua_get_Application_unsigned_seed(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'seed'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getSeed());
 return 1;
}
/* set function: seed of class  Application */
static int tolua_set_Application_unsigned_seed(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.seed'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.seed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSeed(static_cast< unsigned int>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: targetFPS of class  Application */
static int tolua_get_Application_targetFPS(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'targetFPS'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getTargetFPS());
 return 1;
}
/* set function: targetFPS of class  Application */
static int tolua_set_Application_targetFPS(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.targetFPS'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.targetFPS'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTargetFPS(static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: winSize of class  Application */
static int tolua_get_Application_winSize(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'winSize'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getWinSize()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* set function: winSize of class  Application */
static int tolua_set_Application_winSize(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.winSize'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.winSize'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWinSize(* static_cast< Size*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: winPosition of class  Application */
static int tolua_get_Application_winPosition(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'winPosition'",NULL);
#endif
  Vec2 tolua_obj =  self->getWinPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: winPosition of class  Application */
static int tolua_set_Application_winPosition(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.winPosition'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.winPosition'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWinPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: fPSLimited of class  Application */
static int tolua_get_Application_fpsLimited(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fPSLimited'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFPSLimited());
 return 1;
}
/* set function: fPSLimited of class  Application */
static int tolua_set_Application_fpsLimited(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.fPSLimited'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.fPSLimited'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFPSLimited(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: idled of class  Application */
static int tolua_get_Application_idled(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'idled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isIdled());
 return 1;
}
/* set function: idled of class  Application */
static int tolua_set_Application_idled(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.idled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.idled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setIdled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: fullScreen of class  Application */
static int tolua_get_Application_fullScreen(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fullScreen'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFullScreen());
 return 1;
}
/* set function: fullScreen of class  Application */
static int tolua_set_Application_fullScreen(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.fullScreen'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.fullScreen'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFullScreen(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: alwaysOnTop of class  Application */
static int tolua_get_Application_alwaysOnTop(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'alwaysOnTop'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isAlwaysOnTop());
 return 1;
}
/* set function: alwaysOnTop of class  Application */
static int tolua_set_Application_alwaysOnTop(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.alwaysOnTop'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.alwaysOnTop'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAlwaysOnTop(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: devMode of class  Application */
static int tolua_get_Application_devMode(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'devMode'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDevMode());
 return 1;
}
/* set function: devMode of class  Application */
static int tolua_set_Application_devMode(lua_State* tolua_S){
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Application.devMode'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Application.devMode'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDevMode(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: openURL of class  Application */
static int tolua_LuaBinding_Application_openURL00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Application"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Application.openURL'", NULL);
#endif
  TOLUA_TRY
  {
   self->openURL(url);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.openURL'.",&tolua_err);
 return 0;
#endif
}
/* method: install of class  Application */
static int tolua_LuaBinding_Application_install00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Application"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Application.install'", NULL);
#endif
  TOLUA_TRY
  {
   self->install(path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.install'.",&tolua_err);
 return 0;
#endif
}
/* method: saveLog of class  Application */
static int tolua_LuaBinding_Application_saveLog00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Application"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Application.saveLog'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->saveLog(filename);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.saveLog'.",&tolua_err);
 return 0;
#endif
}
/* method: openFileDialog of class  Application */
static int tolua_LuaBinding_Application_openFileDialog00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Application"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
  bool folderOnly =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,3));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Application.openFileDialog'", NULL);
#endif
  TOLUA_TRY
  {
   self->openFileDialog(folderOnly,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.openFileDialog'.",&tolua_err);
 return 0;
#endif
}
/* method: shutdown of class  Application */
static int tolua_LuaBinding_Application_shutdown00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Application"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Application* self = (Application*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Application.shutdown'", NULL);
#endif
  TOLUA_TRY
  {
   self->shutdown();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.shutdown'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Application */
static int tolua_LuaBinding_Application_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Application* tolua_ret = (tolua_outside Application*)  Application_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Application>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Application.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: id of class  Object */
static int tolua_get_Object_id(lua_State* tolua_S){
  Object* self = (Object*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'id'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getId());
 return 1;
}
/* get function: luaRef of class  Object */
static int tolua_get_Object_ref(lua_State* tolua_S){
  Object* self = (Object*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'luaRef'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getLuaRef());
 return 1;
}
/* get function: count of class  Object */
static int tolua_get_Object_count(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getCount());
 return 1;
}
/* get function: maxCount of class  Object */
static int tolua_get_Object_maxCount(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getMaxCount());
 return 1;
}
/* get function: luaRefCount of class  Object */
static int tolua_get_Object_luaRefCount(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getLuaRefCount());
 return 1;
}
/* get function: maxLuaRefCount of class  Object */
static int tolua_get_Object_maxLuaRefCount(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getMaxLuaRefCount());
 return 1;
}
/* get function: luaCallbackCount of class  Object */
static int tolua_get_Object_callRefCount(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getLuaCallbackCount());
 return 1;
}
/* get function: maxLuaCallbackCount of class  Object */
static int tolua_get_Object_maxCallRefCount(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Object::getMaxLuaCallbackCount());
 return 1;
}
/* get function: count of class  Array */
static int tolua_get_Array_count(lua_State* tolua_S){
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'count'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getCount());
 return 1;
}
/* get function: empty of class  Array */
static int tolua_get_Array_empty(lua_State* tolua_S){
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'empty'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEmpty());
 return 1;
}
/* method: addRange of class  Array */
static int tolua_LuaBinding_Array_addRange00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Array"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  Array* other =  static_cast< Array*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.addRange'", NULL);
#endif
  TOLUA_TRY
  {
   self->addRange(other);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.addRange'.",&tolua_err);
 return 0;
#endif
}
/* method: removeFrom of class  Array */
static int tolua_LuaBinding_Array_removeFrom00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Array"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  Array* other =  static_cast< Array*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.removeFrom'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeFrom(other);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.removeFrom'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Array */
static int tolua_LuaBinding_Array_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: reverse of class  Array */
static int tolua_LuaBinding_Array_reverse00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.reverse'", NULL);
#endif
  TOLUA_TRY
  {
   self->reverse();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.reverse'.",&tolua_err);
 return 0;
#endif
}
/* method: shrink of class  Array */
static int tolua_LuaBinding_Array_shrink00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.shrink'", NULL);
#endif
  TOLUA_TRY
  {
   self->shrink();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.shrink'.",&tolua_err);
 return 0;
#endif
}
/* method: Array_swap of class  Array */
static int tolua_LuaBinding_Array_swap00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  int indexA =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int indexB =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.Array_swap'", NULL);
#endif
  TOLUA_TRY
  {
   Array_swap(self,indexA,indexB);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.swap'.",&tolua_err);
 return 0;
#endif
}
/* method: Array_removeAt of class  Array */
static int tolua_LuaBinding_Array_removeAt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  int index =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.Array_removeAt'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  Array_removeAt(self,index);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.removeAt'.",&tolua_err);
 return 0;
#endif
}
/* method: Array_fastRemoveAt of class  Array */
static int tolua_LuaBinding_Array_fastRemoveAt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  int index =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.Array_fastRemoveAt'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  Array_fastRemoveAt(self,index);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.fastRemoveAt'.",&tolua_err);
 return 0;
#endif
}
/* method: Array_each of class  Array */
static int tolua_LuaBinding_Array_each00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Array"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Array* self = (Array*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Array.Array_each'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  Array_each(self,func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Array.each'.",&tolua_err);
 return 0;
#endif
}
/* get function: count of class  Dictionary */
static int tolua_get_Dictionary_count(lua_State* tolua_S){
  Dictionary* self = (Dictionary*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'count'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getCount());
 return 1;
}
/* method: each of class  Dictionary */
static int tolua_LuaBinding_Dictionary_each00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Dictionary"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Dictionary* self = (Dictionary*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dictionary.each'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->each(func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dictionary.each'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Dictionary */
static int tolua_LuaBinding_Dictionary_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Dictionary"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Dictionary* self = (Dictionary*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Dictionary.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dictionary.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Dictionary */
static int tolua_LuaBinding_Dictionary_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Dictionary* tolua_ret = (Dictionary*)  Dictionary::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dictionary.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: count of class  Entity */
static int tolua_get_Entity_count(lua_State* tolua_S){
  tolua_pushinteger(tolua_S,(lua_Integer)Entity::getCount());
 return 1;
}
/* get function: index of class  Entity */
static int tolua_get_Entity_index(lua_State* tolua_S){
  Entity* self = (Entity*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'index'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getIndex());
 return 1;
}
/* method: clear of class  Entity */
static int tolua_LuaBinding_Entity_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Entity::clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Entity.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: getComIndex of class  Entity */
static int tolua_LuaBinding_Entity_getComIndex00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  Entity::getComIndex(name);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Entity.getComIndex'.",&tolua_err);
 return 0;
#endif
}
/* method: tryGetComIndex of class  Entity */
static int tolua_LuaBinding_Entity_tryGetComIndex00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  Entity::tryGetComIndex(name);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Entity.tryGetComIndex'.",&tolua_err);
 return 0;
#endif
}
/* method: destroy of class  Entity */
static int tolua_LuaBinding_Entity_destroy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Entity"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Entity* self = (Entity*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Entity.destroy'", NULL);
#endif
  TOLUA_TRY
  {
   self->destroy();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Entity.destroy'.",&tolua_err);
 return 0;
#endif
}
/* get function: count of class  EntityGroup */
static int tolua_get_EntityGroup_count(lua_State* tolua_S){
  EntityGroup* self = (EntityGroup*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'count'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getCount());
 return 1;
}
/* get function: first of class  EntityGroup */
static int tolua_get_EntityGroup_first_ptr(lua_State* tolua_S){
  EntityGroup* self = (EntityGroup*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'first'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getFirst());
 return 1;
}
/* method: each of class  EntityGroup */
static int tolua_LuaBinding_Group_each00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"EntityGroup"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  EntityGroup* self = (EntityGroup*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EntityGroup.each'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->each(func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EntityGroup.each'.",&tolua_err);
 return 0;
#endif
}
/* method: find of class  EntityGroup */
static int tolua_LuaBinding_Group_find00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"EntityGroup"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  EntityGroup* self = (EntityGroup*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EntityGroup.find'", NULL);
#endif
  TOLUA_TRY
  {
   Entity* tolua_ret = (Entity*)  self->find(func);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EntityGroup.find'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  EntityGroup */
static int tolua_LuaBinding_Group_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* components = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    components[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   EntityGroup* tolua_ret = (EntityGroup*)  EntityGroup::create(components,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(components);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EntityGroup.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  EntityObserver */
static int tolua_LuaBinding_Observer_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice option =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* components = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    components[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   tolua_outside EntityObserver* tolua_ret = (tolua_outside EntityObserver*)  EntityObserver_create(option,components,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(components);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EntityObserver.new'.",&tolua_err);
 return 0;
#endif
}
/* method: getExt of class  Path */
static int tolua_LuaBinding_Path_getExt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::getExt(path);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.getExt'.",&tolua_err);
 return 0;
#endif
}
/* method: getPath of class  Path */
static int tolua_LuaBinding_Path_getPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::getPath(path);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.getPath'.",&tolua_err);
 return 0;
#endif
}
/* method: getName of class  Path */
static int tolua_LuaBinding_Path_getName00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::getName(path);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.getName'.",&tolua_err);
 return 0;
#endif
}
/* method: getFilename of class  Path */
static int tolua_LuaBinding_Path_getFilename00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::getFilename(path);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.getFilename'.",&tolua_err);
 return 0;
#endif
}
/* method: getRelative of class  Path */
static int tolua_LuaBinding_Path_getRelative00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice target =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::getRelative(path,target);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.getRelative'.",&tolua_err);
 return 0;
#endif
}
/* method: replaceExt of class  Path */
static int tolua_LuaBinding_Path_replaceExt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice newExt =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::replaceExt(path,newExt);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.replaceExt'.",&tolua_err);
 return 0;
#endif
}
/* method: replaceFilename of class  Path */
static int tolua_LuaBinding_Path_replaceFilename00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice newFile =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   string tolua_ret = (string)  Path::replaceFilename(path,newFile);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Path.replaceFilename'.",&tolua_err);
 return 0;
#endif
}
/* get function: assetPath of class  Content */
static int tolua_get_Content_assetPath(lua_State* tolua_S){
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'assetPath'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getAssetPath());
 return 1;
}
/* set function: assetPath of class  Content */
static int tolua_set_Content_assetPath(lua_State* tolua_S){
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Content.assetPath'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Content.assetPath'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAssetPath(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: writablePath of class  Content */
static int tolua_get_Content_writablePath(lua_State* tolua_S){
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'writablePath'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getWritablePath());
 return 1;
}
/* set function: writablePath of class  Content */
static int tolua_set_Content_writablePath(lua_State* tolua_S){
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Content.writablePath'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Content.writablePath'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWritablePath(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: appPath of class  Content */
static int tolua_get_Content_appPath(lua_State* tolua_S){
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'appPath'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getAppPath());
 return 1;
}
/* method: save of class  Content */
static int tolua_LuaBinding_Content_save00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice content =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.save'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->save(filename,content);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.save'.",&tolua_err);
 return 0;
#endif
}
/* method: exist of class  Content */
static int tolua_LuaBinding_Content_exist00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.exist'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->exist(filename);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.exist'.",&tolua_err);
 return 0;
#endif
}
/* method: createFolder of class  Content */
static int tolua_LuaBinding_Content_mkdir00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.createFolder'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->createFolder(path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.mkdir'.",&tolua_err);
 return 0;
#endif
}
/* method: isFolder of class  Content */
static int tolua_LuaBinding_Content_isdir00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.isFolder'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isFolder(path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.isdir'.",&tolua_err);
 return 0;
#endif
}
/* method: isAbsolutePath of class  Content */
static int tolua_LuaBinding_Content_isAbsolutePath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.isAbsolutePath'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isAbsolutePath(path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.isAbsolutePath'.",&tolua_err);
 return 0;
#endif
}
/* method: copy of class  Content */
static int tolua_LuaBinding_Content_copy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice src =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice dst =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.copy'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->copy(src,dst);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.copy'.",&tolua_err);
 return 0;
#endif
}
/* method: move of class  Content */
static int tolua_LuaBinding_Content_move00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice src =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice dst =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.move'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->move(src,dst);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.move'.",&tolua_err);
 return 0;
#endif
}
/* method: remove of class  Content */
static int tolua_LuaBinding_Content_remove00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.remove'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->remove(path);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.remove'.",&tolua_err);
 return 0;
#endif
}
/* method: getFullPath of class  Content */
static int tolua_LuaBinding_Content_getFullPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.getFullPath'", NULL);
#endif
  TOLUA_TRY
  {
   string tolua_ret = (string)  self->getFullPath(filename);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.getFullPath'.",&tolua_err);
 return 0;
#endif
}
/* method: Content_insertSearchPath of class  Content */
static int tolua_LuaBinding_Content_insertSearchPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
  int index =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.Content_insertSearchPath'", NULL);
#endif
  TOLUA_TRY
  {
   Content_insertSearchPath(self,index,path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.insertSearchPath'.",&tolua_err);
 return 0;
#endif
}
/* method: addSearchPath of class  Content */
static int tolua_LuaBinding_Content_addSearchPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.addSearchPath'", NULL);
#endif
  TOLUA_TRY
  {
   self->addSearchPath(path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.addSearchPath'.",&tolua_err);
 return 0;
#endif
}
/* method: removeSearchPath of class  Content */
static int tolua_LuaBinding_Content_removeSearchPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.removeSearchPath'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeSearchPath(path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.removeSearchPath'.",&tolua_err);
 return 0;
#endif
}
/* method: loadAsync of class  Content */
static int tolua_LuaBinding_Content_loadAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> handler(tolua_ref_function(tolua_S,3));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.loadAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->loadAsync(filename,handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.loadAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: saveAsync of class  Content */
static int tolua_LuaBinding_Content_saveAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,4,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice content =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  LuaFunction<void> handler(tolua_ref_function(tolua_S,4));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.saveAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->saveAsync(filename,content,handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.saveAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: copyAsync of class  Content */
static int tolua_LuaBinding_Content_copyAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,4,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice src =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice dst =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  LuaFunction<void> handler(tolua_ref_function(tolua_S,4));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.copyAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->copyAsync(src,dst,handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.copyAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: zipAsync of class  Content */
static int tolua_LuaBinding_Content_zipAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,4,&tolua_err) ||
  !tolua_isfunction(tolua_S,5,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice folderPath =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice zipFile =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  LuaFunction<bool> filter(tolua_ref_function(tolua_S,4));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,5));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.zipAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->zipAsync(folderPath,zipFile,filter,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.zipAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: unzipAsync of class  Content */
static int tolua_LuaBinding_Content_unzipAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,4,&tolua_err) ||
  !tolua_isfunction(tolua_S,5,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice zipFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice folderPath =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  LuaFunction<bool> filter(tolua_ref_function(tolua_S,4));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,5));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.unzipAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->unzipAsync(zipFile,folderPath,filter,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.unzipAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: clearPathCache of class  Content */
static int tolua_LuaBinding_Content_clearPathCache00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.clearPathCache'", NULL);
#endif
  TOLUA_TRY
  {
   self->clearPathCache();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.clearPathCache'.",&tolua_err);
 return 0;
#endif
}
/* method: Content_getDirs of class  Content */
static int tolua_LuaBinding_Content_getDirs00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.Content_getDirs'", NULL);
#endif
  TOLUA_TRY
  {
   Content_getDirs(self,path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.getDirs'.",&tolua_err);
 return 0;
#endif
}
/* method: Content_getFiles of class  Content */
static int tolua_LuaBinding_Content_getFiles00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.Content_getFiles'", NULL);
#endif
  TOLUA_TRY
  {
   Content_getFiles(self,path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.getFiles'.",&tolua_err);
 return 0;
#endif
}
/* method: Content_getAllFiles of class  Content */
static int tolua_LuaBinding_Content_getAllFiles00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice path =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.Content_getAllFiles'", NULL);
#endif
  TOLUA_TRY
  {
   Content_getAllFiles(self,path);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.getAllFiles'.",&tolua_err);
 return 0;
#endif
}
/* method: Content_loadFile of class  Content */
static int tolua_LuaBinding_Content_load00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Content"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Content* self = (Content*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Content.Content_loadFile'", NULL);
#endif
  TOLUA_TRY
  {
   Content_loadFile(self,filename);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.load'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Content */
static int tolua_LuaBinding_Content_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Content* tolua_ret = (tolua_outside Content*)  Content_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Content>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Content.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: name of class  Listener */
static int tolua_get_Listener_name(lua_State* tolua_S){
  Listener* self = (Listener*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'name'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getName());
 return 1;
}
/* get function: enabled of class  Listener */
static int tolua_get_Listener_enabled(lua_State* tolua_S){
  Listener* self = (Listener*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'enabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEnabled());
 return 1;
}
/* set function: enabled of class  Listener */
static int tolua_set_Listener_enabled(lua_State* tolua_S){
  Listener* self = (Listener*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Listener.enabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Listener.enabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: timeScale of class  Scheduler */
static int tolua_get_Scheduler_timeScale(lua_State* tolua_S){
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'timeScale'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getTimeScale());
 return 1;
}
/* set function: timeScale of class  Scheduler */
static int tolua_set_Scheduler_timeScale(lua_State* tolua_S){
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Scheduler.timeScale'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Scheduler.timeScale'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTimeScale(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: fixedFPS of class  Scheduler */
static int tolua_get_Scheduler_fixedFPS(lua_State* tolua_S){
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fixedFPS'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getFixedFPS());
 return 1;
}
/* set function: fixedFPS of class  Scheduler */
static int tolua_set_Scheduler_fixedFPS(lua_State* tolua_S){
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Scheduler.fixedFPS'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Scheduler.fixedFPS'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFixedFPS(static_cast< int>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: schedule of class  Scheduler */
static int tolua_LuaBinding_Scheduler_schedule00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Scheduler"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Scheduler.schedule'", NULL);
#endif
  TOLUA_TRY
  {
   self->schedule(handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Scheduler.schedule'.",&tolua_err);
 return 0;
#endif
}
/* method: update of class  Scheduler */
static int tolua_LuaBinding_Scheduler_update00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Scheduler"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Scheduler* self = (Scheduler*)  tolua_tousertype(tolua_S,1,0);
  double deltaTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Scheduler.update'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->update(deltaTime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Scheduler.update'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Scheduler */
static int tolua_LuaBinding_Scheduler_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Scheduler* tolua_ret = (Scheduler*)  Scheduler::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Scheduler.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: name of class  Camera */
static int tolua_get_Camera_name(lua_State* tolua_S){
  Camera* self = (Camera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'name'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getName());
 return 1;
}
/* get function: rotation of class  Camera2D */
static int tolua_get_Camera2D_rotation(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rotation'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getRotation());
 return 1;
}
/* set function: rotation of class  Camera2D */
static int tolua_set_Camera2D_rotation(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Camera2D.rotation'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Camera2D.rotation'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRotation(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: zoom of class  Camera2D */
static int tolua_get_Camera2D_zoom(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'zoom'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getZoom());
 return 1;
}
/* set function: zoom of class  Camera2D */
static int tolua_set_Camera2D_zoom(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Camera2D.zoom'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Camera2D.zoom'",&tolua_err);
#endif
  TOLUA_TRY
  self->setZoom(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: position of class  Camera2D */
static int tolua_get_Camera2D_position(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  Camera2D */
static int tolua_set_Camera2D_position(lua_State* tolua_S){
  Camera2D* self = (Camera2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Camera2D.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Camera2D.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Camera2D */
static int tolua_LuaBinding_Camera2D_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   Camera2D* tolua_ret = (Camera2D*)  Camera2D::create(name);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Camera2D.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: position of class  CameraOtho */
static int tolua_get_CameraOtho_position(lua_State* tolua_S){
  CameraOtho* self = (CameraOtho*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  CameraOtho */
static int tolua_set_CameraOtho_position(lua_State* tolua_S){
  CameraOtho* self = (CameraOtho*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'CameraOtho.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'CameraOtho.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  CameraOtho */
static int tolua_LuaBinding_CameraOtho_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   CameraOtho* tolua_ret = (CameraOtho*)  CameraOtho::create(name);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<CameraOtho>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CameraOtho.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: clearColor of class  Director */
static int tolua_get_Director_clearColor(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'clearColor'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color)(self->getClearColor()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
 return 1;
}
/* set function: clearColor of class  Director */
static int tolua_set_Director_clearColor(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Director.clearColor'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Director.clearColor'",&tolua_err);
#endif
  TOLUA_TRY
  self->setClearColor(* static_cast< Color*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scheduler of class  Director */
static int tolua_get_Director_scheduler_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scheduler'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getScheduler());
 return 1;
}
/* set function: scheduler of class  Director */
static int tolua_set_Director_scheduler_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Director.scheduler'",NULL);
  if (!tolua_isobject(tolua_S,2,"Scheduler"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Director.scheduler'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScheduler(static_cast< Scheduler*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: uI of class  Director */
static int tolua_get_Director_ui_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'uI'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getUI());
 return 1;
}
/* get function: uI3D of class  Director */
static int tolua_get_Director_ui3D_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'uI3D'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getUI3D());
 return 1;
}
/* get function: entry of class  Director */
static int tolua_get_Director_entry_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'entry'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEntry());
 return 1;
}
/* get function: postNode of class  Director */
static int tolua_get_Director_postNode_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'postNode'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPostNode());
 return 1;
}
/* get function: systemScheduler of class  Director */
static int tolua_get_Director_systemScheduler_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'systemScheduler'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getSystemScheduler());
 return 1;
}
/* get function: postScheduler of class  Director */
static int tolua_get_Director_postScheduler_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'postScheduler'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPostScheduler());
 return 1;
}
/* get function: currentCamera of class  Director */
static int tolua_get_Director_currentCamera_ptr(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'currentCamera'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getCurrentCamera());
 return 1;
}
/* get function: frustumCulling of class  Director */
static int tolua_get_Director_frustumCulling(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'frustumCulling'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFrustumCulling());
 return 1;
}
/* set function: frustumCulling of class  Director */
static int tolua_set_Director_frustumCulling(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Director.frustumCulling'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Director.frustumCulling'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFrustumCulling(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: profilerSending of class  Director */
static int tolua_get_Director_profilerSending(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'profilerSending'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isProfilerSending());
 return 1;
}
/* set function: profilerSending of class  Director */
static int tolua_set_Director_profilerSending(lua_State* tolua_S){
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Director.profilerSending'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Director.profilerSending'",&tolua_err);
#endif
  TOLUA_TRY
  self->setProfilerSending(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: pushCamera of class  Director */
static int tolua_LuaBinding_Director_pushCamera00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Director"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Camera"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
  Camera* camera =  static_cast< Camera*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Director.pushCamera'", NULL);
#endif
  TOLUA_TRY
  {
   self->pushCamera(camera);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.pushCamera'.",&tolua_err);
 return 0;
#endif
}
/* method: popCamera of class  Director */
static int tolua_LuaBinding_Director_popCamera00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Director"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Director.popCamera'", NULL);
#endif
  TOLUA_TRY
  {
   self->popCamera();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.popCamera'.",&tolua_err);
 return 0;
#endif
}
/* method: removeCamera of class  Director */
static int tolua_LuaBinding_Director_removeCamera00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Director"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Camera"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
  Camera* camera =  static_cast< Camera*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Director.removeCamera'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->removeCamera(camera);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.removeCamera'.",&tolua_err);
 return 0;
#endif
}
/* method: clearCamera of class  Director */
static int tolua_LuaBinding_Director_clearCamera00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Director"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Director.clearCamera'", NULL);
#endif
  TOLUA_TRY
  {
   self->clearCamera();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.clearCamera'.",&tolua_err);
 return 0;
#endif
}
/* method: cleanup of class  Director */
static int tolua_LuaBinding_Director_cleanup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Director"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Director* self = (Director*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Director.cleanup'", NULL);
#endif
  TOLUA_TRY
  {
   self->cleanup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.cleanup'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Director */
static int tolua_LuaBinding_Director_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Director* tolua_ret = (tolua_outside Director*)  Director_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Director>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Director.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: size of class  View */
static int tolua_get_View_size(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'size'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getSize()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* get function: standardDistance of class  View */
static int tolua_get_View_standardDistance(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'standardDistance'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getStandardDistance());
 return 1;
}
/* get function: aspectRatio of class  View */
static int tolua_get_View_aspectRatio(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'aspectRatio'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAspectRatio());
 return 1;
}
/* get function: nearPlaneDistance of class  View */
static int tolua_get_View_nearPlaneDistance(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'nearPlaneDistance'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getNearPlaneDistance());
 return 1;
}
/* set function: nearPlaneDistance of class  View */
static int tolua_set_View_nearPlaneDistance(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.nearPlaneDistance'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.nearPlaneDistance'",&tolua_err);
#endif
  TOLUA_TRY
  self->setNearPlaneDistance(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: farPlaneDistance of class  View */
static int tolua_get_View_farPlaneDistance(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'farPlaneDistance'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getFarPlaneDistance());
 return 1;
}
/* set function: farPlaneDistance of class  View */
static int tolua_set_View_farPlaneDistance(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.farPlaneDistance'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.farPlaneDistance'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFarPlaneDistance(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: fieldOfView of class  View */
static int tolua_get_View_fieldOfView(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fieldOfView'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getFieldOfView());
 return 1;
}
/* set function: fieldOfView of class  View */
static int tolua_set_View_fieldOfView(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.fieldOfView'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.fieldOfView'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFieldOfView(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scale of class  View */
static int tolua_get_View_scale(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scale'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getScale());
 return 1;
}
/* set function: scale of class  View */
static int tolua_set_View_scale(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.scale'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.scale'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScale(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: postEffect of class  View */
static int tolua_get_View_postEffect_ptr(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'postEffect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPostEffect());
 return 1;
}
/* set function: postEffect of class  View */
static int tolua_set_View_postEffect_ptr(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.postEffect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.postEffect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPostEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: vSync of class  View */
static int tolua_get_View_vsync(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'vSync'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isVSync());
 return 1;
}
/* set function: vSync of class  View */
static int tolua_set_View_vsync(lua_State* tolua_S){
  View* self = (View*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'View.vSync'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'View.vSync'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVSync(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  View */
static int tolua_LuaBinding_View_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside View* tolua_ret = (tolua_outside View*)  View_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<View>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'View.new'.",&tolua_err);
 return 0;
#endif
}
/* function: Dora_Log */
static int tolua_LuaBinding_Log00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice level =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
   Slice msg =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Dora_Log(level,msg);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Log'.",&tolua_err);
 return 0;
#endif
}
/* method: add of class  Slot */
static int tolua_LuaBinding_Slot_add00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Slot"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Slot* self = (Slot*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<void> handler(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Slot.add'", NULL);
#endif
  TOLUA_TRY
  {
   self->add(handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Slot.add'.",&tolua_err);
 return 0;
#endif
}
/* method: set of class  Slot */
static int tolua_LuaBinding_Slot_set00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Slot"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Slot* self = (Slot*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<void> handler(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Slot.set'", NULL);
#endif
  TOLUA_TRY
  {
   self->set(handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Slot.set'.",&tolua_err);
 return 0;
#endif
}
/* method: remove of class  Slot */
static int tolua_LuaBinding_Slot_remove00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Slot"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Slot* self = (Slot*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<void> handler(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Slot.remove'", NULL);
#endif
  TOLUA_TRY
  {
   self->remove(handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Slot.remove'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Slot */
static int tolua_LuaBinding_Slot_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Slot"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Slot* self = (Slot*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Slot.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Slot.clear'.",&tolua_err);
 return 0;
#endif
}
/* get function: duration of class  Action */
static int tolua_get_Action_duration(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'duration'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDuration());
 return 1;
}
/* get function: running of class  Action */
static int tolua_get_Action_running(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'running'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isRunning());
 return 1;
}
/* get function: paused of class  Action */
static int tolua_get_Action_paused(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'paused'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPaused());
 return 1;
}
/* get function: reversed of class  Action */
static int tolua_get_Action_reversed(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'reversed'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isReversed());
 return 1;
}
/* set function: reversed of class  Action */
static int tolua_set_Action_reversed(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Action.reversed'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Action.reversed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setReversed(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: speed of class  Action */
static int tolua_get_Action_speed(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'speed'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSpeed());
 return 1;
}
/* set function: speed of class  Action */
static int tolua_set_Action_speed(lua_State* tolua_S){
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Action.speed'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Action.speed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSpeed(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: pause of class  Action */
static int tolua_LuaBinding_Action_pause00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Action"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Action.pause'", NULL);
#endif
  TOLUA_TRY
  {
   self->pause();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Action.pause'.",&tolua_err);
 return 0;
#endif
}
/* method: resume of class  Action */
static int tolua_LuaBinding_Action_resume00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Action"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Action.resume'", NULL);
#endif
  TOLUA_TRY
  {
   self->resume();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Action.resume'.",&tolua_err);
 return 0;
#endif
}
/* method: updateTo of class  Action */
static int tolua_LuaBinding_Action_updateTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Action"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Action* self = (Action*)  tolua_tousertype(tolua_S,1,0);
  float elapsed =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  bool reversed =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Action.updateTo'", NULL);
#endif
  TOLUA_TRY
  {
   self->updateTo(elapsed,reversed);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Action.updateTo'.",&tolua_err);
 return 0;
#endif
}
/* get function: order of class  Node */
static int tolua_get_Node_order(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'order'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getOrder());
 return 1;
}
/* set function: order of class  Node */
static int tolua_set_Node_order(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.order'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.order'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOrder(static_cast< int>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: angle of class  Node */
static int tolua_get_Node_angle(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngle());
 return 1;
}
/* set function: angle of class  Node */
static int tolua_set_Node_angle(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.angle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.angle'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngle(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: angleX of class  Node */
static int tolua_get_Node_angleX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angleX'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngleX());
 return 1;
}
/* set function: angleX of class  Node */
static int tolua_set_Node_angleX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.angleX'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.angleX'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngleX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: angleY of class  Node */
static int tolua_get_Node_angleY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angleY'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngleY());
 return 1;
}
/* set function: angleY of class  Node */
static int tolua_set_Node_angleY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.angleY'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.angleY'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngleY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scaleX of class  Node */
static int tolua_get_Node_scaleX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scaleX'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getScaleX());
 return 1;
}
/* set function: scaleX of class  Node */
static int tolua_set_Node_scaleX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.scaleX'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.scaleX'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScaleX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scaleY of class  Node */
static int tolua_get_Node_scaleY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scaleY'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getScaleY());
 return 1;
}
/* set function: scaleY of class  Node */
static int tolua_set_Node_scaleY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.scaleY'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.scaleY'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScaleY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scaleZ of class  Node */
static int tolua_get_Node_scaleZ(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scaleZ'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getScaleZ());
 return 1;
}
/* set function: scaleZ of class  Node */
static int tolua_set_Node_scaleZ(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.scaleZ'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.scaleZ'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScaleZ(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: x of class  Node */
static int tolua_get_Node_x(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'x'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getX());
 return 1;
}
/* set function: x of class  Node */
static int tolua_set_Node_x(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.x'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.x'",&tolua_err);
#endif
  TOLUA_TRY
  self->setX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: y of class  Node */
static int tolua_get_Node_y(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'y'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getY());
 return 1;
}
/* set function: y of class  Node */
static int tolua_set_Node_y(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.y'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.y'",&tolua_err);
#endif
  TOLUA_TRY
  self->setY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: z of class  Node */
static int tolua_get_Node_z(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'z'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getZ());
 return 1;
}
/* set function: z of class  Node */
static int tolua_set_Node_z(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.z'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.z'",&tolua_err);
#endif
  TOLUA_TRY
  self->setZ(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: position of class  Node */
static int tolua_get_Node_position(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  Node */
static int tolua_set_Node_position(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: skewX of class  Node */
static int tolua_get_Node_skewX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'skewX'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSkewX());
 return 1;
}
/* set function: skewX of class  Node */
static int tolua_set_Node_skewX(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.skewX'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.skewX'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSkewX(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: skewY of class  Node */
static int tolua_get_Node_skewY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'skewY'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSkewY());
 return 1;
}
/* set function: skewY of class  Node */
static int tolua_set_Node_skewY(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.skewY'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.skewY'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSkewY(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: visible of class  Node */
static int tolua_get_Node_visible(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'visible'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isVisible());
 return 1;
}
/* set function: visible of class  Node */
static int tolua_set_Node_visible(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.visible'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.visible'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVisible(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: anchor of class  Node */
static int tolua_get_Node_anchor(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'anchor'",NULL);
#endif
  Vec2 tolua_obj =  self->getAnchor();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: anchor of class  Node */
static int tolua_set_Node_anchor(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.anchor'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.anchor'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAnchor(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: width of class  Node */
static int tolua_get_Node_width(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getWidth());
 return 1;
}
/* set function: width of class  Node */
static int tolua_set_Node_width(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.width'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.width'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWidth(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: height of class  Node */
static int tolua_get_Node_height(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getHeight());
 return 1;
}
/* set function: height of class  Node */
static int tolua_set_Node_height(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.height'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.height'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHeight(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: size of class  Node */
static int tolua_get_Node_size(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'size'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getSize()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* set function: size of class  Node */
static int tolua_set_Node_size(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.size'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.size'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSize(* static_cast< Size*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: tag of class  Node */
static int tolua_get_Node_tag(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tag'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getTag());
 return 1;
}
/* set function: tag of class  Node */
static int tolua_set_Node_tag(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.tag'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.tag'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTag(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: opacity of class  Node */
static int tolua_get_Node_opacity(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'opacity'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getOpacity());
 return 1;
}
/* set function: opacity of class  Node */
static int tolua_set_Node_opacity(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.opacity'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.opacity'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOpacity(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: color of class  Node */
static int tolua_get_Node_color(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'color'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color)(self->getColor()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
 return 1;
}
/* set function: color of class  Node */
static int tolua_set_Node_color(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.color'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.color'",&tolua_err);
#endif
  TOLUA_TRY
  self->setColor(* static_cast< Color*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: color3 of class  Node */
static int tolua_get_Node_color3(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'color3'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color3)(self->getColor3()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color3>());
 return 1;
}
/* set function: color3 of class  Node */
static int tolua_set_Node_color3(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.color3'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color3"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.color3'",&tolua_err);
#endif
  TOLUA_TRY
  self->setColor3(* static_cast< Color3*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: passOpacity of class  Node */
static int tolua_get_Node_passOpacity(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'passOpacity'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPassOpacity());
 return 1;
}
/* set function: passOpacity of class  Node */
static int tolua_set_Node_passOpacity(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.passOpacity'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.passOpacity'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPassOpacity(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: passColor3 of class  Node */
static int tolua_get_Node_passColor3(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'passColor3'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPassColor3());
 return 1;
}
/* set function: passColor3 of class  Node */
static int tolua_set_Node_passColor3(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.passColor3'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.passColor3'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPassColor3(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: transformTarget of class  Node */
static int tolua_get_Node_transformTarget_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'transformTarget'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getTransformTarget());
 return 1;
}
/* set function: transformTarget of class  Node */
static int tolua_set_Node_transformTarget_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.transformTarget'",NULL);
  if (!tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.transformTarget'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTransformTarget(static_cast< Node*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: scheduler of class  Node */
static int tolua_get_Node_scheduler_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scheduler'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getScheduler());
 return 1;
}
/* set function: scheduler of class  Node */
static int tolua_set_Node_scheduler_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.scheduler'",NULL);
  if (!tolua_isobject(tolua_S,2,"Scheduler"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.scheduler'",&tolua_err);
#endif
  TOLUA_TRY
  self->setScheduler(static_cast< Scheduler*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: hasChildren of class  Node */
static int tolua_get_Node_hasChildren(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'hasChildren'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->hasChildren());
 return 1;
}
/* get function: children of class  Node */
static int tolua_get_Node_children_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'children'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getChildren());
 return 1;
}
/* get function: parent of class  Node */
static int tolua_get_Node_parent_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'parent'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getParent());
 return 1;
}
/* get function: running of class  Node */
static int tolua_get_Node_running(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'running'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isRunning());
 return 1;
}
/* get function: scheduled of class  Node */
static int tolua_get_Node_scheduled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'scheduled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isScheduled());
 return 1;
}
/* get function: actionCount of class  Node */
static int tolua_get_Node_actionCount(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'actionCount'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getActionCount());
 return 1;
}
/* get function: userData of class  Node */
static int tolua_get_Node_data_ptr(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'userData'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getUserData());
 return 1;
}
/* get function: touchEnabled of class  Node */
static int tolua_get_Node_touchEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'touchEnabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isTouchEnabled());
 return 1;
}
/* set function: touchEnabled of class  Node */
static int tolua_set_Node_touchEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.touchEnabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.touchEnabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTouchEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: swallowTouches of class  Node */
static int tolua_get_Node_swallowTouches(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'swallowTouches'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isSwallowTouches());
 return 1;
}
/* set function: swallowTouches of class  Node */
static int tolua_set_Node_swallowTouches(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.swallowTouches'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.swallowTouches'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSwallowTouches(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: swallowMouseWheel of class  Node */
static int tolua_get_Node_swallowMouseWheel(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'swallowMouseWheel'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isSwallowMouseWheel());
 return 1;
}
/* set function: swallowMouseWheel of class  Node */
static int tolua_set_Node_swallowMouseWheel(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.swallowMouseWheel'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.swallowMouseWheel'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSwallowMouseWheel(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: keyboardEnabled of class  Node */
static int tolua_get_Node_keyboardEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'keyboardEnabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isKeyboardEnabled());
 return 1;
}
/* set function: keyboardEnabled of class  Node */
static int tolua_set_Node_keyboardEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.keyboardEnabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.keyboardEnabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setKeyboardEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: controllerEnabled of class  Node */
static int tolua_get_Node_controllerEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'controllerEnabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isControllerEnabled());
 return 1;
}
/* set function: controllerEnabled of class  Node */
static int tolua_set_Node_controllerEnabled(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.controllerEnabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.controllerEnabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setControllerEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: renderGroup of class  Node */
static int tolua_get_Node_renderGroup(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'renderGroup'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isRenderGroup());
 return 1;
}
/* set function: renderGroup of class  Node */
static int tolua_set_Node_renderGroup(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.renderGroup'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.renderGroup'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRenderGroup(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: showDebug of class  Node */
static int tolua_get_Node_showDebug(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'showDebug'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isShowDebug());
 return 1;
}
/* set function: showDebug of class  Node */
static int tolua_set_Node_showDebug(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.showDebug'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.showDebug'",&tolua_err);
#endif
  TOLUA_TRY
  self->setShowDebug(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: renderOrder of class  Node */
static int tolua_get_Node_renderOrder(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'renderOrder'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getRenderOrder());
 return 1;
}
/* set function: renderOrder of class  Node */
static int tolua_set_Node_renderOrder(lua_State* tolua_S){
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Node.renderOrder'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Node.renderOrder'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRenderOrder(static_cast< int>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: addChild of class  Node */
static int tolua_LuaBinding_Node_addChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* child =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  int order =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
   Slice tag =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->addChild(child,order,tag);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.addChild'.",&tolua_err);
 return 0;
#endif
}
/* method: addChild of class  Node */
static int tolua_LuaBinding_Node_addChild01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* child =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  int order =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->addChild(child,order);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Node_addChild00(tolua_S);
}
/* method: addChild of class  Node */
static int tolua_LuaBinding_Node_addChild02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* child =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->addChild(child);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Node_addChild01(tolua_S);
}
/* method: addTo of class  Node */
static int tolua_LuaBinding_Node_addTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* parent =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  int order =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
   Slice tag =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addTo'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->addTo(parent,order,tag);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.addTo'.",&tolua_err);
 return 0;
#endif
}
/* method: addTo of class  Node */
static int tolua_LuaBinding_Node_addTo01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* parent =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  int order =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addTo'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->addTo(parent,order);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_addTo00(tolua_S);
}
/* method: addTo of class  Node */
static int tolua_LuaBinding_Node_addTo02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* parent =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.addTo'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->addTo(parent);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_addTo01(tolua_S);
}
/* method: removeChild of class  Node */
static int tolua_LuaBinding_Node_removeChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* child =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  bool cleanup =  static_cast< bool>(tolua_toboolean(tolua_S,3,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.removeChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeChild(child,cleanup);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.removeChild'.",&tolua_err);
 return 0;
#endif
}
/* method: removeChildByTag of class  Node */
static int tolua_LuaBinding_Node_removeChildByTag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
   Slice tag =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool cleanup =  static_cast< bool>(tolua_toboolean(tolua_S,3,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.removeChildByTag'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeChildByTag(tag,cleanup);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.removeChildByTag'.",&tolua_err);
 return 0;
#endif
}
/* method: removeAllChildren of class  Node */
static int tolua_LuaBinding_Node_removeAllChildren00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  bool cleanup =  static_cast< bool>(tolua_toboolean(tolua_S,2,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.removeAllChildren'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeAllChildren(cleanup);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.removeAllChildren'.",&tolua_err);
 return 0;
#endif
}
/* method: removeFromParent of class  Node */
static int tolua_LuaBinding_Node_removeFromParent00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  bool cleanup =  static_cast< bool>(tolua_toboolean(tolua_S,2,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.removeFromParent'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeFromParent(cleanup);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.removeFromParent'.",&tolua_err);
 return 0;
#endif
}
/* method: moveToParent of class  Node */
static int tolua_LuaBinding_Node_moveToParent00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Node* parent =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.moveToParent'", NULL);
#endif
  TOLUA_TRY
  {
   self->moveToParent(parent);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.moveToParent'.",&tolua_err);
 return 0;
#endif
}
/* method: cleanup of class  Node */
static int tolua_LuaBinding_Node_cleanup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.cleanup'", NULL);
#endif
  TOLUA_TRY
  {
   self->cleanup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.cleanup'.",&tolua_err);
 return 0;
#endif
}
/* method: getChildByTag of class  Node */
static int tolua_LuaBinding_Node_getChildByTag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
   Slice tag =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.getChildByTag'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->getChildByTag(tag);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.getChildByTag'.",&tolua_err);
 return 0;
#endif
}
/* method: schedule of class  Node */
static int tolua_LuaBinding_Node_schedule00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.schedule'", NULL);
#endif
  TOLUA_TRY
  {
   self->schedule(func);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.schedule'.",&tolua_err);
 return 0;
#endif
}
/* method: unschedule of class  Node */
static int tolua_LuaBinding_Node_unschedule00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.unschedule'", NULL);
#endif
  TOLUA_TRY
  {
   self->unschedule();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.unschedule'.",&tolua_err);
 return 0;
#endif
}
/* method: onUpdate of class  Node */
static int tolua_LuaBinding_Node_onUpdate00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.onUpdate'", NULL);
#endif
  TOLUA_TRY
  {
   self->onUpdate(func);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.onUpdate'.",&tolua_err);
 return 0;
#endif
}
/* method: onRender of class  Node */
static int tolua_LuaBinding_Node_onRender00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.onRender'", NULL);
#endif
  TOLUA_TRY
  {
   self->onRender(func);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.onRender'.",&tolua_err);
 return 0;
#endif
}
/* method: convertToNodeSpace of class  Node */
static int tolua_LuaBinding_Node_convertToNodeSpace00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 worldPoint = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.convertToNodeSpace'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->convertToNodeSpace(worldPoint);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.convertToNodeSpace'.",&tolua_err);
 return 0;
#endif
}
/* method: convertToNodeSpace of class  Node */
static int tolua_LuaBinding_Node_convertToNodeSpace01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 worldPoint = tolua_tolight(tolua_S,2);
  float zInOut =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.convertToNodeSpace'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->convertToNodeSpace(worldPoint,zInOut);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
   tolua_pushnumber(tolua_S,(lua_Number)zInOut);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_Node_convertToNodeSpace00(tolua_S);
}
/* method: convertToWorldSpace of class  Node */
static int tolua_LuaBinding_Node_convertToWorldSpace00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 nodePoint = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.convertToWorldSpace'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->convertToWorldSpace(nodePoint);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.convertToWorldSpace'.",&tolua_err);
 return 0;
#endif
}
/* method: convertToWorldSpace of class  Node */
static int tolua_LuaBinding_Node_convertToWorldSpace01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 nodePoint = tolua_tolight(tolua_S,2);
  float zInOut =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.convertToWorldSpace'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->convertToWorldSpace(nodePoint,zInOut);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
   tolua_pushnumber(tolua_S,(lua_Number)zInOut);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_Node_convertToWorldSpace00(tolua_S);
}
/* method: convertToWindowSpace of class  Node */
static int tolua_LuaBinding_Node_convertToWindowSpace00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 nodePoint = tolua_tolight(tolua_S,2);
  LuaFunction<void> callback(tolua_ref_function(tolua_S,3));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.convertToWindowSpace'", NULL);
#endif
  TOLUA_TRY
  {
   self->convertToWindowSpace(nodePoint,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.convertToWindowSpace'.",&tolua_err);
 return 0;
#endif
}
/* method: Node_eachChild of class  Node */
static int tolua_LuaBinding_Node_eachChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.Node_eachChild'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  Node_eachChild(self,func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.eachChild'.",&tolua_err);
 return 0;
#endif
}
/* method: traverse of class  Node */
static int tolua_LuaBinding_Node_traverse00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.traverse'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->traverse(func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.traverse'.",&tolua_err);
 return 0;
#endif
}
/* method: traverseAll of class  Node */
static int tolua_LuaBinding_Node_traverseAll00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.traverseAll'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->traverseAll(func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.traverseAll'.",&tolua_err);
 return 0;
#endif
}
/* method: runAction of class  Node */
static int tolua_LuaBinding_Node_runAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Action"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Action* action =  static_cast< Action*>(tolua_tousertype(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.runAction'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->runAction(action,loop);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.runAction'.",&tolua_err);
 return 0;
#endif
}
/* method: stopAllActions of class  Node */
static int tolua_LuaBinding_Node_stopAllActions00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.stopAllActions'", NULL);
#endif
  TOLUA_TRY
  {
   self->stopAllActions();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.stopAllActions'.",&tolua_err);
 return 0;
#endif
}
/* method: perform of class  Node */
static int tolua_LuaBinding_Node_perform00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Action"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Action* action =  static_cast< Action*>(tolua_tousertype(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.perform'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->perform(action,loop);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.perform'.",&tolua_err);
 return 0;
#endif
}
/* method: stopAction of class  Node */
static int tolua_LuaBinding_Node_stopAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Action"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Action* action =  static_cast< Action*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.stopAction'", NULL);
#endif
  TOLUA_TRY
  {
   self->stopAction(action);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.stopAction'.",&tolua_err);
 return 0;
#endif
}
/* method: alignItemsVertically of class  Node */
static int tolua_LuaBinding_Node_alignItemsVertically00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,2,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItemsVertically'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItemsVertically(padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.alignItemsVertically'.",&tolua_err);
 return 0;
#endif
}
/* method: alignItemsVertically of class  Node */
static int tolua_LuaBinding_Node_alignItemsVertically01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,3,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItemsVertically'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItemsVertically(size,padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_alignItemsVertically00(tolua_S);
}
/* method: alignItemsHorizontally of class  Node */
static int tolua_LuaBinding_Node_alignItemsHorizontally00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,2,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItemsHorizontally'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItemsHorizontally(padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.alignItemsHorizontally'.",&tolua_err);
 return 0;
#endif
}
/* method: alignItemsHorizontally of class  Node */
static int tolua_LuaBinding_Node_alignItemsHorizontally01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,3,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItemsHorizontally'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItemsHorizontally(size,padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_alignItemsHorizontally00(tolua_S);
}
/* method: alignItems of class  Node */
static int tolua_LuaBinding_Node_alignItems00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,2,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItems'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItems(padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.alignItems'.",&tolua_err);
 return 0;
#endif
}
/* method: alignItems of class  Node */
static int tolua_LuaBinding_Node_alignItems01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Size size = * static_cast< Size*>(tolua_tousertype(tolua_S,2,0));
  float padding =  static_cast< float>(tolua_tonumber(tolua_S,3,10.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.alignItems'", NULL);
#endif
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  self->alignItems(size,padding);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_alignItems00(tolua_S);
}
/* method: moveAndCullItems of class  Node */
static int tolua_LuaBinding_Node_moveAndCullItems00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  Vec2 delta = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.moveAndCullItems'", NULL);
#endif
  TOLUA_TRY
  {
   self->moveAndCullItems(delta);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.moveAndCullItems'.",&tolua_err);
 return 0;
#endif
}
/* method: attachIME of class  Node */
static int tolua_LuaBinding_Node_attachIME00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.attachIME'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachIME();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.attachIME'.",&tolua_err);
 return 0;
#endif
}
/* method: detachIME of class  Node */
static int tolua_LuaBinding_Node_detachIME00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.detachIME'", NULL);
#endif
  TOLUA_TRY
  {
   self->detachIME();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.detachIME'.",&tolua_err);
 return 0;
#endif
}
/* get function: camera of class  Grabber */
static int tolua_get_Node__Grabber_camera_ptr(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'camera'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getCamera());
 return 1;
}
/* set function: camera of class  Grabber */
static int tolua_set_Node__Grabber_camera_ptr(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grabber.camera'",NULL);
  if (!tolua_isobject(tolua_S,2,"Camera"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grabber.camera'",&tolua_err);
#endif
  TOLUA_TRY
  self->setCamera(static_cast< Camera*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: effect of class  Grabber */
static int tolua_get_Node__Grabber_effect_ptr(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'effect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEffect());
 return 1;
}
/* set function: effect of class  Grabber */
static int tolua_set_Node__Grabber_effect_ptr(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grabber.effect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grabber.effect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  Grabber */
static int tolua_get_Node__Grabber_blendFunc(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  Grabber */
static int tolua_set_Node__Grabber_blendFunc(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grabber.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grabber.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: clearColor of class  Grabber */
static int tolua_get_Node__Grabber_clearColor(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'clearColor'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color)(self->getClearColor()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
 return 1;
}
/* set function: clearColor of class  Grabber */
static int tolua_set_Node__Grabber_clearColor(lua_State* tolua_S){
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grabber.clearColor'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grabber.clearColor'",&tolua_err);
#endif
  TOLUA_TRY
  self->setClearColor(* static_cast< Color*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: Grabber_setPos of class  Grabber */
static int tolua_LuaBinding_Node_Grabber_setPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node::Grabber"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Vec2 pos = tolua_tolight(tolua_S,4);
  float z =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grabber.Grabber_setPos'", NULL);
#endif
  TOLUA_TRY
  {
   Grabber_setPos(self,x,y,pos,z);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grabber.setPos'.",&tolua_err);
 return 0;
#endif
}
/* method: Grabber_getPos of class  Grabber */
static int tolua_LuaBinding_Node_Grabber_getPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node::Grabber"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grabber.Grabber_getPos'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret = (tolua_outside Vec2)  Grabber_getPos(self,x,y);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grabber.getPos'.",&tolua_err);
 return 0;
#endif
}
/* method: Grabber_getColor of class  Grabber */
static int tolua_LuaBinding_Node_Grabber_getColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node::Grabber"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grabber.Grabber_getColor'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Color tolua_ret = (tolua_outside Color)  Grabber_getColor(self,x,y);
   {
 void* tolua_obj = Mtolua_new((Color)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grabber.getColor'.",&tolua_err);
 return 0;
#endif
}
/* method: Grabber_setColor of class  Grabber */
static int tolua_LuaBinding_Node_Grabber_setColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node::Grabber"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grabber.Grabber_setColor'", NULL);
#endif
  TOLUA_TRY
  {
   Grabber_setColor(self,x,y,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grabber.setColor'.",&tolua_err);
 return 0;
#endif
}
/* method: Grabber_moveUV of class  Grabber */
static int tolua_LuaBinding_Node_Grabber_moveUV00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node::Grabber"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node::Grabber* self = (Node::Grabber*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Vec2 offset = tolua_tolight(tolua_S,4);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grabber.Grabber_moveUV'", NULL);
#endif
  TOLUA_TRY
  {
   Grabber_moveUV(self,x,y,offset);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grabber.moveUV'.",&tolua_err);
 return 0;
#endif
}
/* method: grab of class  Node */
static int tolua_LuaBinding_Node_grab00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  bool enabled =  static_cast< bool>(tolua_toboolean(tolua_S,2,true));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.grab'", NULL);
#endif
  TOLUA_TRY
  {
   Node::Grabber* tolua_ret = (Node::Grabber*)  self->grab(enabled);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.grab'.",&tolua_err);
 return 0;
#endif
}
/* method: grab of class  Node */
static int tolua_LuaBinding_Node_grab01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Node* self = (Node*)  tolua_tousertype(tolua_S,1,0);
  uint32_t gridX =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  uint32_t gridY =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Node.grab'", NULL);
#endif
  TOLUA_TRY
  {
   Node::Grabber* tolua_ret = (Node::Grabber*)  self->grab(gridX,gridY);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Node_grab00(tolua_S);
}
/* method: new_local of class  Node */
static int tolua_LuaBinding_Node_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  Node::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Node.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: width of class  Texture2D */
static int tolua_get_Texture2D_width(lua_State* tolua_S){
  Texture2D* self = (Texture2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getWidth());
 return 1;
}
/* get function: height of class  Texture2D */
static int tolua_get_Texture2D_height(lua_State* tolua_S){
  Texture2D* self = (Texture2D*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getHeight());
 return 1;
}
/* method: new_local of class  Texture2D */
static int tolua_LuaBinding_Texture2D_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside Texture2D* tolua_ret = (tolua_outside Texture2D*)  Texture2D_create(filename);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Texture2D.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  BlendFunc */
static int tolua_LuaBinding_BlendFunc_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BlendFunc other = * static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   BlendFunc* tolua_ret = (BlendFunc*)  Mtolua_new((BlendFunc)(other));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<BlendFunc>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BlendFunc.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  BlendFunc */
static int tolua_LuaBinding_BlendFunc_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice src =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice dst =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   tolua_outside BlendFunc* tolua_ret = (tolua_outside BlendFunc*)  BlendFunc_create(src,dst);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<BlendFunc>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_BlendFunc_new00_local(tolua_S);
}
/* method: new_local of class  BlendFunc */
static int tolua_LuaBinding_BlendFunc_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isslice(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice srcColor =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice dstColor =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice srcAlpha =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
   Slice dstAlpha =  static_cast<  Slice>(tolua_toslice(tolua_S,5,0));
  TOLUA_TRY
  {
   tolua_outside BlendFunc* tolua_ret = (tolua_outside BlendFunc*)  BlendFunc_create(srcColor,dstColor,srcAlpha,dstAlpha);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<BlendFunc>());
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_BlendFunc_new01_local(tolua_S);
}
/* method: BlendFunc_get of class  BlendFunc */
static int tolua_LuaBinding_BlendFunc_get00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice func =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside uint32_t tolua_ret = (tolua_outside uint32_t)  BlendFunc_get(func);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BlendFunc.get'.",&tolua_err);
 return 0;
#endif
}
/* get function: Default of class  BlendFunc */
static int tolua_get_BlendFunc_Default(lua_State* tolua_S){
 void* tolua_obj = Mtolua_new((BlendFunc)(BlendFunc::Default));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<const BlendFunc>());
 return 1;
}
/* get function: grabPass of class  Pass */
static int tolua_get_Pass_grabPass(lua_State* tolua_S){
  Pass* self = (Pass*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'grabPass'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isGrabPass());
 return 1;
}
/* set function: grabPass of class  Pass */
static int tolua_set_Pass_grabPass(lua_State* tolua_S){
  Pass* self = (Pass*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Pass.grabPass'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Pass.grabPass'",&tolua_err);
#endif
  TOLUA_TRY
  self->setGrabPass(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: set of class  Pass */
static int tolua_LuaBinding_Pass_set00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Pass"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Pass* self = (Pass*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  float var1 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float var2 =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  float var3 =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  float var4 =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Pass.set'", NULL);
#endif
  TOLUA_TRY
  {
   self->set(name,var1,var2,var3,var4);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Pass.set'.",&tolua_err);
 return 0;
#endif
}
/* method: set of class  Pass */
static int tolua_LuaBinding_Pass_set01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Pass"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Pass* self = (Pass*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Color var = * static_cast< Color*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Pass.set'", NULL);
#endif
  TOLUA_TRY
  {
   self->set(name,var);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Pass_set00(tolua_S);
}
/* method: new_local of class  Pass */
static int tolua_LuaBinding_Pass_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice vertShader =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice fragShader =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   Pass* tolua_ret = (Pass*)  Pass::create(vertShader,fragShader);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Pass.new'.",&tolua_err);
 return 0;
#endif
}
/* method: add of class  Effect */
static int tolua_LuaBinding_Effect_add00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Effect"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Pass"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Effect* self = (Effect*)  tolua_tousertype(tolua_S,1,0);
  Pass* pass =  static_cast< Pass*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Effect.add'", NULL);
#endif
  TOLUA_TRY
  {
   self->add(pass);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Effect.add'.",&tolua_err);
 return 0;
#endif
}
/* method: Effect_get of class  Effect */
static int tolua_LuaBinding_Effect_get00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Effect"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Effect* self = (Effect*)  tolua_tousertype(tolua_S,1,0);
  size_t index =  static_cast< size_t>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Effect.Effect_get'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Pass* tolua_ret = (tolua_outside Pass*)  Effect_get(self,index);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Effect.get'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Effect */
static int tolua_LuaBinding_Effect_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Effect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Effect* self = (Effect*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Effect.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Effect.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Effect */
static int tolua_LuaBinding_Effect_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Effect* tolua_ret = (Effect*)  Effect::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Effect.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Effect */
static int tolua_LuaBinding_Effect_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice vertShader =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice fragShader =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   Effect* tolua_ret = (Effect*)  Effect::create(vertShader,fragShader);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Effect_new00_local(tolua_S);
}
/* method: new_local of class  SpriteEffect */
static int tolua_LuaBinding_SpriteEffect_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   SpriteEffect* tolua_ret = (SpriteEffect*)  SpriteEffect::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SpriteEffect.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  SpriteEffect */
static int tolua_LuaBinding_SpriteEffect_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice vertShader =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice fragShader =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   SpriteEffect* tolua_ret = (SpriteEffect*)  SpriteEffect::create(vertShader,fragShader);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_SpriteEffect_new00_local(tolua_S);
}
/* get function: depthWrite of class  Sprite */
static int tolua_get_Sprite_depthWrite(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  Sprite */
static int tolua_set_Sprite_depthWrite(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sprite.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sprite.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: alphaRef of class  Sprite */
static int tolua_get_Sprite_alphaRef(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'alphaRef'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAlphaRef());
 return 1;
}
/* set function: alphaRef of class  Sprite */
static int tolua_set_Sprite_alphaRef(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sprite.alphaRef'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sprite.alphaRef'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAlphaRef(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: textureRect of class  Sprite */
static int tolua_get_Sprite_textureRect(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'textureRect'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Rect)(self->getTextureRect()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Rect>());
 return 1;
}
/* set function: textureRect of class  Sprite */
static int tolua_set_Sprite_textureRect(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sprite.textureRect'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sprite.textureRect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTextureRect(* static_cast< Rect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: texture of class  Sprite */
static int tolua_get_Sprite_texture_ptr(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'texture'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getTexture());
 return 1;
}
/* get function: blendFunc of class  Sprite */
static int tolua_get_Sprite_blendFunc(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  Sprite */
static int tolua_set_Sprite_blendFunc(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sprite.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sprite.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: effect of class  Sprite */
static int tolua_get_Sprite_effect_ptr(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'effect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEffect());
 return 1;
}
/* set function: effect of class  Sprite */
static int tolua_set_Sprite_effect_ptr(lua_State* tolua_S){
  Sprite* self = (Sprite*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sprite.effect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sprite.effect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Sprite */
static int tolua_LuaBinding_Sprite_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Sprite* tolua_ret = (Sprite*)  Sprite::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Sprite.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Sprite */
static int tolua_LuaBinding_Sprite_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Texture2D"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Texture2D* texture =  static_cast< Texture2D*>(tolua_tousertype(tolua_S,2,0));
  Rect textureRect = * static_cast< Rect*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   Sprite* tolua_ret = (Sprite*)  Sprite::create(texture,textureRect);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Sprite_new00_local(tolua_S);
}
/* method: new_local of class  Sprite */
static int tolua_LuaBinding_Sprite_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Texture2D"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Texture2D* texture =  static_cast< Texture2D*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Sprite* tolua_ret = (Sprite*)  Sprite::create(texture);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Sprite_new01_local(tolua_S);
}
/* method: new_local of class  Sprite */
static int tolua_LuaBinding_Sprite_new03_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Sprite* tolua_ret = (Sprite*)  Sprite::from(clipStr);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Sprite_new02_local(tolua_S);
}
/* get function: gridX of class  Grid */
static int tolua_get_Grid_gridX(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'gridX'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGridX());
 return 1;
}
/* get function: gridY of class  Grid */
static int tolua_get_Grid_gridY(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'gridY'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGridY());
 return 1;
}
/* get function: depthWrite of class  Grid */
static int tolua_get_Grid_depthWrite(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  Grid */
static int tolua_set_Grid_depthWrite(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grid.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grid.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  Grid */
static int tolua_get_Grid_blendFunc(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  Grid */
static int tolua_set_Grid_blendFunc(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grid.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grid.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: effect of class  Grid */
static int tolua_get_Grid_effect_ptr(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'effect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEffect());
 return 1;
}
/* set function: effect of class  Grid */
static int tolua_set_Grid_effect_ptr(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grid.effect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grid.effect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: textureRect of class  Grid */
static int tolua_get_Grid_textureRect(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'textureRect'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Rect)(self->getTextureRect()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Rect>());
 return 1;
}
/* set function: textureRect of class  Grid */
static int tolua_set_Grid_textureRect(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grid.textureRect'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grid.textureRect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTextureRect(* static_cast< Rect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: texture of class  Grid */
static int tolua_get_Grid_texture_ptr(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'texture'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getTexture());
 return 1;
}
/* set function: texture of class  Grid */
static int tolua_set_Grid_texture_ptr(lua_State* tolua_S){
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Grid.texture'",NULL);
  if (!tolua_isobject(tolua_S,2,"Texture2D"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Grid.texture'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTexture(static_cast< Texture2D*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: Grid_setPos of class  Grid */
static int tolua_LuaBinding_Grid_setPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Grid"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Vec2 pos = tolua_tolight(tolua_S,4);
  float z =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grid.Grid_setPos'", NULL);
#endif
  TOLUA_TRY
  {
   Grid_setPos(self,x,y,pos,z);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.setPos'.",&tolua_err);
 return 0;
#endif
}
/* method: Grid_getPos of class  Grid */
static int tolua_LuaBinding_Grid_getPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Grid"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grid.Grid_getPos'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Vec2 tolua_ret = (tolua_outside Vec2)  Grid_getPos(self,x,y);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.getPos'.",&tolua_err);
 return 0;
#endif
}
/* method: Grid_getColor of class  Grid */
static int tolua_LuaBinding_Grid_getColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Grid"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grid.Grid_getColor'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Color tolua_ret = (tolua_outside Color)  Grid_getColor(self,x,y);
   {
 void* tolua_obj = Mtolua_new((Color)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.getColor'.",&tolua_err);
 return 0;
#endif
}
/* method: Grid_setColor of class  Grid */
static int tolua_LuaBinding_Grid_setColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Grid"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grid.Grid_setColor'", NULL);
#endif
  TOLUA_TRY
  {
   Grid_setColor(self,x,y,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.setColor'.",&tolua_err);
 return 0;
#endif
}
/* method: Grid_moveUV of class  Grid */
static int tolua_LuaBinding_Grid_moveUV00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Grid"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Grid* self = (Grid*)  tolua_tousertype(tolua_S,1,0);
  int x =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int y =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  Vec2 offset = tolua_tolight(tolua_S,4);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Grid.Grid_moveUV'", NULL);
#endif
  TOLUA_TRY
  {
   Grid_moveUV(self,x,y,offset);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.moveUV'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Grid */
static int tolua_LuaBinding_Grid_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  uint32_t gridX =  static_cast< uint32_t>(tolua_tointeger(tolua_S,4,0));
  uint32_t gridY =  static_cast< uint32_t>(tolua_tointeger(tolua_S,5,0));
  TOLUA_TRY
  {
   Grid* tolua_ret = (Grid*)  Grid::create(width,height,gridX,gridY);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Grid.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Grid */
static int tolua_LuaBinding_Grid_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Texture2D"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Rect"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Texture2D* texture =  static_cast< Texture2D*>(tolua_tousertype(tolua_S,2,0));
  Rect textureRect = * static_cast< Rect*>(tolua_tousertype(tolua_S,3,0));
  uint32_t gridX =  static_cast< uint32_t>(tolua_tointeger(tolua_S,4,0));
  uint32_t gridY =  static_cast< uint32_t>(tolua_tointeger(tolua_S,5,0));
  TOLUA_TRY
  {
   Grid* tolua_ret = (Grid*)  Grid::create(texture,textureRect,gridX,gridY);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Grid_new00_local(tolua_S);
}
/* method: new_local of class  Grid */
static int tolua_LuaBinding_Grid_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Texture2D"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Texture2D* texture =  static_cast< Texture2D*>(tolua_tousertype(tolua_S,2,0));
  uint32_t gridX =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  uint32_t gridY =  static_cast< uint32_t>(tolua_tointeger(tolua_S,4,0));
  TOLUA_TRY
  {
   Grid* tolua_ret = (Grid*)  Grid::create(texture,gridX,gridY);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Grid_new01_local(tolua_S);
}
/* method: new_local of class  Grid */
static int tolua_LuaBinding_Grid_new03_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  uint32_t gridX =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  uint32_t gridY =  static_cast< uint32_t>(tolua_tointeger(tolua_S,4,0));
  TOLUA_TRY
  {
   Grid* tolua_ret = (Grid*)  Grid::from(clipStr,gridX,gridY);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Grid_new02_local(tolua_S);
}
/* get function: enabled of class  Touch */
static int tolua_get_Touch_enabled(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'enabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEnabled());
 return 1;
}
/* set function: enabled of class  Touch */
static int tolua_set_Touch_enabled(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Touch.enabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Touch.enabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: first of class  Touch */
static int tolua_get_Touch_first(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'first'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFirst());
 return 1;
}
/* get function: id of class  Touch */
static int tolua_get_Touch_id(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'id'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getId());
 return 1;
}
/* get function: delta of class  Touch */
static int tolua_get_Touch_delta(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'delta'",NULL);
#endif
  Vec2 tolua_obj =  self->getDelta();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* get function: location of class  Touch */
static int tolua_get_Touch_location(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'location'",NULL);
#endif
  Vec2 tolua_obj =  self->getLocation();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* get function: worldLocation of class  Touch */
static int tolua_get_Touch_worldLocation(lua_State* tolua_S){
  Touch* self = (Touch*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'worldLocation'",NULL);
#endif
  Vec2 tolua_obj =  self->getWorldLocation();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* method: func of class  Ease */
static int tolua_LuaBinding_Ease_func00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Ease::Enum easing =  static_cast< Ease::Enum>(static_cast<int>(tolua_tointeger(tolua_S,2,0)));
  float time =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_TRY
  {
   float tolua_ret = (float)  Ease::func(easing,time);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Ease.func'.",&tolua_err);
 return 0;
#endif
}
/* get function: alphaRef of class  Label */
static int tolua_get_Label_alphaRef(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'alphaRef'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAlphaRef());
 return 1;
}
/* set function: alphaRef of class  Label */
static int tolua_set_Label_alphaRef(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.alphaRef'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.alphaRef'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAlphaRef(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: textWidth of class  Label */
static int tolua_get_Label_textWidth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'textWidth'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getTextWidth());
 return 1;
}
/* set function: textWidth of class  Label */
static int tolua_set_Label_textWidth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.textWidth'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.textWidth'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTextWidth(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: spacing of class  Label */
static int tolua_get_Label_spacing(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'spacing'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSpacing());
 return 1;
}
/* set function: spacing of class  Label */
static int tolua_set_Label_spacing(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.spacing'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.spacing'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSpacing(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: lineGap of class  Label */
static int tolua_get_Label_lineGap(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'lineGap'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getLineGap());
 return 1;
}
/* set function: lineGap of class  Label */
static int tolua_set_Label_lineGap(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.lineGap'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.lineGap'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLineGap(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: outlineWidth of class  Label */
static int tolua_get_Label_outlineWidth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'outlineWidth'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getOutlineWidth());
 return 1;
}
/* set function: outlineWidth of class  Label */
static int tolua_set_Label_outlineWidth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.outlineWidth'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.outlineWidth'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOutlineWidth(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: outlineColor of class  Label */
static int tolua_get_Label_outlineColor(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'outlineColor'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Color)(self->getOutlineColor()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Color>());
 return 1;
}
/* set function: outlineColor of class  Label */
static int tolua_set_Label_outlineColor(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.outlineColor'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.outlineColor'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOutlineColor(* static_cast< Color*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: smooth of class  Label */
static int tolua_get_Label_smooth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'smooth'",NULL);
#endif
  Vec2 tolua_obj =  self->getSmooth();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: smooth of class  Label */
static int tolua_set_Label_smooth(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.smooth'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.smooth'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSmooth(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: text of class  Label */
static int tolua_get_Label_text(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'text'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getText());
 return 1;
}
/* set function: text of class  Label */
static int tolua_set_Label_text(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.text'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.text'",&tolua_err);
#endif
  TOLUA_TRY
  self->setText(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  Label */
static int tolua_get_Label_blendFunc(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  Label */
static int tolua_set_Label_blendFunc(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: depthWrite of class  Label */
static int tolua_get_Label_depthWrite(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  Label */
static int tolua_set_Label_depthWrite(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: batched of class  Label */
static int tolua_get_Label_batched(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'batched'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isBatched());
 return 1;
}
/* set function: batched of class  Label */
static int tolua_set_Label_batched(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.batched'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.batched'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBatched(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: effect of class  Label */
static int tolua_get_Label_effect_ptr(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'effect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEffect());
 return 1;
}
/* set function: effect of class  Label */
static int tolua_set_Label_effect_ptr(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Label.effect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Label.effect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: characterCount of class  Label */
static int tolua_get_Label_characterCount(lua_State* tolua_S){
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'characterCount'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getCharacterCount());
 return 1;
}
/* method: Label_getCharacter of class  Label */
static int tolua_LuaBinding_Label_getCharacter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Label"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Label* self = (Label*)  tolua_tousertype(tolua_S,1,0);
  int index =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Label.Label_getCharacter'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Sprite* tolua_ret = (tolua_outside Sprite*)  Label_getCharacter(self,index);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Label.getCharacter'.",&tolua_err);
 return 0;
#endif
}
/* get function: AutomaticWidth of class  Label */
static int tolua_get_Label_AutomaticWidth(lua_State* tolua_S){
  tolua_pushnumber(tolua_S,(lua_Number)Label::AutomaticWidth);
 return 1;
}
/* method: new_local of class  Label */
static int tolua_LuaBinding_Label_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice fontStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Label* tolua_ret = (Label*)  Label::create(fontStr);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Label.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Label */
static int tolua_LuaBinding_Label_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice fontName =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  uint32_t fontSize =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  bool sdf =  static_cast< bool>(tolua_toboolean(tolua_S,4,false));
  TOLUA_TRY
  {
   Label* tolua_ret = (Label*)  Label::create(fontName,fontSize,sdf);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Label_new00_local(tolua_S);
}
/* get function: width of class  RenderTarget */
static int tolua_get_RenderTarget_width(lua_State* tolua_S){
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getWidth());
 return 1;
}
/* get function: height of class  RenderTarget */
static int tolua_get_RenderTarget_height(lua_State* tolua_S){
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getHeight());
 return 1;
}
/* get function: camera of class  RenderTarget */
static int tolua_get_RenderTarget_camera_ptr(lua_State* tolua_S){
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'camera'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getCamera());
 return 1;
}
/* set function: camera of class  RenderTarget */
static int tolua_set_RenderTarget_camera_ptr(lua_State* tolua_S){
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'RenderTarget.camera'",NULL);
  if (!tolua_isobject(tolua_S,2,"Camera"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'RenderTarget.camera'",&tolua_err);
#endif
  TOLUA_TRY
  self->setCamera(static_cast< Camera*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: texture of class  RenderTarget */
static int tolua_get_RenderTarget_texture_ptr(lua_State* tolua_S){
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'texture'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getTexture());
 return 1;
}
/* method: render of class  RenderTarget */
static int tolua_LuaBinding_RenderTarget_render00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"RenderTarget"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
  Node* target =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderTarget.render'", NULL);
#endif
  TOLUA_TRY
  {
   self->render(target);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderTarget.render'.",&tolua_err);
 return 0;
#endif
}
/* method: renderWithClear of class  RenderTarget */
static int tolua_LuaBinding_RenderTarget_renderWithClear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"RenderTarget"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  float depth =  static_cast< float>(tolua_tonumber(tolua_S,3,1.0f));
  uint8_t stencil =  static_cast< uint8_t>(tolua_tointeger(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderTarget.renderWithClear'", NULL);
#endif
  TOLUA_TRY
  {
   self->renderWithClear(color,depth,stencil);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderTarget.renderWithClear'.",&tolua_err);
 return 0;
#endif
}
/* method: renderWithClear of class  RenderTarget */
static int tolua_LuaBinding_RenderTarget_renderWithClear01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"RenderTarget"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
  Node* target =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,3,0));
  float depth =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  uint8_t stencil =  static_cast< uint8_t>(tolua_tointeger(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderTarget.renderWithClear'", NULL);
#endif
  TOLUA_TRY
  {
   self->renderWithClear(target,color,depth,stencil);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_RenderTarget_renderWithClear00(tolua_S);
}
/* method: saveAsync of class  RenderTarget */
static int tolua_LuaBinding_RenderTarget_saveAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"RenderTarget"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  RenderTarget* self = (RenderTarget*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> handler(tolua_ref_function(tolua_S,3));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'RenderTarget.saveAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->saveAsync(filename,handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderTarget.saveAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  RenderTarget */
static int tolua_LuaBinding_RenderTarget_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  uint16_t width =  static_cast< uint16_t>(tolua_tointeger(tolua_S,2,0));
  uint16_t height =  static_cast< uint16_t>(tolua_tointeger(tolua_S,3,0));
  TOLUA_TRY
  {
   RenderTarget* tolua_ret = (RenderTarget*)  RenderTarget::create(width,height);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RenderTarget.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: stencil of class  ClipNode */
static int tolua_get_ClipNode_stencil_ptr(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'stencil'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getStencil());
 return 1;
}
/* set function: stencil of class  ClipNode */
static int tolua_set_ClipNode_stencil_ptr(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ClipNode.stencil'",NULL);
  if (!tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'ClipNode.stencil'",&tolua_err);
#endif
  TOLUA_TRY
  self->setStencil(static_cast< Node*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: alphaThreshold of class  ClipNode */
static int tolua_get_ClipNode_alphaThreshold(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'alphaThreshold'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAlphaThreshold());
 return 1;
}
/* set function: alphaThreshold of class  ClipNode */
static int tolua_set_ClipNode_alphaThreshold(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ClipNode.alphaThreshold'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'ClipNode.alphaThreshold'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAlphaThreshold(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: inverted of class  ClipNode */
static int tolua_get_ClipNode_inverted(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'inverted'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isInverted());
 return 1;
}
/* set function: inverted of class  ClipNode */
static int tolua_set_ClipNode_inverted(lua_State* tolua_S){
  ClipNode* self = (ClipNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'ClipNode.inverted'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'ClipNode.inverted'",&tolua_err);
#endif
  TOLUA_TRY
  self->setInverted(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  ClipNode */
static int tolua_LuaBinding_ClipNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Node"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* stencil =  static_cast< Node*>(tolua_tousertype(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   ClipNode* tolua_ret = (ClipNode*)  ClipNode::create(stencil);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClipNode.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: depthWrite of class  DrawNode */
static int tolua_get_DrawNode_depthWrite(lua_State* tolua_S){
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  DrawNode */
static int tolua_set_DrawNode_depthWrite(lua_State* tolua_S){
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'DrawNode.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'DrawNode.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  DrawNode */
static int tolua_get_DrawNode_blendFunc(lua_State* tolua_S){
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  DrawNode */
static int tolua_set_DrawNode_blendFunc(lua_State* tolua_S){
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'DrawNode.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'DrawNode.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: drawDot of class  DrawNode */
static int tolua_LuaBinding_DrawNode_drawDot00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"DrawNode"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
  Vec2 pos = tolua_tolight(tolua_S,2);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,4,(void*)(&Color::White)));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawNode.drawDot'", NULL);
#endif
  TOLUA_TRY
  {
   self->drawDot(pos,radius,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawNode.drawDot'.",&tolua_err);
 return 0;
#endif
}
/* method: drawSegment of class  DrawNode */
static int tolua_LuaBinding_DrawNode_drawSegment00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"DrawNode"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
  Vec2 from = tolua_tolight(tolua_S,2);
  Vec2 to = tolua_tolight(tolua_S,3);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,5,(void*)(&Color::White)));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawNode.drawSegment'", NULL);
#endif
  TOLUA_TRY
  {
   self->drawSegment(from,to,radius,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawNode.drawSegment'.",&tolua_err);
 return 0;
#endif
}
/* method: drawPolygon of class  DrawNode */
static int tolua_LuaBinding_DrawNode_drawPolygon00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"DrawNode"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* verts = Mtolua_new_dim(Vec2, tolua_len);
  Color fillColor = * static_cast< Color*>(tolua_tousertype(tolua_S,3,(void*)(&Color::White)));
  float borderWidth =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  Color borderColor = * static_cast< Color*>(tolua_tousertype(tolua_S,5,(void*)(&Color::White)));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawNode.drawPolygon'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    verts[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->drawPolygon(verts,tolua_len,fillColor,borderWidth,borderColor);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(verts);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawNode.drawPolygon'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  DrawNode */
static int tolua_LuaBinding_DrawNode_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"DrawNode"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DrawNode* self = (DrawNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DrawNode.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawNode.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  DrawNode */
static int tolua_LuaBinding_DrawNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   DrawNode* tolua_ret = (DrawNode*)  DrawNode::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DrawNode.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: depthWrite of class  Line */
static int tolua_get_Line_depthWrite(lua_State* tolua_S){
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  Line */
static int tolua_set_Line_depthWrite(lua_State* tolua_S){
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Line.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Line.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  Line */
static int tolua_get_Line_blendFunc(lua_State* tolua_S){
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  Line */
static int tolua_set_Line_blendFunc(lua_State* tolua_S){
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Line.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Line.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: add of class  Line */
static int tolua_LuaBinding_Line_add00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Line"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* verts = Mtolua_new_dim(Vec2, tolua_len);
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,3,(void*)(&Color::White)));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Line.add'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    verts[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->add(verts,tolua_len,color);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(verts);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Line.add'.",&tolua_err);
 return 0;
#endif
}
/* method: set of class  Line */
static int tolua_LuaBinding_Line_set00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Line"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* verts = Mtolua_new_dim(Vec2, tolua_len);
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,3,(void*)(&Color::White)));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Line.set'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    verts[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->set(verts,tolua_len,color);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(verts);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Line.set'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Line */
static int tolua_LuaBinding_Line_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Line"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Line* self = (Line*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Line.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Line.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Line */
static int tolua_LuaBinding_Line_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Line* tolua_ret = (Line*)  Line::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Line.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Line */
static int tolua_LuaBinding_Line_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* verts = Mtolua_new_dim(Vec2, tolua_len);
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,3,(void*)(&Color::White)));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    verts[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   Line* tolua_ret = (Line*)  Line::create(verts,tolua_len,color);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(verts);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Line_new00_local(tolua_S);
}
/* get function: active of class  ParticleNode */
static int tolua_get_ParticleNode_active(lua_State* tolua_S){
  ParticleNode* self = (ParticleNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'active'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isActive());
 return 1;
}
/* method: start of class  ParticleNode */
static int tolua_LuaBinding_Particle_start00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"ParticleNode"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  ParticleNode* self = (ParticleNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ParticleNode.start'", NULL);
#endif
  TOLUA_TRY
  {
   self->start();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ParticleNode.start'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  ParticleNode */
static int tolua_LuaBinding_Particle_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"ParticleNode"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  ParticleNode* self = (ParticleNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ParticleNode.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ParticleNode.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  ParticleNode */
static int tolua_LuaBinding_Particle_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   ParticleNode* tolua_ret = (ParticleNode*)  ParticleNode::create(filename);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ParticleNode.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: look of class  Playable */
static int tolua_get_Playable_look(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'look'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getLook());
 return 1;
}
/* set function: look of class  Playable */
static int tolua_set_Playable_look(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Playable.look'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Playable.look'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLook(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: speed of class  Playable */
static int tolua_get_Playable_speed(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'speed'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSpeed());
 return 1;
}
/* set function: speed of class  Playable */
static int tolua_set_Playable_speed(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Playable.speed'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Playable.speed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSpeed(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: recovery of class  Playable */
static int tolua_get_Playable_recovery(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'recovery'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getRecovery());
 return 1;
}
/* set function: recovery of class  Playable */
static int tolua_set_Playable_recovery(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Playable.recovery'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Playable.recovery'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRecovery(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: fliped of class  Playable */
static int tolua_get_Playable_fliped(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fliped'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFliped());
 return 1;
}
/* set function: fliped of class  Playable */
static int tolua_set_Playable_fliped(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Playable.fliped'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Playable.fliped'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFliped(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: current of class  Playable */
static int tolua_get_Playable_current(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'current'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getCurrent());
 return 1;
}
/* get function: lastCompleted of class  Playable */
static int tolua_get_Playable_lastCompleted(lua_State* tolua_S){
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'lastCompleted'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getLastCompleted());
 return 1;
}
/* method: getKeyPoint of class  Playable */
static int tolua_LuaBinding_Playable_getKey00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Playable"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Playable.getKeyPoint'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->getKeyPoint(name);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.getKey'.",&tolua_err);
 return 0;
#endif
}
/* method: play of class  Playable */
static int tolua_LuaBinding_Playable_play00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Playable"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Playable.play'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->play(name,loop);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.play'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  Playable */
static int tolua_LuaBinding_Playable_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Playable"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Playable.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: setSlot of class  Playable */
static int tolua_LuaBinding_Playable_setSlot00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Playable"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Node* item =  static_cast< Node*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Playable.setSlot'", NULL);
#endif
  TOLUA_TRY
  {
   self->setSlot(name,item);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.setSlot'.",&tolua_err);
 return 0;
#endif
}
/* method: getSlot of class  Playable */
static int tolua_LuaBinding_Playable_getSlot00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Playable"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Playable* self = (Playable*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Playable.getSlot'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->getSlot(name);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.getSlot'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Playable */
static int tolua_LuaBinding_Playable_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Playable* tolua_ret = (Playable*)  Playable::create(filename);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Playable.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: reversed of class  Model */
static int tolua_get_Model_reversed(lua_State* tolua_S){
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'reversed'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isReversed());
 return 1;
}
/* set function: reversed of class  Model */
static int tolua_set_Model_reversed(lua_State* tolua_S){
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Model.reversed'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Model.reversed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setReversed(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: duration of class  Model */
static int tolua_get_Model_duration(lua_State* tolua_S){
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'duration'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDuration());
 return 1;
}
/* get function: playing of class  Model */
static int tolua_get_Model_playing(lua_State* tolua_S){
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'playing'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPlaying());
 return 1;
}
/* get function: paused of class  Model */
static int tolua_get_Model_paused(lua_State* tolua_S){
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'paused'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPaused());
 return 1;
}
/* method: hasAnimation of class  Model */
static int tolua_LuaBinding_Model_hasAnimation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.hasAnimation'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->hasAnimation(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.hasAnimation'.",&tolua_err);
 return 0;
#endif
}
/* method: pause of class  Model */
static int tolua_LuaBinding_Model_pause00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.pause'", NULL);
#endif
  TOLUA_TRY
  {
   self->pause();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.pause'.",&tolua_err);
 return 0;
#endif
}
/* method: resume of class  Model */
static int tolua_LuaBinding_Model_resume00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.resume'", NULL);
#endif
  TOLUA_TRY
  {
   self->resume();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.resume'.",&tolua_err);
 return 0;
#endif
}
/* method: resume of class  Model */
static int tolua_LuaBinding_Model_resume01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.resume'", NULL);
#endif
  TOLUA_TRY
  {
   self->resume(name,loop);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Model_resume00(tolua_S);
}
/* method: reset of class  Model */
static int tolua_LuaBinding_Model_reset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.reset'", NULL);
#endif
  TOLUA_TRY
  {
   self->reset();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.reset'.",&tolua_err);
 return 0;
#endif
}
/* method: updateTo of class  Model */
static int tolua_LuaBinding_Model_updateTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
  float elapsed =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  bool reversed =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.updateTo'", NULL);
#endif
  TOLUA_TRY
  {
   self->updateTo(elapsed,reversed);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.updateTo'.",&tolua_err);
 return 0;
#endif
}
/* method: getNodeByName of class  Model */
static int tolua_LuaBinding_Model_getNodeByName00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.getNodeByName'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->getNodeByName(name);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.getNodeByName'.",&tolua_err);
 return 0;
#endif
}
/* method: eachNode of class  Model */
static int tolua_LuaBinding_Model_eachNode00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Model"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Model* self = (Model*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Model.eachNode'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->eachNode(func);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.eachNode'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Model */
static int tolua_LuaBinding_Model_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Model* tolua_ret = (Model*)  Model::create(filename);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.new'.",&tolua_err);
 return 0;
#endif
}
/* method: dummy of class  Model */
static int tolua_LuaBinding_Model_dummy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Model* tolua_ret = (Model*)  Model::dummy();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.dummy'.",&tolua_err);
 return 0;
#endif
}
/* method: Model_getClipFile of class  Model */
static int tolua_LuaBinding_Model_getClipFile00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Model_getClipFile(filename);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.getClipFile'.",&tolua_err);
 return 0;
#endif
}
/* method: Model_getLookNames of class  Model */
static int tolua_LuaBinding_Model_getLooks00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Model_getLookNames(filename);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.getLooks'.",&tolua_err);
 return 0;
#endif
}
/* method: Model_getAnimationNames of class  Model */
static int tolua_LuaBinding_Model_getAnimations00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Model_getAnimationNames(filename);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Model.getAnimations'.",&tolua_err);
 return 0;
#endif
}
/* get function: hitTestEnabled of class  Spine */
static int tolua_get_Spine_hitTestEnabled(lua_State* tolua_S){
  Spine* self = (Spine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'hitTestEnabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isHitTestEnabled());
 return 1;
}
/* set function: hitTestEnabled of class  Spine */
static int tolua_set_Spine_hitTestEnabled(lua_State* tolua_S){
  Spine* self = (Spine*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Spine.hitTestEnabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Spine.hitTestEnabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHitTestEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: setBoneRotation of class  Spine */
static int tolua_LuaBinding_Spine_setBoneRotation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Spine"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Spine* self = (Spine*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  float rotation =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Spine.setBoneRotation'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->setBoneRotation(name,rotation);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Spine.setBoneRotation'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Spine */
static int tolua_LuaBinding_Spine_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice skelFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice atlasFile =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   Spine* tolua_ret = (Spine*)  Spine::create(skelFile,atlasFile);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Spine.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Spine */
static int tolua_LuaBinding_Spine_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice spineStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Spine* tolua_ret = (Spine*)  Spine::create(spineStr);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Spine_new00_local(tolua_S);
}
/* method: Spine_getLookNames of class  Spine */
static int tolua_LuaBinding_Spine_getLooks00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice spineStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Spine_getLookNames(spineStr);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Spine.getLooks'.",&tolua_err);
 return 0;
#endif
}
/* method: Spine_getAnimationNames of class  Spine */
static int tolua_LuaBinding_Spine_getAnimations00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice spineStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Spine_getAnimationNames(spineStr);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Spine.getAnimations'.",&tolua_err);
 return 0;
#endif
}
/* get function: hitTestEnabled of class  DragonBone */
static int tolua_get_DragonBone_hitTestEnabled(lua_State* tolua_S){
  DragonBone* self = (DragonBone*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'hitTestEnabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isHitTestEnabled());
 return 1;
}
/* set function: hitTestEnabled of class  DragonBone */
static int tolua_set_DragonBone_hitTestEnabled(lua_State* tolua_S){
  DragonBone* self = (DragonBone*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'DragonBone.hitTestEnabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'DragonBone.hitTestEnabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHitTestEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  DragonBone */
static int tolua_LuaBinding_DragonBone_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice boneFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice atlasFile =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   DragonBone* tolua_ret = (DragonBone*)  DragonBone::create(boneFile,atlasFile);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragonBone.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  DragonBone */
static int tolua_LuaBinding_DragonBone_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice boneStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   DragonBone* tolua_ret = (DragonBone*)  DragonBone::create(boneStr);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_DragonBone_new00_local(tolua_S);
}
/* method: DragonBone_getLookNames of class  DragonBone */
static int tolua_LuaBinding_DragonBone_getLooks00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice boneStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   DragonBone_getLookNames(boneStr);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragonBone.getLooks'.",&tolua_err);
 return 0;
#endif
}
/* method: DragonBone_getAnimationNames of class  DragonBone */
static int tolua_LuaBinding_DragonBone_getAnimations00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice boneStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   DragonBone_getAnimationNames(boneStr);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragonBone.getAnimations'.",&tolua_err);
 return 0;
#endif
}
/* method: css of class  AlignNode */
static int tolua_LuaBinding_AlignNode_css00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AlignNode"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AlignNode* self = (AlignNode*)  tolua_tousertype(tolua_S,1,0);
   Slice css =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AlignNode.css'", NULL);
#endif
  TOLUA_TRY
  {
   self->css(css);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AlignNode.css'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  AlignNode */
static int tolua_LuaBinding_AlignNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool isRoot =  static_cast< bool>(tolua_toboolean(tolua_S,2,false));
  TOLUA_TRY
  {
   AlignNode* tolua_ret = (AlignNode*)  AlignNode::create(isRoot);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AlignNode.new'.",&tolua_err);
 return 0;
#endif
}
/* method: play of class  EffekNode */
static int tolua_LuaBinding_EffekNode_play00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"EffekNode"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  EffekNode* self = (EffekNode*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Vec2 pos = tolua_tolight(tolua_S,3,Vec2::zero);
  float z =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EffekNode.play'", NULL);
#endif
  TOLUA_TRY
  {
   int tolua_ret = (int)  self->play(filename,pos,z);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EffekNode.play'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  EffekNode */
static int tolua_LuaBinding_EffekNode_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"EffekNode"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  EffekNode* self = (EffekNode*)  tolua_tousertype(tolua_S,1,0);
  int handle =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'EffekNode.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop(handle);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EffekNode.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  EffekNode */
static int tolua_LuaBinding_EffekNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   EffekNode* tolua_ret = (EffekNode*)  EffekNode::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EffekNode.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: depthWrite of class  TileNode */
static int tolua_get_TileNode_depthWrite(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'depthWrite'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDepthWrite());
 return 1;
}
/* set function: depthWrite of class  TileNode */
static int tolua_set_TileNode_depthWrite(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'TileNode.depthWrite'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'TileNode.depthWrite'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDepthWrite(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: blendFunc of class  TileNode */
static int tolua_get_TileNode_blendFunc(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'blendFunc'",NULL);
#endif
 void* tolua_obj = Mtolua_new((BlendFunc)(self->getBlendFunc()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<BlendFunc>());
 return 1;
}
/* set function: blendFunc of class  TileNode */
static int tolua_set_TileNode_blendFunc(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'TileNode.blendFunc'",NULL);
  if (!tolua_isusertype(tolua_S,2,"BlendFunc"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'TileNode.blendFunc'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBlendFunc(* static_cast< BlendFunc*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: effect of class  TileNode */
static int tolua_get_TileNode_effect_ptr(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'effect'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEffect());
 return 1;
}
/* set function: effect of class  TileNode */
static int tolua_set_TileNode_effect_ptr(lua_State* tolua_S){
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'TileNode.effect'",NULL);
  if (!tolua_isobject(tolua_S,2,"SpriteEffect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'TileNode.effect'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEffect(static_cast< SpriteEffect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: getLayer of class  TileNode */
static int tolua_LuaBinding_TileNode_getLayer00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"TileNode"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TileNode* self = (TileNode*)  tolua_tousertype(tolua_S,1,0);
   Slice layerName =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'TileNode.getLayer'", NULL);
#endif
  TOLUA_TRY
  {
   Dictionary* tolua_ret = (Dictionary*)  self->getLayer(layerName);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TileNode.getLayer'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  TileNode */
static int tolua_LuaBinding_TileNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice tmxFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   TileNode* tolua_ret = (TileNode*)  TileNode::create(tmxFile);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TileNode.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  TileNode */
static int tolua_LuaBinding_TileNode_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice tmxFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice layerName =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   TileNode* tolua_ret = (TileNode*)  TileNode::create(tmxFile,layerName);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_TileNode_new00_local(tolua_S);
}
/* method: new_local of class  TileNode */
static int tolua_LuaBinding_TileNode_new02_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice tmxFile =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
  Slice* layerNames = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    layerNames[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   TileNode* tolua_ret = (TileNode*)  TileNode::create(tmxFile,layerNames,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(layerNames);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_TileNode_new01_local(tolua_S);
}
/* method: query of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_query00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  PhysicsWorld* self = (PhysicsWorld*)  tolua_tousertype(tolua_S,1,0);
  Rect rect = * static_cast< Rect*>(tolua_tousertype(tolua_S,2,0));
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,3));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PhysicsWorld.query'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->query(rect,handler);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.query'.",&tolua_err);
 return 0;
#endif
}
/* method: raycast of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_raycast00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,5,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  PhysicsWorld* self = (PhysicsWorld*)  tolua_tousertype(tolua_S,1,0);
  Vec2 start = tolua_tolight(tolua_S,2);
  Vec2 stop = tolua_tolight(tolua_S,3);
  bool closest =  static_cast< bool>(tolua_toboolean(tolua_S,4,0));
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,5));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PhysicsWorld.raycast'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->raycast(start,stop,closest,handler);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.raycast'.",&tolua_err);
 return 0;
#endif
}
/* method: setIterations of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_setIterations00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  PhysicsWorld* self = (PhysicsWorld*)  tolua_tousertype(tolua_S,1,0);
  int velocityIter =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int positionIter =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PhysicsWorld.setIterations'", NULL);
#endif
  TOLUA_TRY
  {
   self->setIterations(velocityIter,positionIter);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.setIterations'.",&tolua_err);
 return 0;
#endif
}
/* method: setShouldContact of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_setShouldContact00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  PhysicsWorld* self = (PhysicsWorld*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
  bool contact =  static_cast< bool>(tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PhysicsWorld.setShouldContact'", NULL);
#endif
  TOLUA_TRY
  {
   self->setShouldContact(groupA,groupB,contact);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.setShouldContact'.",&tolua_err);
 return 0;
#endif
}
/* method: getShouldContact of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_getShouldContact00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  PhysicsWorld* self = (PhysicsWorld*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'PhysicsWorld.getShouldContact'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->getShouldContact(groupA,groupB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.getShouldContact'.",&tolua_err);
 return 0;
#endif
}
/* get function: scaleFactor of class  PhysicsWorld */
static int tolua_get_PhysicsWorld_scaleFactor(lua_State* tolua_S){
  tolua_pushnumber(tolua_S,(lua_Number)PhysicsWorld::scaleFactor);
 return 1;
}
/* set function: scaleFactor of class  PhysicsWorld */
static int tolua_set_PhysicsWorld_scaleFactor(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!tolua_isnumber(tolua_S,3,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'PhysicsWorld.scaleFactor'",&tolua_err);
#endif
  TOLUA_TRY
  PhysicsWorld::scaleFactor =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  PhysicsWorld */
static int tolua_LuaBinding_PhysicsWorld_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   PhysicsWorld* tolua_ret = (PhysicsWorld*)  PhysicsWorld::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PhysicsWorld.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: offset of class  BodyDef */
static int tolua_get_BodyDef_position(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'offset'",NULL);
#endif
  Vec2 tolua_obj =  self->offset;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: offset of class  BodyDef */
static int tolua_set_BodyDef_position(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.offset'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.offset'",&tolua_err);
#endif
  TOLUA_TRY
  self->offset =  tolua_tolight(tolua_S,2);
  TOLUA_CATCH
  return 0;
}
/* get function: angleOffset of class  BodyDef */
static int tolua_get_BodyDef_angle(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angleOffset'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->angleOffset);
 return 1;
}
/* set function: angleOffset of class  BodyDef */
static int tolua_set_BodyDef_angle(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.angleOffset'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.angleOffset'",&tolua_err);
#endif
  TOLUA_TRY
  self->angleOffset =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: face of class  BodyDef */
static int tolua_get_BodyDef_face(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'face'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->face);
 return 1;
}
/* set function: face of class  BodyDef */
static int tolua_set_BodyDef_face(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.face'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.face'",&tolua_err);
#endif
  TOLUA_TRY
  self->face =  static_cast< string>(tolua_toslice(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: facePos of class  BodyDef */
static int tolua_get_BodyDef_facePos(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'facePos'",NULL);
#endif
  Vec2 tolua_obj =  self->facePos;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: facePos of class  BodyDef */
static int tolua_set_BodyDef_facePos(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.facePos'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.facePos'",&tolua_err);
#endif
  TOLUA_TRY
  self->facePos =  tolua_tolight(tolua_S,2);
  TOLUA_CATCH
  return 0;
}
/* get function: linearDamping of class  BodyDef */
static int tolua_get_BodyDef_linearDamping(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'linearDamping'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getLinearDamping());
 return 1;
}
/* set function: linearDamping of class  BodyDef */
static int tolua_set_BodyDef_linearDamping(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.linearDamping'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.linearDamping'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLinearDamping(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: angularDamping of class  BodyDef */
static int tolua_get_BodyDef_angularDamping(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angularDamping'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngularDamping());
 return 1;
}
/* set function: angularDamping of class  BodyDef */
static int tolua_set_BodyDef_angularDamping(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.angularDamping'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.angularDamping'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngularDamping(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: linearAcceleration of class  BodyDef */
static int tolua_get_BodyDef_linearAcceleration(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'linearAcceleration'",NULL);
#endif
  Vec2 tolua_obj =  self->getLinearAcceleration();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: linearAcceleration of class  BodyDef */
static int tolua_set_BodyDef_linearAcceleration(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.linearAcceleration'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.linearAcceleration'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLinearAcceleration(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: fixedRotation of class  BodyDef */
static int tolua_get_BodyDef_fixedRotation(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'fixedRotation'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFixedRotation());
 return 1;
}
/* set function: fixedRotation of class  BodyDef */
static int tolua_set_BodyDef_fixedRotation(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.fixedRotation'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.fixedRotation'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFixedRotation(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: bullet of class  BodyDef */
static int tolua_get_BodyDef_bullet(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bullet'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isBullet());
 return 1;
}
/* set function: bullet of class  BodyDef */
static int tolua_set_BodyDef_bullet(lua_State* tolua_S){
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'BodyDef.bullet'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'BodyDef.bullet'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBullet(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: polygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_polygon00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 center = tolua_tolight(tolua_S,2);
  float width =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,7,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::polygon(center,width,height,angle,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.polygon'.",&tolua_err);
 return 0;
#endif
}
/* method: polygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_polygon01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,5,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::polygon(width,height,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_polygon00(tolua_S);
}
/* method: polygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_polygon02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::polygon(vertices,tolua_len,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_polygon01(tolua_S);
}
/* method: attachPolygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygon00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  Vec2 center = tolua_tolight(tolua_S,2);
  float width =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,7,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygon'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachPolygon(center,width,height,angle,density,friction,restitution);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachPolygon'.",&tolua_err);
 return 0;
#endif
}
/* method: attachPolygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygon01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,5,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygon'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachPolygon(width,height,density,friction,restitution);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachPolygon00(tolua_S);
}
/* method: attachPolygon of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygon02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygon'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->attachPolygon(vertices,tolua_len,density,friction,restitution);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachPolygon01(tolua_S);
}
/* method: multi of class  BodyDef */
static int tolua_LuaBinding_BodyDef_multi00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::multi(vertices,tolua_len,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.multi'.",&tolua_err);
 return 0;
#endif
}
/* method: attachMulti of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachMulti00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachMulti'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->attachMulti(vertices,tolua_len,density,friction,restitution);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachMulti'.",&tolua_err);
 return 0;
#endif
}
/* method: disk of class  BodyDef */
static int tolua_LuaBinding_BodyDef_disk00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 center = tolua_tolight(tolua_S,2);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,5,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::disk(center,radius,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.disk'.",&tolua_err);
 return 0;
#endif
}
/* method: disk of class  BodyDef */
static int tolua_LuaBinding_BodyDef_disk01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::disk(radius,density,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_disk00(tolua_S);
}
/* method: attachDisk of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachDisk00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  Vec2 center = tolua_tolight(tolua_S,2);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,5,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachDisk'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachDisk(center,radius,density,friction,restitution);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachDisk'.",&tolua_err);
 return 0;
#endif
}
/* method: attachDisk of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachDisk01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float density =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,4,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachDisk'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachDisk(radius,density,friction,restitution);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachDisk00(tolua_S);
}
/* method: chain of class  BodyDef */
static int tolua_LuaBinding_BodyDef_chain00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,3,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   FixtureDef* tolua_ret = (FixtureDef*)  BodyDef::chain(vertices,tolua_len,friction,restitution);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.chain'.",&tolua_err);
 return 0;
#endif
}
/* method: attachChain of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachChain00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
  float friction =  static_cast< float>(tolua_tonumber(tolua_S,3,0.4f));
  float restitution =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachChain'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,2,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,2,i+1);
   }
  }
  TOLUA_TRY
  {
   self->attachChain(vertices,tolua_len,friction,restitution);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachChain'.",&tolua_err);
 return 0;
#endif
}
/* method: attachPolygonSensor of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygonSensor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  float width =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygonSensor'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachPolygonSensor(tag,width,height);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachPolygonSensor'.",&tolua_err);
 return 0;
#endif
}
/* method: attachPolygonSensor of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygonSensor01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 center = tolua_tolight(tolua_S,3);
  float width =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygonSensor'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachPolygonSensor(tag,center,width,height,angle);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachPolygonSensor00(tolua_S);
}
/* method: attachPolygonSensor of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachPolygonSensor02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
  Vec2* vertices = Mtolua_new_dim(Vec2, tolua_len);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachPolygonSensor'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,3,"Vec2"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    vertices[i] =  tolua_tofieldlight(tolua_S,3,i+1);
   }
  }
  TOLUA_TRY
  {
   self->attachPolygonSensor(tag,vertices,tolua_len);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(vertices);
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachPolygonSensor01(tolua_S);
}
/* method: attachDiskSensor of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachDiskSensor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 center = tolua_tolight(tolua_S,3);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachDiskSensor'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachDiskSensor(tag,center,radius);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.attachDiskSensor'.",&tolua_err);
 return 0;
#endif
}
/* method: attachDiskSensor of class  BodyDef */
static int tolua_LuaBinding_BodyDef_attachDiskSensor01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  BodyDef* self = (BodyDef*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'BodyDef.attachDiskSensor'", NULL);
#endif
  TOLUA_TRY
  {
   self->attachDiskSensor(tag,radius);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_BodyDef_attachDiskSensor00(tolua_S);
}
/* method: new_local of class  BodyDef */
static int tolua_LuaBinding_BodyDef_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   BodyDef* tolua_ret = (BodyDef*)  BodyDef::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BodyDef.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: enabled of class  Sensor */
static int tolua_get_Sensor_enabled(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'enabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEnabled());
 return 1;
}
/* set function: enabled of class  Sensor */
static int tolua_set_Sensor_enabled(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Sensor.enabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Sensor.enabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: tag of class  Sensor */
static int tolua_get_Sensor_tag(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tag'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getTag());
 return 1;
}
/* get function: owner of class  Sensor */
static int tolua_get_Sensor_owner_ptr(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'owner'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getOwner());
 return 1;
}
/* get function: sensed of class  Sensor */
static int tolua_get_Sensor_sensed(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'sensed'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isSensed());
 return 1;
}
/* get function: sensedBodies of class  Sensor */
static int tolua_get_Sensor_sensedBodies_ptr(lua_State* tolua_S){
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'sensedBodies'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getSensedBodies());
 return 1;
}
/* method: contains of class  Sensor */
static int tolua_LuaBinding_Sensor_contains00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Sensor"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Sensor* self = (Sensor*)  tolua_tousertype(tolua_S,1,0);
  Body* body =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Sensor.contains'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->contains(body);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Sensor.contains'.",&tolua_err);
 return 0;
#endif
}
/* get function: physicsWorld of class  Body */
static int tolua_get_Body_world_ptr(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'physicsWorld'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPhysicsWorld());
 return 1;
}
/* get function: bodyDef of class  Body */
static int tolua_get_Body_bodyDef_ptr(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bodyDef'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getBodyDef());
 return 1;
}
/* get function: mass of class  Body */
static int tolua_get_Body_mass(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'mass'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getMass());
  TOLUA_CATCH
 return 1;
}
/* get function: sensor of class  Body */
static int tolua_get_Body_sensor(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'sensor'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isSensor());
 return 1;
}
/* get function: velocityX of class  Body */
static int tolua_get_Body_velocityX(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'velocityX'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getVelocityX());
  TOLUA_CATCH
 return 1;
}
/* set function: velocityX of class  Body */
static int tolua_set_Body_velocityX(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.velocityX'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.velocityX'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVelocityX(static_cast< tolua_except  float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: velocityY of class  Body */
static int tolua_get_Body_velocityY(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'velocityY'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getVelocityY());
  TOLUA_CATCH
 return 1;
}
/* set function: velocityY of class  Body */
static int tolua_set_Body_velocityY(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.velocityY'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.velocityY'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVelocityY(static_cast< tolua_except  float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: velocity of class  Body */
static int tolua_get_Body_velocity(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'velocity'",NULL);
#endif
  TOLUA_TRY
  Vec2 tolua_obj =  self->getVelocity();
  tolua_pushlight(tolua_S,tolua_obj);
  TOLUA_CATCH
 return 1;
}
/* set function: velocity of class  Body */
static int tolua_set_Body_velocity(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.velocity'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.velocity'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVelocity(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: angularRate of class  Body */
static int tolua_get_Body_angularRate(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angularRate'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngularRate());
  TOLUA_CATCH
 return 1;
}
/* set function: angularRate of class  Body */
static int tolua_set_Body_angularRate(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.angularRate'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.angularRate'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngularRate(static_cast< tolua_except  float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: group of class  Body */
static int tolua_get_Body_group(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'group'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroup());
 return 1;
}
/* set function: group of class  Body */
static int tolua_set_Body_group(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.group'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.group'",&tolua_err);
#endif
  TOLUA_TRY
  self->setGroup(static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: linearDamping of class  Body */
static int tolua_get_Body_linearDamping(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'linearDamping'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getLinearDamping());
  TOLUA_CATCH
 return 1;
}
/* set function: linearDamping of class  Body */
static int tolua_set_Body_linearDamping(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.linearDamping'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.linearDamping'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLinearDamping(static_cast< tolua_except  float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: angularDamping of class  Body */
static int tolua_get_Body_angularDamping(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angularDamping'",NULL);
#endif
  TOLUA_TRY
  tolua_pushnumber(tolua_S,(lua_Number)self->getAngularDamping());
  TOLUA_CATCH
 return 1;
}
/* set function: angularDamping of class  Body */
static int tolua_set_Body_angularDamping(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.angularDamping'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.angularDamping'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAngularDamping(static_cast< tolua_except  float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: owner of class  Body */
static int tolua_get_Body_owner_ptr(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'owner'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getOwner());
 return 1;
}
/* set function: owner of class  Body */
static int tolua_set_Body_owner_ptr(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.owner'",NULL);
  if (!tolua_isobject(tolua_S,2,"Object"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.owner'",&tolua_err);
#endif
  TOLUA_TRY
  self->setOwner(static_cast< Object*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: receivingContact of class  Body */
static int tolua_get_Body_receivingContact(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'receivingContact'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isReceivingContact());
 return 1;
}
/* set function: receivingContact of class  Body */
static int tolua_set_Body_receivingContact(lua_State* tolua_S){
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Body.receivingContact'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Body.receivingContact'",&tolua_err);
#endif
  TOLUA_TRY
  self->setReceivingContact(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: applyLinearImpulse of class  Body */
static int tolua_LuaBinding_Body_applyLinearImpulse00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  Vec2 impulse = tolua_tolight(tolua_S,2);
  Vec2 pos = tolua_tolight(tolua_S,3);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.applyLinearImpulse'", NULL);
#endif
  TOLUA_TRY
  {
   self->applyLinearImpulse(impulse,pos);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.applyLinearImpulse'.",&tolua_err);
 return 0;
#endif
}
/* method: applyAngularImpulse of class  Body */
static int tolua_LuaBinding_Body_applyAngularImpulse00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  float impulse =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.applyAngularImpulse'", NULL);
#endif
  TOLUA_TRY
  {
   self->applyAngularImpulse(impulse);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.applyAngularImpulse'.",&tolua_err);
 return 0;
#endif
}
/* method: getSensorByTag of class  Body */
static int tolua_LuaBinding_Body_getSensorByTag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.getSensorByTag'", NULL);
#endif
  TOLUA_TRY
  {
   Sensor* tolua_ret = (Sensor*)  self->getSensorByTag(tag);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.getSensorByTag'.",&tolua_err);
 return 0;
#endif
}
/* method: removeSensorByTag of class  Body */
static int tolua_LuaBinding_Body_removeSensorByTag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.removeSensorByTag'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->removeSensorByTag(tag);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.removeSensorByTag'.",&tolua_err);
 return 0;
#endif
}
/* method: removeSensor of class  Body */
static int tolua_LuaBinding_Body_removeSensor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Sensor"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  Sensor* sensor =  static_cast< Sensor*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.removeSensor'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->removeSensor(sensor);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.removeSensor'.",&tolua_err);
 return 0;
#endif
}
/* method: attach of class  Body */
static int tolua_LuaBinding_Body_attach00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"FixtureDef"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  FixtureDef* fixtureDef =  static_cast< FixtureDef*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.attach'", NULL);
#endif
  TOLUA_TRY
  {
   self->attach(fixtureDef);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.attach'.",&tolua_err);
 return 0;
#endif
}
/* method: attachSensor of class  Body */
static int tolua_LuaBinding_Body_attachSensor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"FixtureDef"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  int tag =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  FixtureDef* fixtureDef =  static_cast< FixtureDef*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.attachSensor'", NULL);
#endif
  TOLUA_TRY
  {
   Sensor* tolua_ret = (Sensor*)  self->attachSensor(tag,fixtureDef);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.attachSensor'.",&tolua_err);
 return 0;
#endif
}
/* method: onContactFilter of class  Body */
static int tolua_LuaBinding_Body_onContactFilter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Body"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Body* self = (Body*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Body.onContactFilter'", NULL);
#endif
  TOLUA_TRY
  {
   self->onContactFilter(handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.onContactFilter'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Body */
static int tolua_LuaBinding_Body_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"BodyDef"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  BodyDef* def =  static_cast< BodyDef*>(tolua_tousertype(tolua_S,2,0));
  PhysicsWorld* world =  static_cast< PhysicsWorld*>(tolua_tousertype(tolua_S,3,0));
  Vec2 pos = tolua_tolight(tolua_S,4,Vec2::zero);
  float rot =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  TOLUA_TRY
  {
   Body* tolua_ret = (Body*)  Body::create(def,world,pos,rot);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Body.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: center of class  JointDef */
static int tolua_get_JointDef_center(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'center'",NULL);
#endif
  Vec2 tolua_obj =  self->center;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: center of class  JointDef */
static int tolua_set_JointDef_center(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'JointDef.center'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'JointDef.center'",&tolua_err);
#endif
  TOLUA_TRY
  self->center =  tolua_tolight(tolua_S,2);
  TOLUA_CATCH
  return 0;
}
/* get function: position of class  JointDef */
static int tolua_get_JointDef_position(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->position;
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  JointDef */
static int tolua_set_JointDef_position(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'JointDef.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'JointDef.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->position =  tolua_tolight(tolua_S,2);
  TOLUA_CATCH
  return 0;
}
/* get function: angle of class  JointDef */
static int tolua_get_JointDef_angle(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'angle'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->angle);
 return 1;
}
/* set function: angle of class  JointDef */
static int tolua_set_JointDef_angle(lua_State* tolua_S){
  JointDef* self = (JointDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'JointDef.angle'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'JointDef.angle'",&tolua_err);
#endif
  TOLUA_TRY
  self->angle =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* method: distance of class  JointDef */
static int tolua_LuaBinding_JointDef_distance00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::distance(collision,bodyA,bodyB,anchorA,anchorB,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.distance'.",&tolua_err);
 return 0;
#endif
}
/* method: friction of class  JointDef */
static int tolua_LuaBinding_JointDef_friction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float maxForce =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxTorque =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::friction(collision,bodyA,bodyB,worldPos,maxForce,maxTorque);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.friction'.",&tolua_err);
 return 0;
#endif
}
/* method: gear of class  JointDef */
static int tolua_LuaBinding_JointDef_gear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice jointA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice jointB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  float ratio =  static_cast< float>(tolua_tonumber(tolua_S,5,1.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::gear(collision,jointA,jointB,ratio);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.gear'.",&tolua_err);
 return 0;
#endif
}
/* method: spring of class  JointDef */
static int tolua_LuaBinding_JointDef_spring00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 linearOffset = tolua_tolight(tolua_S,5);
  float angularOffset =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxForce =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  float maxTorque =  static_cast< float>(tolua_tonumber(tolua_S,8,0));
  float correctionFactor =  static_cast< float>(tolua_tonumber(tolua_S,9,1.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::spring(collision,bodyA,bodyB,linearOffset,angularOffset,maxForce,maxTorque,correctionFactor);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.spring'.",&tolua_err);
 return 0;
#endif
}
/* method: prismatic of class  JointDef */
static int tolua_LuaBinding_JointDef_prismatic00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,11,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float axisAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float lowerTranslation =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float upperTranslation =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float maxMotorForce =  static_cast< float>(tolua_tonumber(tolua_S,9,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,10,0.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::prismatic(collision,bodyA,bodyB,worldPos,axisAngle,lowerTranslation,upperTranslation,maxMotorForce,motorSpeed);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.prismatic'.",&tolua_err);
 return 0;
#endif
}
/* method: pulley of class  JointDef */
static int tolua_LuaBinding_JointDef_pulley00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,7,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,8,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  Vec2 groundAnchorA = tolua_tolight(tolua_S,7);
  Vec2 groundAnchorB = tolua_tolight(tolua_S,8);
  float ratio =  static_cast< float>(tolua_tonumber(tolua_S,9,1.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::pulley(collision,bodyA,bodyB,anchorA,anchorB,groundAnchorA,groundAnchorB,ratio);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.pulley'.",&tolua_err);
 return 0;
#endif
}
/* method: revolute of class  JointDef */
static int tolua_LuaBinding_JointDef_revolute00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float lowerAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float upperAngle =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float maxMotorTorque =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,9,0.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::revolute(collision,bodyA,bodyB,worldPos,lowerAngle,upperAngle,maxMotorTorque,motorSpeed);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.revolute'.",&tolua_err);
 return 0;
#endif
}
/* method: rope of class  JointDef */
static int tolua_LuaBinding_JointDef_rope00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  float maxLength =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::rope(collision,bodyA,bodyB,anchorA,anchorB,maxLength);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.rope'.",&tolua_err);
 return 0;
#endif
}
/* method: weld of class  JointDef */
static int tolua_LuaBinding_JointDef_weld00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::weld(collision,bodyA,bodyB,worldPos,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.weld'.",&tolua_err);
 return 0;
#endif
}
/* method: wheel of class  JointDef */
static int tolua_LuaBinding_JointDef_wheel00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,11,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice bodyA =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
   Slice bodyB =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float axisAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxMotorTorque =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,9,2.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,10,0.7f));
  TOLUA_TRY
  {
   JointDef* tolua_ret = (JointDef*)  JointDef::wheel(collision,bodyA,bodyB,worldPos,axisAngle,maxMotorTorque,motorSpeed,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'JointDef.wheel'.",&tolua_err);
 return 0;
#endif
}
/* method: distance of class  Joint */
static int tolua_LuaBinding_Joint_distance00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::distance(collision,bodyA,bodyB,anchorA,anchorB,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.distance'.",&tolua_err);
 return 0;
#endif
}
/* method: friction of class  Joint */
static int tolua_LuaBinding_Joint_friction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float maxForce =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxTorque =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::friction(collision,bodyA,bodyB,worldPos,maxForce,maxTorque);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.friction'.",&tolua_err);
 return 0;
#endif
}
/* method: gear of class  Joint */
static int tolua_LuaBinding_Joint_gear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Joint"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Joint"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Joint* jointA =  static_cast< Joint*>(tolua_tousertype(tolua_S,3,0));
  Joint* jointB =  static_cast< Joint*>(tolua_tousertype(tolua_S,4,0));
  float ratio =  static_cast< float>(tolua_tonumber(tolua_S,5,1.0f));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::gear(collision,jointA,jointB,ratio);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.gear'.",&tolua_err);
 return 0;
#endif
}
/* method: spring of class  Joint */
static int tolua_LuaBinding_Joint_spring00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 linearOffset = tolua_tolight(tolua_S,5);
  float angularOffset =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxForce =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  float maxTorque =  static_cast< float>(tolua_tonumber(tolua_S,8,0));
  float correctionFactor =  static_cast< float>(tolua_tonumber(tolua_S,9,1.0f));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::spring(collision,bodyA,bodyB,linearOffset,angularOffset,maxForce,maxTorque,correctionFactor);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.spring'.",&tolua_err);
 return 0;
#endif
}
/* method: move of class  Joint */
static int tolua_LuaBinding_Joint_move00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* body =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Vec2 targetPos = tolua_tolight(tolua_S,4);
  float maxForce =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,6,5.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,7,0.7f));
  TOLUA_TRY
  {
   MoveJoint* tolua_ret = (MoveJoint*)  Joint::move(collision,body,targetPos,maxForce,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.move'.",&tolua_err);
 return 0;
#endif
}
/* method: prismatic of class  Joint */
static int tolua_LuaBinding_Joint_prismatic00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,11,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float axisAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float lowerTranslation =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float upperTranslation =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float maxMotorForce =  static_cast< float>(tolua_tonumber(tolua_S,9,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,10,0.0f));
  TOLUA_TRY
  {
   MotorJoint* tolua_ret = (MotorJoint*)  Joint::prismatic(collision,bodyA,bodyB,worldPos,axisAngle,lowerTranslation,upperTranslation,maxMotorForce,motorSpeed);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.prismatic'.",&tolua_err);
 return 0;
#endif
}
/* method: pulley of class  Joint */
static int tolua_LuaBinding_Joint_pulley00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,7,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,8,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  Vec2 groundAnchorA = tolua_tolight(tolua_S,7);
  Vec2 groundAnchorB = tolua_tolight(tolua_S,8);
  float ratio =  static_cast< float>(tolua_tonumber(tolua_S,9,1.0f));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::pulley(collision,bodyA,bodyB,anchorA,anchorB,groundAnchorA,groundAnchorB,ratio);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.pulley'.",&tolua_err);
 return 0;
#endif
}
/* method: revolute of class  Joint */
static int tolua_LuaBinding_Joint_revolute00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float lowerAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float upperAngle =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float maxMotorTorque =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,9,0.0f));
  TOLUA_TRY
  {
   MotorJoint* tolua_ret = (MotorJoint*)  Joint::revolute(collision,bodyA,bodyB,worldPos,lowerAngle,upperAngle,maxMotorTorque,motorSpeed);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.revolute'.",&tolua_err);
 return 0;
#endif
}
/* method: rope of class  Joint */
static int tolua_LuaBinding_Joint_rope00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 anchorA = tolua_tolight(tolua_S,5);
  Vec2 anchorB = tolua_tolight(tolua_S,6);
  float maxLength =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::rope(collision,bodyA,bodyB,anchorA,anchorB,maxLength);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.rope'.",&tolua_err);
 return 0;
#endif
}
/* method: weld of class  Joint */
static int tolua_LuaBinding_Joint_weld00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::weld(collision,bodyA,bodyB,worldPos,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.weld'.",&tolua_err);
 return 0;
#endif
}
/* method: wheel of class  Joint */
static int tolua_LuaBinding_Joint_wheel00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Body"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,9,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,10,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,11,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collision =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,4,0));
  Vec2 worldPos = tolua_tolight(tolua_S,5);
  float axisAngle =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float maxMotorTorque =  static_cast< float>(tolua_tonumber(tolua_S,7,0.0f));
  float motorSpeed =  static_cast< float>(tolua_tonumber(tolua_S,8,0.0f));
  float frequency =  static_cast< float>(tolua_tonumber(tolua_S,9,2.0f));
  float damping =  static_cast< float>(tolua_tonumber(tolua_S,10,0.7f));
  TOLUA_TRY
  {
   MotorJoint* tolua_ret = (MotorJoint*)  Joint::wheel(collision,bodyA,bodyB,worldPos,axisAngle,maxMotorTorque,motorSpeed,frequency,damping);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.wheel'.",&tolua_err);
 return 0;
#endif
}
/* get function: physicsWorld of class  Joint */
static int tolua_get_Joint_world_ptr(lua_State* tolua_S){
  Joint* self = (Joint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'physicsWorld'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPhysicsWorld());
 return 1;
}
/* method: destroy of class  Joint */
static int tolua_LuaBinding_Joint_destroy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Joint"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Joint* self = (Joint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Joint.destroy'", NULL);
#endif
  TOLUA_TRY
  {
   self->destroy();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.destroy'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Joint */
static int tolua_LuaBinding_Joint_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"JointDef"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Dictionary"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  JointDef* def =  static_cast< JointDef*>(tolua_tousertype(tolua_S,2,0));
  Dictionary* itemDict =  static_cast< Dictionary*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   Joint* tolua_ret = (Joint*)  Joint::create(def,itemDict);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Joint.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: position of class  MoveJoint */
static int tolua_get_MoveJoint_position(lua_State* tolua_S){
  MoveJoint* self = (MoveJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  MoveJoint */
static int tolua_set_MoveJoint_position(lua_State* tolua_S){
  MoveJoint* self = (MoveJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'MoveJoint.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'MoveJoint.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: enabled of class  MotorJoint */
static int tolua_get_MotorJoint_enabled(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'enabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEnabled());
 return 1;
}
/* set function: enabled of class  MotorJoint */
static int tolua_set_MotorJoint_enabled(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'MotorJoint.enabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'MotorJoint.enabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: force of class  MotorJoint */
static int tolua_get_MotorJoint_force(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'force'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getForce());
 return 1;
}
/* set function: force of class  MotorJoint */
static int tolua_set_MotorJoint_force(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'MotorJoint.force'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'MotorJoint.force'",&tolua_err);
#endif
  TOLUA_TRY
  self->setForce(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: speed of class  MotorJoint */
static int tolua_get_MotorJoint_speed(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'speed'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSpeed());
 return 1;
}
/* set function: speed of class  MotorJoint */
static int tolua_set_MotorJoint_speed(lua_State* tolua_S){
  MotorJoint* self = (MotorJoint*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'MotorJoint.speed'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'MotorJoint.speed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSpeed(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: load of class  Cache */
static int tolua_LuaBinding_Cache_load00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  Cache::load(filename);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cache.load'.",&tolua_err);
 return 0;
#endif
}
/* method: loadAsync of class  Cache */
static int tolua_LuaBinding_Cache_loadAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,3));
  TOLUA_TRY
  {
   Cache::loadAsync(filename,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cache.loadAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: update of class  Cache */
static int tolua_LuaBinding_Cache_update00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice content =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   Cache::update(filename,content);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cache.update'.",&tolua_err);
 return 0;
#endif
}
/* method: update of class  Cache */
static int tolua_LuaBinding_Cache_update01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Texture2D"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Texture2D* texture =  static_cast< Texture2D*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   Cache::update(filename,texture);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Cache_update00(tolua_S);
}
/* method: unload of class  Cache */
static int tolua_LuaBinding_Cache_unload00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Cache::unload();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cache.unload'.",&tolua_err);
 return 0;
#endif
}
/* method: unload of class  Cache */
static int tolua_LuaBinding_Cache_unload01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  Cache::unload(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Cache_unload00(tolua_S);
}
/* method: removeUnused of class  Cache */
static int tolua_LuaBinding_Cache_removeUnused00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Cache::removeUnused();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Cache.removeUnused'.",&tolua_err);
 return 0;
#endif
}
/* method: removeUnused of class  Cache */
static int tolua_LuaBinding_Cache_removeUnused01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice type =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Cache::removeUnused(type);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_Cache_removeUnused00(tolua_S);
}
/* get function: soundSpeed of class  Audio */
static int tolua_get_Audio_soundSpeed(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'soundSpeed'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getSoundSpeed());
 return 1;
}
/* set function: soundSpeed of class  Audio */
static int tolua_set_Audio_soundSpeed(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Audio.soundSpeed'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Audio.soundSpeed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setSoundSpeed(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: globalVolume of class  Audio */
static int tolua_get_Audio_globalVolume(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'globalVolume'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getGlobalVolume());
 return 1;
}
/* set function: globalVolume of class  Audio */
static int tolua_set_Audio_globalVolume(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Audio.globalVolume'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Audio.globalVolume'",&tolua_err);
#endif
  TOLUA_TRY
  self->setGlobalVolume(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: listener of class  Audio */
static int tolua_get_Audio_listener_ptr(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'listener'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getListener());
 return 1;
}
/* set function: listener of class  Audio */
static int tolua_set_Audio_listener_ptr(lua_State* tolua_S){
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Audio.listener'",NULL);
  if (!tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Audio.listener'",&tolua_err);
#endif
  TOLUA_TRY
  self->setListener(static_cast< Node*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: play of class  Audio */
static int tolua_LuaBinding_Audio_play00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.play'", NULL);
#endif
  TOLUA_TRY
  {
   uint32_t tolua_ret = (uint32_t)  self->play(filename,loop);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.play'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  Audio */
static int tolua_LuaBinding_Audio_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  uint32_t handle =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop(handle);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: playStream of class  Audio */
static int tolua_LuaBinding_Audio_playStream00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool loop =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
  float crossFadeTime =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.playStream'", NULL);
#endif
  TOLUA_TRY
  {
   self->playStream(filename,loop,crossFadeTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.playStream'.",&tolua_err);
 return 0;
#endif
}
/* method: stopStream of class  Audio */
static int tolua_LuaBinding_Audio_stopStream00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  float fadeTime =  static_cast< float>(tolua_tonumber(tolua_S,2,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.stopStream'", NULL);
#endif
  TOLUA_TRY
  {
   self->stopStream(fadeTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.stopStream'.",&tolua_err);
 return 0;
#endif
}
/* method: stopAll of class  Audio */
static int tolua_LuaBinding_Audio_stopAll00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  float fadeTime =  static_cast< float>(tolua_tonumber(tolua_S,2,0.0f));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.stopAll'", NULL);
#endif
  TOLUA_TRY
  {
   self->stopAll(fadeTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.stopAll'.",&tolua_err);
 return 0;
#endif
}
/* method: setPauseAllCurrent of class  Audio */
static int tolua_LuaBinding_Audio_setPauseAllCurrent00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  bool aPause =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.setPauseAllCurrent'", NULL);
#endif
  TOLUA_TRY
  {
   self->setPauseAllCurrent(aPause);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.setPauseAllCurrent'.",&tolua_err);
 return 0;
#endif
}
/* method: setListenerAt of class  Audio */
static int tolua_LuaBinding_Audio_setListenerAt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  float aAtX =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float aAtY =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float aAtZ =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.setListenerAt'", NULL);
#endif
  TOLUA_TRY
  {
   self->setListenerAt(aAtX,aAtY,aAtZ);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.setListenerAt'.",&tolua_err);
 return 0;
#endif
}
/* method: setListenerUp of class  Audio */
static int tolua_LuaBinding_Audio_setListenerUp00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  float aUpX =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float aUpY =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float aUpZ =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.setListenerUp'", NULL);
#endif
  TOLUA_TRY
  {
   self->setListenerUp(aUpX,aUpY,aUpZ);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.setListenerUp'.",&tolua_err);
 return 0;
#endif
}
/* method: setListenerVelocity of class  Audio */
static int tolua_LuaBinding_Audio_setListenerVelocity00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Audio"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Audio* self = (Audio*)  tolua_tousertype(tolua_S,1,0);
  float aVelocityX =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float aVelocityY =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float aVelocityZ =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Audio.setListenerVelocity'", NULL);
#endif
  TOLUA_TRY
  {
   self->setListenerVelocity(aVelocityX,aVelocityY,aVelocityZ);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.setListenerVelocity'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Audio */
static int tolua_LuaBinding_Audio_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Audio* tolua_ret = (tolua_outside Audio*)  Audio_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Audio>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Audio.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: volume of class  AudioBus */
static int tolua_get_AudioBus_volume(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'volume'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getVolume());
 return 1;
}
/* set function: volume of class  AudioBus */
static int tolua_set_AudioBus_volume(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioBus.volume'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioBus.volume'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVolume(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: pan of class  AudioBus */
static int tolua_get_AudioBus_pan(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pan'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getPan());
 return 1;
}
/* set function: pan of class  AudioBus */
static int tolua_set_AudioBus_pan(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioBus.pan'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioBus.pan'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPan(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: playSpeed of class  AudioBus */
static int tolua_get_AudioBus_playSpeed(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'playSpeed'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getPlaySpeed());
 return 1;
}
/* set function: playSpeed of class  AudioBus */
static int tolua_set_AudioBus_playSpeed(lua_State* tolua_S){
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioBus.playSpeed'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioBus.playSpeed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPlaySpeed(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: fadeVolume of class  AudioBus */
static int tolua_LuaBinding_AudioBus_fadeVolume00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  double time =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
  float toVolume =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.fadeVolume'", NULL);
#endif
  TOLUA_TRY
  {
   self->fadeVolume(time,toVolume);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.fadeVolume'.",&tolua_err);
 return 0;
#endif
}
/* method: fadePan of class  AudioBus */
static int tolua_LuaBinding_AudioBus_fadePan00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  double time =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
  float toPan =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.fadePan'", NULL);
#endif
  TOLUA_TRY
  {
   self->fadePan(time,toPan);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.fadePan'.",&tolua_err);
 return 0;
#endif
}
/* method: fadePlaySpeed of class  AudioBus */
static int tolua_LuaBinding_AudioBus_fadePlaySpeed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  double time =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
  float toPlaySpeed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.fadePlaySpeed'", NULL);
#endif
  TOLUA_TRY
  {
   self->fadePlaySpeed(time,toPlaySpeed);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.fadePlaySpeed'.",&tolua_err);
 return 0;
#endif
}
/* method: setFilter of class  AudioBus */
static int tolua_LuaBinding_AudioBus_setFilter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  uint32_t index =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.setFilter'", NULL);
#endif
  TOLUA_TRY
  {
   self->setFilter(index,name);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.setFilter'.",&tolua_err);
 return 0;
#endif
}
/* method: setFilterParameter of class  AudioBus */
static int tolua_LuaBinding_AudioBus_setFilterParameter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  uint32_t index =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  uint32_t attrId =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  float value =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.setFilterParameter'", NULL);
#endif
  TOLUA_TRY
  {
   self->setFilterParameter(index,attrId,value);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.setFilterParameter'.",&tolua_err);
 return 0;
#endif
}
/* method: getFilterParameter of class  AudioBus */
static int tolua_LuaBinding_AudioBus_getFilterParameter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  uint32_t index =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  uint32_t attrId =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.getFilterParameter'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->getFilterParameter(index,attrId);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.getFilterParameter'.",&tolua_err);
 return 0;
#endif
}
/* method: fadeFilterParameter of class  AudioBus */
static int tolua_LuaBinding_AudioBus_fadeFilterParameter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioBus"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioBus* self = (AudioBus*)  tolua_tousertype(tolua_S,1,0);
  uint32_t index =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  uint32_t attrId =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  float to =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  double time =  static_cast< double>(tolua_tonumber(tolua_S,5,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioBus.fadeFilterParameter'", NULL);
#endif
  TOLUA_TRY
  {
   self->fadeFilterParameter(index,attrId,to,time);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.fadeFilterParameter'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  AudioBus */
static int tolua_LuaBinding_AudioBus_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   AudioBus* tolua_ret = (AudioBus*)  AudioBus::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioBus.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: volume of class  AudioSource */
static int tolua_get_AudioSource_volume(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'volume'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getVolume());
 return 1;
}
/* set function: volume of class  AudioSource */
static int tolua_set_AudioSource_volume(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioSource.volume'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioSource.volume'",&tolua_err);
#endif
  TOLUA_TRY
  self->setVolume(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: pan of class  AudioSource */
static int tolua_get_AudioSource_pan(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'pan'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getPan());
 return 1;
}
/* set function: pan of class  AudioSource */
static int tolua_set_AudioSource_pan(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioSource.pan'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioSource.pan'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPan(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: looping of class  AudioSource */
static int tolua_get_AudioSource_looping(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'looping'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isLooping());
 return 1;
}
/* set function: looping of class  AudioSource */
static int tolua_set_AudioSource_looping(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'AudioSource.looping'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'AudioSource.looping'",&tolua_err);
#endif
  TOLUA_TRY
  self->setLooping(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: playing of class  AudioSource */
static int tolua_get_AudioSource_playing(lua_State* tolua_S){
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'playing'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPlaying());
 return 1;
}
/* method: seek of class  AudioSource */
static int tolua_LuaBinding_AudioSource_seek00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double startTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.seek'", NULL);
#endif
  TOLUA_TRY
  {
   self->seek(startTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.seek'.",&tolua_err);
 return 0;
#endif
}
/* method: scheduleStop of class  AudioSource */
static int tolua_LuaBinding_AudioSource_scheduleStop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double timeToStop =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.scheduleStop'", NULL);
#endif
  TOLUA_TRY
  {
   self->scheduleStop(timeToStop);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.scheduleStop'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  AudioSource */
static int tolua_LuaBinding_AudioSource_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double fadeTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0.0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop(fadeTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: play of class  AudioSource */
static int tolua_LuaBinding_AudioSource_play00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double delayTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0.0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.play'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->play(delayTime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.play'.",&tolua_err);
 return 0;
#endif
}
/* method: playBackground of class  AudioSource */
static int tolua_LuaBinding_AudioSource_playBackground00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.playBackground'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->playBackground();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.playBackground'.",&tolua_err);
 return 0;
#endif
}
/* method: play3D of class  AudioSource */
static int tolua_LuaBinding_AudioSource_play3D00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double delayTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0.0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.play3D'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->play3D(delayTime);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.play3D'.",&tolua_err);
 return 0;
#endif
}
/* method: setProtected of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setProtected00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  bool var =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setProtected'", NULL);
#endif
  TOLUA_TRY
  {
   self->setProtected(var);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setProtected'.",&tolua_err);
 return 0;
#endif
}
/* method: setLoopPoint of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setLoopPoint00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  double loopStartTime =  static_cast< double>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setLoopPoint'", NULL);
#endif
  TOLUA_TRY
  {
   self->setLoopPoint(loopStartTime);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setLoopPoint'.",&tolua_err);
 return 0;
#endif
}
/* method: setVelocity of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setVelocity00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  float vx =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float vy =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float vz =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setVelocity'", NULL);
#endif
  TOLUA_TRY
  {
   self->setVelocity(vx,vy,vz);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setVelocity'.",&tolua_err);
 return 0;
#endif
}
/* method: setMinMaxDistance of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setMinMaxDistance00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  float min =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float max =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setMinMaxDistance'", NULL);
#endif
  TOLUA_TRY
  {
   self->setMinMaxDistance(min,max);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setMinMaxDistance'.",&tolua_err);
 return 0;
#endif
}
/* method: setAttenuation of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setAttenuation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
   Slice model =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  float factor =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setAttenuation'", NULL);
#endif
  TOLUA_TRY
  {
   self->setAttenuation(model,factor);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setAttenuation'.",&tolua_err);
 return 0;
#endif
}
/* method: setDopplerFactor of class  AudioSource */
static int tolua_LuaBinding_AudioSource_setDopplerFactor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"AudioSource"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  AudioSource* self = (AudioSource*)  tolua_tousertype(tolua_S,1,0);
  float factor =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'AudioSource.setDopplerFactor'", NULL);
#endif
  TOLUA_TRY
  {
   self->setDopplerFactor(factor);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.setDopplerFactor'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  AudioSource */
static int tolua_LuaBinding_AudioSource_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"AudioBus"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool autoRemove =  static_cast< bool>(tolua_toboolean(tolua_S,3,true));
  AudioBus* bus =  static_cast< AudioBus*>(tolua_tousertype(tolua_S,4,nullptr));
  TOLUA_TRY
  {
   AudioSource* tolua_ret = (AudioSource*)  AudioSource::create(filename,autoRemove,bus);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AudioSource.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: enabled of class  Menu */
static int tolua_get_Menu_enabled(lua_State* tolua_S){
  Menu* self = (Menu*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'enabled'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isEnabled());
 return 1;
}
/* set function: enabled of class  Menu */
static int tolua_set_Menu_enabled(lua_State* tolua_S){
  Menu* self = (Menu*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Menu.enabled'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Menu.enabled'",&tolua_err);
#endif
  TOLUA_TRY
  self->setEnabled(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Menu */
static int tolua_LuaBinding_Menu_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_TRY
  {
   Menu* tolua_ret = (Menu*)  Menu::create(width,height);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Menu.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Menu */
static int tolua_LuaBinding_Menu_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  TOLUA_TRY
  {
   Menu* tolua_ret = (Menu*)  Menu::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Menu_new00_local(tolua_S);
}
/* method: isKeyDown of class  Keyboard */
static int tolua_LuaBinding_Keyboard_isKeyDown00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Keyboard"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Keyboard* self = (Keyboard*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Keyboard.isKeyDown'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isKeyDown(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Keyboard.isKeyDown'.",&tolua_err);
 return 0;
#endif
}
/* method: isKeyUp of class  Keyboard */
static int tolua_LuaBinding_Keyboard_isKeyUp00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Keyboard"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Keyboard* self = (Keyboard*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Keyboard.isKeyUp'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isKeyUp(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Keyboard.isKeyUp'.",&tolua_err);
 return 0;
#endif
}
/* method: isKeyPressed of class  Keyboard */
static int tolua_LuaBinding_Keyboard_isKeyPressed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Keyboard"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Keyboard* self = (Keyboard*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Keyboard.isKeyPressed'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isKeyPressed(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Keyboard.isKeyPressed'.",&tolua_err);
 return 0;
#endif
}
/* method: updateIMEPosHint of class  Keyboard */
static int tolua_LuaBinding_Keyboard_updateIMEPosHint00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Keyboard"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Keyboard* self = (Keyboard*)  tolua_tousertype(tolua_S,1,0);
  Vec2 winPos = tolua_tolight(tolua_S,2);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Keyboard.updateIMEPosHint'", NULL);
#endif
  TOLUA_TRY
  {
   self->updateIMEPosHint(winPos);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Keyboard.updateIMEPosHint'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Keyboard */
static int tolua_LuaBinding_Keyboard_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Keyboard* tolua_ret = (tolua_outside Keyboard*)  Keyboard_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Keyboard>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Keyboard.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: position of class  Mouse */
static int tolua_get_Mouse_position(lua_State* tolua_S){
  Vec2 tolua_obj =  Mouse::getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* get function: leftButtonPressed of class  Mouse */
static int tolua_get_Mouse_leftButtonPressed(lua_State* tolua_S){
  tolua_pushboolean(tolua_S,(bool)Mouse::isLeftButtonPressed());
 return 1;
}
/* get function: rightButtonPressed of class  Mouse */
static int tolua_get_Mouse_rightButtonPressed(lua_State* tolua_S){
  tolua_pushboolean(tolua_S,(bool)Mouse::isRightButtonPressed());
 return 1;
}
/* get function: middleButtonPressed of class  Mouse */
static int tolua_get_Mouse_middleButtonPressed(lua_State* tolua_S){
  tolua_pushboolean(tolua_S,(bool)Mouse::isMiddleButtonPressed());
 return 1;
}
/* get function: wheel of class  Mouse */
static int tolua_get_Mouse_wheel(lua_State* tolua_S){
  Vec2 tolua_obj =  Mouse::getWheel();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* method: isButtonDown of class  Controller */
static int tolua_LuaBinding_Controller_isButtonDown00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Controller"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Controller* self = (Controller*)  tolua_tousertype(tolua_S,1,0);
  int controllerId =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Controller.isButtonDown'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isButtonDown(controllerId,name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Controller.isButtonDown'.",&tolua_err);
 return 0;
#endif
}
/* method: isButtonUp of class  Controller */
static int tolua_LuaBinding_Controller_isButtonUp00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Controller"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Controller* self = (Controller*)  tolua_tousertype(tolua_S,1,0);
  int controllerId =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Controller.isButtonUp'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isButtonUp(controllerId,name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Controller.isButtonUp'.",&tolua_err);
 return 0;
#endif
}
/* method: isButtonPressed of class  Controller */
static int tolua_LuaBinding_Controller_isButtonPressed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Controller"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Controller* self = (Controller*)  tolua_tousertype(tolua_S,1,0);
  int controllerId =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Controller.isButtonPressed'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isButtonPressed(controllerId,name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Controller.isButtonPressed'.",&tolua_err);
 return 0;
#endif
}
/* method: getAxis of class  Controller */
static int tolua_LuaBinding_Controller_getAxis00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Controller"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Controller* self = (Controller*)  tolua_tousertype(tolua_S,1,0);
  int controllerId =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Controller.getAxis'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->getAxis(controllerId,name);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Controller.getAxis'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Controller */
static int tolua_LuaBinding_Controller_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Controller* tolua_ret = (tolua_outside Controller*)  Controller_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Controller>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Controller.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: width of class  SVGDef */
static int tolua_get_SVGDef_width(lua_State* tolua_S){
  SVGDef* self = (SVGDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getWidth());
 return 1;
}
/* get function: height of class  SVGDef */
static int tolua_get_SVGDef_height(lua_State* tolua_S){
  SVGDef* self = (SVGDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getHeight());
 return 1;
}
/* method: render of class  SVGDef */
static int tolua_LuaBinding_SVG_render00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"SVGDef"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  SVGDef* self = (SVGDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'SVGDef.render'", NULL);
#endif
  TOLUA_TRY
  {
   self->render();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SVGDef.render'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  SVGDef */
static int tolua_LuaBinding_SVG_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   SVGDef* tolua_ret = (SVGDef*)  SVGDef::from(filename);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SVGDef.new'.",&tolua_err);
 return 0;
#endif
}
/* method: existDB of class  DB */
static int tolua_LuaBinding_DB_existDB00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"DB"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DB* self = (DB*)  tolua_tousertype(tolua_S,1,0);
   Slice dbName =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DB.existDB'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->existDB(dbName);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DB.existDB'.",&tolua_err);
 return 0;
#endif
}
/* method: exist of class  DB */
static int tolua_LuaBinding_DB_exist00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"DB"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  DB* self = (DB*)  tolua_tousertype(tolua_S,1,0);
   Slice tableName =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice schema =  static_cast<  Slice>(tolua_toslice(tolua_S,3,nullptr));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'DB.exist'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->exist(tableName,schema);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DB.exist'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  DB */
static int tolua_LuaBinding_DB_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside DB* tolua_ret = (tolua_outside DB*)  DB_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<DB>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DB.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: localIP of class  HttpServer */
static int tolua_get_HttpServer_localIP(lua_State* tolua_S){
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'localIP'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getLocalIP());
 return 1;
}
/* get function: wSConnectionCount of class  HttpServer */
static int tolua_get_HttpServer_wsConnectionCount(lua_State* tolua_S){
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'wSConnectionCount'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getWSConnectionCount());
 return 1;
}
/* get function: wWWPath of class  HttpServer */
static int tolua_get_HttpServer_wwwPath(lua_State* tolua_S){
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'wWWPath'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getWWWPath());
 return 1;
}
/* set function: wWWPath of class  HttpServer */
static int tolua_set_HttpServer_wwwPath(lua_State* tolua_S){
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'HttpServer.wWWPath'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'HttpServer.wWWPath'",&tolua_err);
#endif
  TOLUA_TRY
  self->setWWWPath(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: start of class  HttpServer */
static int tolua_LuaBinding_HttpServer_start00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpServer"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
  int port =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpServer.start'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->start(port);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpServer.start'.",&tolua_err);
 return 0;
#endif
}
/* method: startWS of class  HttpServer */
static int tolua_LuaBinding_HttpServer_startWS00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpServer"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
  int port =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpServer.startWS'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->startWS(port);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpServer.startWS'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  HttpServer */
static int tolua_LuaBinding_HttpServer_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpServer"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpServer* self = (HttpServer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpServer.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpServer.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  HttpServer */
static int tolua_LuaBinding_HttpServer_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside HttpServer* tolua_ret = (tolua_outside HttpServer*)  HttpServer_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<HttpServer>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpServer.new'.",&tolua_err);
 return 0;
#endif
}
/* method: postAsync of class  HttpClient */
static int tolua_LuaBinding_HttpClient_postAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpClient"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,6,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpClient* self = (HttpClient*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* headers = Mtolua_new_dim(Slice, tolua_len);
   Slice json =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  float timeout =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,6));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpClient.postAsync'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    headers[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   self->postAsync(url,headers,tolua_len,json,timeout,callback);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(headers);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpClient.postAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: postAsync of class  HttpClient */
static int tolua_LuaBinding_HttpClient_postAsync01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpClient"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,6,&tolua_err) ||
  !tolua_isfunction(tolua_S,7,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  HttpClient* self = (HttpClient*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* headers = Mtolua_new_dim(Slice, tolua_len);
   Slice json =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  float timeout =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  LuaFunction<bool> partCallback(tolua_ref_function(tolua_S,6));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,7));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpClient.postAsync'", NULL);
#endif
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    headers[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   self->postAsync(url,headers,tolua_len,json,timeout,partCallback,callback);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(headers);
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_HttpClient_postAsync00(tolua_S);
}
/* method: postAsync of class  HttpClient */
static int tolua_LuaBinding_HttpClient_postAsync02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpClient"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,5,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  HttpClient* self = (HttpClient*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice json =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  float timeout =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,5));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpClient.postAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->postAsync(url,json,timeout,callback);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_HttpClient_postAsync01(tolua_S);
}
/* method: getAsync of class  HttpClient */
static int tolua_LuaBinding_HttpClient_getAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpClient"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,4,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpClient* self = (HttpClient*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  float timeout =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,4));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpClient.getAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->getAsync(url,timeout,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpClient.getAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: downloadAsync of class  HttpClient */
static int tolua_LuaBinding_HttpClient_downloadAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"HttpClient"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,5,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  HttpClient* self = (HttpClient*)  tolua_tousertype(tolua_S,1,0);
   Slice url =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice filePath =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  float timeout =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  LuaFunction<bool> progress(tolua_ref_function(tolua_S,5));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'HttpClient.downloadAsync'", NULL);
#endif
  TOLUA_TRY
  {
   self->downloadAsync(url,filePath,timeout,progress);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpClient.downloadAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  HttpClient */
static int tolua_LuaBinding_HttpClient_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside HttpClient* tolua_ret = (tolua_outside HttpClient*)  HttpClient_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<HttpClient>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'HttpClient.new'.",&tolua_err);
 return 0;
#endif
}
/* method: update of class  ML::QLearner */
static int tolua_LuaBinding_ML_QLearner_update00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"ML::QLearner"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  ML::QLearner* self = (ML::QLearner*)  tolua_tousertype(tolua_S,1,0);
  uint64_t state =  static_cast< uint64_t>(tolua_tointeger(tolua_S,2,0));
  uint32_t action =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  double reward =  static_cast< double>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ML::QLearner.update'", NULL);
#endif
  TOLUA_TRY
  {
   self->update(state,action,reward);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ML::QLearner.update'.",&tolua_err);
 return 0;
#endif
}
/* method: getBestAction of class  ML::QLearner */
static int tolua_LuaBinding_ML_QLearner_getBestAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"ML::QLearner"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  ML::QLearner* self = (ML::QLearner*)  tolua_tousertype(tolua_S,1,0);
  uint64_t state =  static_cast< uint64_t>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'ML::QLearner.getBestAction'", NULL);
#endif
  TOLUA_TRY
  {
   uint32_t tolua_ret = (uint32_t)  self->getBestAction(state);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ML::QLearner.getBestAction'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  ML::QLearner */
static int tolua_LuaBinding_ML_QLearner_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  double gamma =  static_cast< double>(tolua_tonumber(tolua_S,2,0.5));
  double alpha =  static_cast< double>(tolua_tonumber(tolua_S,3,0.5));
  double maxQ =  static_cast< double>(tolua_tonumber(tolua_S,4,100.0));
  TOLUA_TRY
  {
   ML::QLearner* tolua_ret = (ML::QLearner*)  ML::QLearner::create(gamma,alpha,maxQ);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ML::QLearner.new'.",&tolua_err);
 return 0;
#endif
}
/* function: ML::BuildDecisionTreeAsync */
static int tolua_LuaBinding_ML_BuildDecisionTreeAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice data =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  int maxDepth =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  LuaFunction<void> handleTree(tolua_ref_function(tolua_S,3));
  TOLUA_TRY
  {
   ML::BuildDecisionTreeAsync(data,maxDepth,handleTree);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BuildDecisionTreeAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: SharedWasmRuntime.executeMainFile of class  WasmRuntime */
static int tolua_LuaBinding_Wasm_executeMainFile00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  SharedWasmRuntime.executeMainFile(filename);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WasmRuntime.executeMainFile'.",&tolua_err);
 return 0;
#endif
}
/* method: SharedWasmRuntime.executeMainFileAsync of class  WasmRuntime */
static int tolua_LuaBinding_Wasm_executeMainFileAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> handler(tolua_ref_function(tolua_S,3));
  TOLUA_TRY
  {
   SharedWasmRuntime.executeMainFileAsync(filename,handler);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WasmRuntime.executeMainFileAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: SharedWasmRuntime.buildWaAsync of class  WasmRuntime */
static int tolua_LuaBinding_Wasm_buildWaAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice fullPath =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,3));
  TOLUA_TRY
  {
   SharedWasmRuntime.buildWaAsync(fullPath,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WasmRuntime.buildWaAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: SharedWasmRuntime.formatWaAsync of class  WasmRuntime */
static int tolua_LuaBinding_Wasm_formatWaAsync00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice fullPath =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  LuaFunction<void> callback(tolua_ref_function(tolua_S,3));
  TOLUA_TRY
  {
   SharedWasmRuntime.formatWaAsync(fullPath,callback);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WasmRuntime.formatWaAsync'.",&tolua_err);
 return 0;
#endif
}
/* method: WasmRuntime_clear of class  WasmRuntime */
static int tolua_LuaBinding_Wasm_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   WasmRuntime_clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'WasmRuntime.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::TargetAllow */
static int tolua_LuaBinding_Platformer_TargetAllow_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  uint32_t flag =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::TargetAllow* tolua_ret = (Platformer::TargetAllow*)  Mtolua_new((Platformer::TargetAllow)(flag));
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Platformer::TargetAllow>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::TargetAllow.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: terrainAllowed of class  Platformer::TargetAllow */
static int tolua_get_Platformer__TargetAllow_terrainAllowed(lua_State* tolua_S){
  Platformer::TargetAllow* self = (Platformer::TargetAllow*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'terrainAllowed'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isTerrainAllowed());
 return 1;
}
/* set function: terrainAllowed of class  Platformer::TargetAllow */
static int tolua_set_Platformer__TargetAllow_terrainAllowed(lua_State* tolua_S){
  Platformer::TargetAllow* self = (Platformer::TargetAllow*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::TargetAllow.terrainAllowed'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::TargetAllow.terrainAllowed'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTerrainAllowed(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: TargetAllow_allow of class  Platformer::TargetAllow */
static int tolua_LuaBinding_Platformer_TargetAllow_allow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::TargetAllow"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::TargetAllow* self = (Platformer::TargetAllow*)  tolua_tousertype(tolua_S,1,0);
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  bool allow =  static_cast< bool>(tolua_toboolean(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::TargetAllow.TargetAllow_allow'", NULL);
#endif
  TOLUA_TRY
  {
   TargetAllow_allow(self,relation,allow);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::TargetAllow.allow'.",&tolua_err);
 return 0;
#endif
}
/* method: TargetAllow_isAllow of class  Platformer::TargetAllow */
static int tolua_LuaBinding_Platformer_TargetAllow_isAllow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::TargetAllow"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::TargetAllow* self = (Platformer::TargetAllow*)  tolua_tousertype(tolua_S,1,0);
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::TargetAllow.TargetAllow_isAllow'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside bool tolua_ret = (tolua_outside bool)  TargetAllow_isAllow(self,relation);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::TargetAllow.isAllow'.",&tolua_err);
 return 0;
#endif
}
/* method: toValue of class  Platformer::TargetAllow */
static int tolua_LuaBinding_Platformer_TargetAllow_toValue00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::TargetAllow"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::TargetAllow* self = (Platformer::TargetAllow*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::TargetAllow.toValue'", NULL);
#endif
  TOLUA_TRY
  {
   uint32_t tolua_ret = (uint32_t)  self->toValue();
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::TargetAllow.toValue'.",&tolua_err);
 return 0;
#endif
}
/* method: addChild of class  Platformer::Face */
static int tolua_LuaBinding_Platformer_Face_addChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Face"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Face"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Face* self = (Platformer::Face*)  tolua_tousertype(tolua_S,1,0);
  Platformer::Face* face =  static_cast< Platformer::Face*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Face.addChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->addChild(face);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Face.addChild'.",&tolua_err);
 return 0;
#endif
}
/* method: toNode of class  Platformer::Face */
static int tolua_LuaBinding_Platformer_Face_toNode00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Face"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Face* self = (Platformer::Face*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Face.toNode'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->toNode();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Face.toNode'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Face */
static int tolua_LuaBinding_Platformer_Face_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice faceStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Vec2 point = tolua_tolight(tolua_S,3,Vec2::zero);
  float scale =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  TOLUA_TRY
  {
   Platformer::Face* tolua_ret = (Platformer::Face*)  Platformer::Face::create(faceStr,point,scale,angle);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Face.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Face */
static int tolua_LuaBinding_Platformer_Face_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  LuaFunction<Node*> createFunc(tolua_ref_function(tolua_S,2));
  Vec2 point = tolua_tolight(tolua_S,3,Vec2::zero);
  float scale =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  TOLUA_TRY
  {
   Platformer::Face* tolua_ret = (Platformer::Face*)  Platformer::Face::create(createFunc,point,scale,angle);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Face_new00_local(tolua_S);
}
/* get function: tag of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_tag(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'tag'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->tag);
 return 1;
}
/* set function: tag of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_tag(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.tag'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.tag'",&tolua_err);
#endif
  TOLUA_TRY
  self->tag =  static_cast< string>(tolua_toslice(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: endEffect of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_endEffect(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'endEffect'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->endEffect);
 return 1;
}
/* set function: endEffect of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_endEffect(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.endEffect'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.endEffect'",&tolua_err);
#endif
  TOLUA_TRY
  self->endEffect =  static_cast< string>(tolua_toslice(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: lifeTime of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_lifeTime(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'lifeTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->lifeTime);
 return 1;
}
/* set function: lifeTime of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_lifeTime(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.lifeTime'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.lifeTime'",&tolua_err);
#endif
  TOLUA_TRY
  self->lifeTime =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: damageRadius of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_damageRadius(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'damageRadius'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->damageRadius);
 return 1;
}
/* set function: damageRadius of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_damageRadius(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.damageRadius'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.damageRadius'",&tolua_err);
#endif
  TOLUA_TRY
  self->damageRadius =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: highSpeedFix of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_highSpeedFix(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'highSpeedFix'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isHighSpeedFix());
 return 1;
}
/* set function: highSpeedFix of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_highSpeedFix(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.highSpeedFix'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.highSpeedFix'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHighSpeedFix(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: gravity of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_gravity(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'gravity'",NULL);
#endif
  Vec2 tolua_obj =  self->getGravity();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: gravity of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_gravity(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.gravity'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.gravity'",&tolua_err);
#endif
  TOLUA_TRY
  self->setGravity(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: face of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_face_ptr(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'face'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getFace());
 return 1;
}
/* set function: face of class  Platformer::BulletDef */
static int tolua_set_Platformer__BulletDef_face_ptr(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::BulletDef.face'",NULL);
  if (!tolua_isobject(tolua_S,2,"Platformer::Face"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::BulletDef.face'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFace(static_cast< Platformer::Face*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: bodyDef of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_bodyDef_ptr(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bodyDef'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getBodyDef());
 return 1;
}
/* get function: velocity of class  Platformer::BulletDef */
static int tolua_get_Platformer__BulletDef_velocity(lua_State* tolua_S){
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'velocity'",NULL);
#endif
  Vec2 tolua_obj =  self->getVelocity();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* method: setAsCircle of class  Platformer::BulletDef */
static int tolua_LuaBinding_Platformer_BulletDef_setAsCircle00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::BulletDef"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::BulletDef.setAsCircle'", NULL);
#endif
  TOLUA_TRY
  {
   self->setAsCircle(radius);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::BulletDef.setAsCircle'.",&tolua_err);
 return 0;
#endif
}
/* method: setVelocity of class  Platformer::BulletDef */
static int tolua_LuaBinding_Platformer_BulletDef_setVelocity00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::BulletDef"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::BulletDef* self = (Platformer::BulletDef*)  tolua_tousertype(tolua_S,1,0);
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float speed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::BulletDef.setVelocity'", NULL);
#endif
  TOLUA_TRY
  {
   self->setVelocity(angle,speed);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::BulletDef.setVelocity'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::BulletDef */
static int tolua_LuaBinding_Platformer_BulletDef_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Platformer::BulletDef* tolua_ret = (Platformer::BulletDef*)  Platformer::BulletDef::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::BulletDef.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: playable of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_playable_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'playable'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getPlayable());
 return 1;
}
/* set function: playable of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_playable_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.playable'",NULL);
  if (!tolua_isobject(tolua_S,2,"Playable"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.playable'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPlayable(static_cast< Playable*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: detectDistance of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_detectDistance(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'detectDistance'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDetectDistance());
 return 1;
}
/* set function: detectDistance of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_detectDistance(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.detectDistance'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.detectDistance'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDetectDistance(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: attackRange of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_attackRange(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'attackRange'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Size)(self->getAttackRange()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
 return 1;
}
/* set function: attackRange of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_attackRange(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.attackRange'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Size"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.attackRange'",&tolua_err);
#endif
  TOLUA_TRY
  self->setAttackRange(* static_cast< Size*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: faceRight of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_faceRight(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'faceRight'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFaceRight());
 return 1;
}
/* set function: faceRight of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_faceRight(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.faceRight'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.faceRight'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFaceRight(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: receivingDecisionTrace of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_receivingDecisionTrace(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'receivingDecisionTrace'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isReceivingDecisionTrace());
 return 1;
}
/* set function: receivingDecisionTrace of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_receivingDecisionTrace(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.receivingDecisionTrace'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.receivingDecisionTrace'",&tolua_err);
#endif
  TOLUA_TRY
  self->setReceivingDecisionTrace(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: decisionTreeName of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_decisionTree(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'decisionTreeName'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getDecisionTreeName());
 return 1;
}
/* set function: decisionTreeName of class  Platformer::Unit */
static int tolua_set_Platformer__Unit_decisionTree(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Unit.decisionTreeName'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Unit.decisionTreeName'",&tolua_err);
#endif
  TOLUA_TRY
  self->setDecisionTreeName(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: onSurface of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_onSurface(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'onSurface'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isOnSurface());
 return 1;
}
/* get function: groundSensor of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_groundSensor_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groundSensor'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getGroundSensor());
 return 1;
}
/* get function: detectSensor of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_detectSensor_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'detectSensor'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getDetectSensor());
 return 1;
}
/* get function: attackSensor of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_attackSensor_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'attackSensor'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getAttackSensor());
 return 1;
}
/* get function: unitDef of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_unitDef_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'unitDef'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getUnitDef());
 return 1;
}
/* get function: currentAction of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_currentAction_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'currentAction'",NULL);
#endif
  tolua_pushusertype(tolua_S,(void*)self->getCurrentAction(),LuaType<Platformer::UnitAction>());
 return 1;
}
/* get function: width of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_width(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'width'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getWidth());
 return 1;
}
/* get function: height of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_height(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'height'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getHeight());
 return 1;
}
/* get function: entity of class  Platformer::Unit */
static int tolua_get_Platformer__Unit_entity_ptr(lua_State* tolua_S){
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'entity'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEntity());
 return 1;
}
/* method: attachAction of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_attachAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.attachAction'", NULL);
#endif
  TOLUA_TRY
  {
   Platformer::UnitAction* tolua_ret = (Platformer::UnitAction*)  self->attachAction(name);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Platformer::UnitAction>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.attachAction'.",&tolua_err);
 return 0;
#endif
}
/* method: removeAction of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_removeAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.removeAction'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeAction(name);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.removeAction'.",&tolua_err);
 return 0;
#endif
}
/* method: removeAllActions of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_removeAllActions00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.removeAllActions'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeAllActions();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.removeAllActions'.",&tolua_err);
 return 0;
#endif
}
/* method: getAction of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_getAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.getAction'", NULL);
#endif
  TOLUA_TRY
  {
   Platformer::UnitAction* tolua_ret = (Platformer::UnitAction*)  self->getAction(name);
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Platformer::UnitAction>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.getAction'.",&tolua_err);
 return 0;
#endif
}
/* method: eachAction of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_eachAction00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<void> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.eachAction'", NULL);
#endif
  TOLUA_TRY
  {
   self->eachAction(func);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.eachAction'.",&tolua_err);
 return 0;
#endif
}
/* method: start of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_start00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.start'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->start(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.start'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: isDoing of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_isDoing00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Unit* self = (Platformer::Unit*)  tolua_tousertype(tolua_S,1,0);
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Unit.isDoing'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isDoing(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.isDoing'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Dictionary"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"PhysicsWorld"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Entity"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Dictionary* unitDef =  static_cast< Dictionary*>(tolua_tousertype(tolua_S,2,0));
  PhysicsWorld* physicsworld =  static_cast< PhysicsWorld*>(tolua_tousertype(tolua_S,3,0));
  Entity* entity =  static_cast< Entity*>(tolua_tousertype(tolua_S,4,0));
  Vec2 pos = tolua_tolight(tolua_S,5);
  float rot =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  TOLUA_TRY
  {
   Platformer::Unit* tolua_ret = (Platformer::Unit*)  Platformer::Unit::create(unitDef,physicsworld,entity,pos,rot);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Unit.new'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Unit */
static int tolua_LuaBinding_Platformer_Unit_new01_local(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isobject(tolua_S,4,"Entity"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice defName =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
   Slice worldName =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  Entity* entity =  static_cast< Entity*>(tolua_tousertype(tolua_S,4,0));
  Vec2 pos = tolua_tolight(tolua_S,5);
  float rot =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
  TOLUA_TRY
  {
   Platformer::Unit* tolua_ret = (Platformer::Unit*)  Platformer::Unit::create(defName,worldName,entity,pos,rot);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Unit_new00_local(tolua_S);
}
/* get function: targetAllow of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_targetAllow(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'targetAllow'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getTargetAllow());
 return 1;
}
/* set function: targetAllow of class  Platformer::Bullet */
static int tolua_set_Platformer__Bullet_targetAllow(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Bullet.targetAllow'",NULL);
  if (!tolua_isinteger(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Bullet.targetAllow'",&tolua_err);
#endif
  TOLUA_TRY
  self->setTargetAllow(static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: faceRight of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_faceRight(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'faceRight'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isFaceRight());
 return 1;
}
/* get function: hitStop of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_hitStop(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'hitStop'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isHitStop());
 return 1;
}
/* set function: hitStop of class  Platformer::Bullet */
static int tolua_set_Platformer__Bullet_hitStop(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Bullet.hitStop'",NULL);
  if (!tolua_isboolean(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Bullet.hitStop'",&tolua_err);
#endif
  TOLUA_TRY
  self->setHitStop(static_cast< bool>(tolua_toboolean(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: emitter of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_emitter_ptr(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'emitter'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getEmitter());
 return 1;
}
/* get function: bulletDef of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_bulletDef_ptr(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'bulletDef'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getBulletDef());
 return 1;
}
/* get function: face of class  Platformer::Bullet */
static int tolua_get_Platformer__Bullet_face_ptr(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'face'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getFace());
 return 1;
}
/* set function: face of class  Platformer::Bullet */
static int tolua_set_Platformer__Bullet_face_ptr(lua_State* tolua_S){
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::Bullet.face'",NULL);
  if (!tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::Bullet.face'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFace(static_cast< Node*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: destroy of class  Platformer::Bullet */
static int tolua_LuaBinding_Platformer_Bullet_destroy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Bullet"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Bullet* self = (Platformer::Bullet*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Bullet.destroy'", NULL);
#endif
  TOLUA_TRY
  {
   self->destroy();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Bullet.destroy'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Bullet */
static int tolua_LuaBinding_Platformer_Bullet_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,2,"Platformer::BulletDef"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Platformer::Unit"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::BulletDef* def =  static_cast< Platformer::BulletDef*>(tolua_tousertype(tolua_S,2,0));
  Platformer::Unit* owner =  static_cast< Platformer::Unit*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   Platformer::Bullet* tolua_ret = (Platformer::Bullet*)  Platformer::Bullet::create(def,owner);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Bullet.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: playing of class  Platformer::Visual */
static int tolua_get_Platformer__Visual_playing(lua_State* tolua_S){
  Platformer::Visual* self = (Platformer::Visual*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'playing'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isPlaying());
 return 1;
}
/* method: start of class  Platformer::Visual */
static int tolua_LuaBinding_Platformer_Visual_start00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Visual"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Visual* self = (Platformer::Visual*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Visual.start'", NULL);
#endif
  TOLUA_TRY
  {
   self->start();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Visual.start'.",&tolua_err);
 return 0;
#endif
}
/* method: stop of class  Platformer::Visual */
static int tolua_LuaBinding_Platformer_Visual_stop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Visual"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Visual* self = (Platformer::Visual*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Visual.stop'", NULL);
#endif
  TOLUA_TRY
  {
   self->stop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Visual.stop'.",&tolua_err);
 return 0;
#endif
}
/* method: autoRemove of class  Platformer::Visual */
static int tolua_LuaBinding_Platformer_Visual_autoRemove00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Visual"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Visual* self = (Platformer::Visual*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Visual.autoRemove'", NULL);
#endif
  TOLUA_TRY
  {
   Platformer::Visual* tolua_ret = (Platformer::Visual*)  self->autoRemove();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Visual.autoRemove'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Visual */
static int tolua_LuaBinding_Platformer_Visual_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Visual* tolua_ret = (Platformer::Visual*)  Platformer::Visual::create(name);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Visual.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: deltaTime of class  Platformer::Behavior::Blackboard */
static int tolua_get_Platformer__Behavior__Blackboard_deltaTime(lua_State* tolua_S){
  Platformer::Behavior::Blackboard* self = (Platformer::Behavior::Blackboard*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'deltaTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getDeltaTime());
 return 1;
}
/* get function: owner of class  Platformer::Behavior::Blackboard */
static int tolua_get_Platformer__Behavior__Blackboard_owner_ptr(lua_State* tolua_S){
  Platformer::Behavior::Blackboard* self = (Platformer::Behavior::Blackboard*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'owner'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getOwner());
 return 1;
}
/* function: Platformer::Behavior::Seq */
static int tolua_LuaBinding_Platformer_Behavior_Seq00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
  Platformer::Behavior::Leaf** nodes = Mtolua_new_dim(Platformer::Behavior::Leaf*, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,1,"Platformer::Behavior::Leaf"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    nodes[i] = ((Platformer::Behavior::Leaf*)  tolua_tofieldusertype(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Seq(nodes,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(nodes);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Seq'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Sel */
static int tolua_LuaBinding_Platformer_Behavior_Sel00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
  Platformer::Behavior::Leaf** nodes = Mtolua_new_dim(Platformer::Behavior::Leaf*, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,1,"Platformer::Behavior::Leaf"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    nodes[i] = ((Platformer::Behavior::Leaf*)  tolua_tofieldusertype(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Sel(nodes,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(nodes);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Sel'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Con */
static int tolua_LuaBinding_Platformer_Behavior_Con00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,2));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Con(name,handler);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Con'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Act */
static int tolua_LuaBinding_Platformer_Behavior_Act00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice action =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Act(action);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Act'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Command */
static int tolua_LuaBinding_Platformer_Behavior_Command00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice action =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Command(action);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Command'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Wait */
static int tolua_LuaBinding_Platformer_Behavior_Wait00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  double duration =  static_cast< double>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Wait(duration);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Wait'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Countdown */
static int tolua_LuaBinding_Platformer_Behavior_Countdown00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  double time =  static_cast< double>(tolua_tonumber(tolua_S,1,0));
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Countdown(time,node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Countdown'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Timeout */
static int tolua_LuaBinding_Platformer_Behavior_Timeout00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  double time =  static_cast< double>(tolua_tonumber(tolua_S,1,0));
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Timeout(time,node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Timeout'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Repeat */
static int tolua_LuaBinding_Platformer_Behavior_Repeat00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int times =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Repeat(times,node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Repeat'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Repeat */
static int tolua_LuaBinding_Platformer_Behavior_Repeat01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Repeat(node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Behavior_Repeat00(tolua_S);
}
/* function: Platformer::Behavior::Retry */
static int tolua_LuaBinding_Platformer_Behavior_Retry00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int times =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Retry(times,node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Retry'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Behavior::Retry */
static int tolua_LuaBinding_Platformer_Behavior_Retry01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Behavior::Leaf* node =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Behavior::Leaf* tolua_ret = (Platformer::Behavior::Leaf*)  Platformer::Behavior::Retry(node);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Behavior_Retry00(tolua_S);
}
/* function: Platformer::Decision::Sel */
static int tolua_LuaBinding_Platformer_Decision_Sel00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
  Platformer::Decision::Leaf** nodes = Mtolua_new_dim(Platformer::Decision::Leaf*, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,1,"Platformer::Decision::Leaf"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    nodes[i] = ((Platformer::Decision::Leaf*)  tolua_tofieldusertype(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Sel(nodes,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(nodes);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Sel'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Seq */
static int tolua_LuaBinding_Platformer_Decision_Seq00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
  Platformer::Decision::Leaf** nodes = Mtolua_new_dim(Platformer::Decision::Leaf*, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isusertypearray(tolua_S,1,"Platformer::Decision::Leaf"_slice,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    nodes[i] = ((Platformer::Decision::Leaf*)  tolua_tofieldusertype(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Seq(nodes,tolua_len);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(nodes);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Seq'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Con */
static int tolua_LuaBinding_Platformer_Decision_Con00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  LuaFunction<bool> handler(tolua_ref_function(tolua_S,2));
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Con(name,handler);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Con'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Act */
static int tolua_LuaBinding_Platformer_Decision_Act00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice action =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Act(action);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Act'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Act */
static int tolua_LuaBinding_Platformer_Decision_Act01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isfunction(tolua_S,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  LuaFunction<string> handler(tolua_ref_function(tolua_S,1));
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Act(handler);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Decision_Act00(tolua_S);
}
/* function: Platformer::Decision::Accept */
static int tolua_LuaBinding_Platformer_Decision_Accept00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Accept();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Accept'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Reject */
static int tolua_LuaBinding_Platformer_Decision_Reject00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Reject();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Reject'.",&tolua_err);
 return 0;
#endif
}
/* function: Platformer::Decision::Behave */
static int tolua_LuaBinding_Platformer_Decision_Behave00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Platformer::Behavior::Leaf"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Platformer::Behavior::Leaf* root =  static_cast< Platformer::Behavior::Leaf*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   Platformer::Decision::Leaf* tolua_ret = (Platformer::Decision::Leaf*)  Platformer::Decision::Behave(name,root);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Behave'.",&tolua_err);
 return 0;
#endif
}
/* method: Platformer::AI_getUnitsByRelation of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getUnitsByRelation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.Platformer::AI_getUnitsByRelation'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Array* tolua_ret = (tolua_outside Array*)  Platformer::AI_getUnitsByRelation(self,relation);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getUnitsByRelation'.",&tolua_err);
 return 0;
#endif
}
/* method: getDetectedUnits of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getDetectedUnits00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.getDetectedUnits'", NULL);
#endif
  TOLUA_TRY
  {
   Array* tolua_ret = (Array*)  self->getDetectedUnits();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getDetectedUnits'.",&tolua_err);
 return 0;
#endif
}
/* method: getDetectedBodies of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getDetectedBodies00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.getDetectedBodies'", NULL);
#endif
  TOLUA_TRY
  {
   Array* tolua_ret = (Array*)  self->getDetectedBodies();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getDetectedBodies'.",&tolua_err);
 return 0;
#endif
}
/* method: Platformer::AI_getNearestUnit of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getNearestUnit00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.Platformer::AI_getNearestUnit'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Platformer::Unit* tolua_ret = (tolua_outside Platformer::Unit*)  Platformer::AI_getNearestUnit(self,relation);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getNearestUnit'.",&tolua_err);
 return 0;
#endif
}
/* method: Platformer::AI_getNearestUnitDistance of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getNearestUnitDistance00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.Platformer::AI_getNearestUnitDistance'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside float tolua_ret = (tolua_outside float)  Platformer::AI_getNearestUnitDistance(self,relation);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getNearestUnitDistance'.",&tolua_err);
 return 0;
#endif
}
/* method: getUnitsInAttackRange of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getUnitsInAttackRange00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.getUnitsInAttackRange'", NULL);
#endif
  TOLUA_TRY
  {
   Array* tolua_ret = (Array*)  self->getUnitsInAttackRange();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getUnitsInAttackRange'.",&tolua_err);
 return 0;
#endif
}
/* method: getBodiesInAttackRange of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_getBodiesInAttackRange00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Decision::AI"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Decision::AI* self = (Platformer::Decision::AI*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Decision::AI.getBodiesInAttackRange'", NULL);
#endif
  TOLUA_TRY
  {
   Array* tolua_ret = (Array*)  self->getBodiesInAttackRange();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.getBodiesInAttackRange'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Decision::AI */
static int tolua_LuaBinding_Platformer_Decision_AI_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Platformer::Decision::AI* tolua_ret = (tolua_outside Platformer::Decision::AI*)  Platformer::AI_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Platformer::Decision::AI>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Decision::AI.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: reaction of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_reaction(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'reaction'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->reaction);
 return 1;
}
/* set function: reaction of class  Platformer::UnitAction */
static int tolua_set_Platformer__UnitAction_reaction(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::UnitAction.reaction'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::UnitAction.reaction'",&tolua_err);
#endif
  TOLUA_TRY
  self->reaction =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: recovery of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_recovery(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'recovery'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->recovery);
 return 1;
}
/* set function: recovery of class  Platformer::UnitAction */
static int tolua_set_Platformer__UnitAction_recovery(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::UnitAction.recovery'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::UnitAction.recovery'",&tolua_err);
#endif
  TOLUA_TRY
  self->recovery =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_CATCH
  return 0;
}
/* get function: name of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_name(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'name'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getName());
 return 1;
}
/* get function: doing of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_doing(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'doing'",NULL);
#endif
  tolua_pushboolean(tolua_S,(bool)self->isDoing());
 return 1;
}
/* get function: owner of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_owner_ptr(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'owner'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getOwner());
 return 1;
}
/* get function: elapsedTime of class  Platformer::UnitAction */
static int tolua_get_Platformer__UnitAction_elapsedTime(lua_State* tolua_S){
  Platformer::UnitAction* self = (Platformer::UnitAction*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'elapsedTime'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getElapsedTime());
 return 1;
}
/* method: Platformer::LuaUnitAction_add of class  Platformer::UnitAction */
static int tolua_LuaBinding_Platformer_UnitAction_add00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,6,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,7,&tolua_err) ||
  !tolua_isfunction(tolua_S,8,&tolua_err) ||
  !tolua_isfunction(tolua_S,9,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  int priority =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  float reaction =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float recovery =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  bool queued =  static_cast< bool>(tolua_toboolean(tolua_S,6,0));
  LuaFunction<bool> available(tolua_ref_function(tolua_S,7));
  LuaFunction<LuaFunction<bool>> create(tolua_ref_function(tolua_S,8));
  LuaFunction<void> stop(tolua_ref_function(tolua_S,9));
  TOLUA_TRY
  {
   Platformer::LuaUnitAction_add(name,priority,reaction,recovery,queued,available,create,stop);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::UnitAction.add'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Platformer::UnitAction */
static int tolua_LuaBinding_Platformer_UnitAction_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Platformer::UnitAction::clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::UnitAction.clear'.",&tolua_err);
 return 0;
#endif
}
/* get function: camera of class  Platformer::PlatformWorld */
static int tolua_get_Platformer__PlatformWorld_camera_ptr(lua_State* tolua_S){
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'camera'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getCamera());
 return 1;
}
/* method: moveChild of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_moveChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  Node* child =  static_cast< Node*>(tolua_tousertype(tolua_S,2,0));
  int newOrder =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.moveChild'", NULL);
#endif
  TOLUA_TRY
  {
   self->moveChild(child,newOrder);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.moveChild'.",&tolua_err);
 return 0;
#endif
}
/* method: getLayer of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_getLayer00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.getLayer'", NULL);
#endif
  TOLUA_TRY
  {
   Node* tolua_ret = (Node*)  self->getLayer(order);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.getLayer'.",&tolua_err);
 return 0;
#endif
}
/* method: setLayerRatio of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_setLayerRatio00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 ratio = tolua_tolight(tolua_S,3);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.setLayerRatio'", NULL);
#endif
  TOLUA_TRY
  {
   self->setLayerRatio(order,ratio);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.setLayerRatio'.",&tolua_err);
 return 0;
#endif
}
/* method: getLayerRatio of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_getLayerRatio00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.getLayerRatio'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->getLayerRatio(order);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.getLayerRatio'.",&tolua_err);
 return 0;
#endif
}
/* method: setLayerOffset of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_setLayerOffset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 offset = tolua_tolight(tolua_S,3);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.setLayerOffset'", NULL);
#endif
  TOLUA_TRY
  {
   self->setLayerOffset(order,offset);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.setLayerOffset'.",&tolua_err);
 return 0;
#endif
}
/* method: getLayerOffset of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_getLayerOffset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.getLayerOffset'", NULL);
#endif
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  self->getLayerOffset(order);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.getLayerOffset'.",&tolua_err);
 return 0;
#endif
}
/* method: swapLayer of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_swapLayer00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int orderA =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int orderB =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.swapLayer'", NULL);
#endif
  TOLUA_TRY
  {
   self->swapLayer(orderA,orderB);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.swapLayer'.",&tolua_err);
 return 0;
#endif
}
/* method: removeLayer of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_removeLayer00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
  int order =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.removeLayer'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeLayer(order);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.removeLayer'.",&tolua_err);
 return 0;
#endif
}
/* method: removeAllLayers of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_removeAllLayers00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Platformer::PlatformWorld"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::PlatformWorld* self = (Platformer::PlatformWorld*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::PlatformWorld.removeAllLayers'", NULL);
#endif
  TOLUA_TRY
  {
   self->removeAllLayers();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.removeAllLayers'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::PlatformWorld */
static int tolua_LuaBinding_Platformer_PlatformWorld_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Platformer::PlatformWorld* tolua_ret = (Platformer::PlatformWorld*)  Platformer::PlatformWorld::create();
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformWorld.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: position of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_position(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'position'",NULL);
#endif
  Vec2 tolua_obj =  self->getPosition();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: position of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_position(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.position'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.position'",&tolua_err);
#endif
  TOLUA_TRY
  self->setPosition(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: rotation of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_rotation(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'rotation'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getRotation());
 return 1;
}
/* set function: rotation of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_rotation(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.rotation'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.rotation'",&tolua_err);
#endif
  TOLUA_TRY
  self->setRotation(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: zoom of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_zoom(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'zoom'",NULL);
#endif
  tolua_pushnumber(tolua_S,(lua_Number)self->getZoom());
 return 1;
}
/* set function: zoom of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_zoom(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.zoom'",NULL);
  if (!tolua_isnumber(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.zoom'",&tolua_err);
#endif
  TOLUA_TRY
  self->setZoom(static_cast< float>(tolua_tonumber(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: boundary of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_boundary(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'boundary'",NULL);
#endif
 void* tolua_obj = Mtolua_new((Rect)(self->getBoundary()));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Rect>());
 return 1;
}
/* set function: boundary of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_boundary(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.boundary'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Rect"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.boundary'",&tolua_err);
#endif
  TOLUA_TRY
  self->setBoundary(* static_cast< Rect*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* get function: followRatio of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_followRatio(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'followRatio'",NULL);
#endif
  Vec2 tolua_obj =  self->getFollowRatio();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: followRatio of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_followRatio(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.followRatio'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.followRatio'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFollowRatio(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: followOffset of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_followOffset(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'followOffset'",NULL);
#endif
  Vec2 tolua_obj =  self->getFollowOffset();
  tolua_pushlight(tolua_S,tolua_obj);
 return 1;
}
/* set function: followOffset of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_followOffset(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.followOffset'",NULL);
  if (!tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.followOffset'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFollowOffset(tolua_tolight(tolua_S,2));
  TOLUA_CATCH
  return 0;
}
/* get function: followTarget of class  Platformer::PlatformCamera */
static int tolua_get_Platformer__PlatformCamera_followTarget_ptr(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'followTarget'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getFollowTarget());
 return 1;
}
/* set function: followTarget of class  Platformer::PlatformCamera */
static int tolua_set_Platformer__PlatformCamera_followTarget_ptr(lua_State* tolua_S){
  Platformer::PlatformCamera* self = (Platformer::PlatformCamera*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Platformer::PlatformCamera.followTarget'",NULL);
  if (!tolua_isobject(tolua_S,2,"Node"_slice,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Platformer::PlatformCamera.followTarget'",&tolua_err);
#endif
  TOLUA_TRY
  self->setFollowTarget(static_cast< Node*>(tolua_tousertype(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Platformer::PlatformCamera */
static int tolua_LuaBinding_Platformer_PlatformCamera_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   Platformer::PlatformCamera* tolua_ret = (Platformer::PlatformCamera*)  Platformer::PlatformCamera::create(name);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::PlatformCamera.new'.",&tolua_err);
 return 0;
#endif
}
/* get function: groupFirstPlayer of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupFirstPlayer(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupFirstPlayer'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupFirstPlayer());
 return 1;
}
/* get function: groupLastPlayer of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupLastPlayer(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupLastPlayer'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupLastPlayer());
 return 1;
}
/* get function: groupHide of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupHide(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupHide'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupHide());
 return 1;
}
/* get function: groupDetectPlayer of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupDetectPlayer(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupDetectPlayer'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupDetectPlayer());
 return 1;
}
/* get function: groupTerrain of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupTerrain(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupTerrain'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupTerrain());
 return 1;
}
/* get function: groupDetection of class  Platformer::Data */
static int tolua_get_Platformer__Data_groupDetection(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'groupDetection'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->getGroupDetection());
 return 1;
}
/* get function: store of class  Platformer::Data */
static int tolua_get_Platformer__Data_store_ptr(lua_State* tolua_S){
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'store'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getStore());
 return 1;
}
/* method: setShouldContact of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_setShouldContact00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
  bool contact =  static_cast< bool>(tolua_toboolean(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.setShouldContact'", NULL);
#endif
  TOLUA_TRY
  {
   self->setShouldContact(groupA,groupB,contact);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.setShouldContact'.",&tolua_err);
 return 0;
#endif
}
/* method: getShouldContact of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_getShouldContact00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.getShouldContact'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->getShouldContact(groupA,groupB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.getShouldContact'.",&tolua_err);
 return 0;
#endif
}
/* method: Data_setRelation of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_setRelation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
   Slice relation =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.Data_setRelation'", NULL);
#endif
  TOLUA_TRY
  {
   Data_setRelation(self,groupA,groupB,relation);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.setRelation'.",&tolua_err);
 return 0;
#endif
}
/* method: Data_getRelation of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_getRelation00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.Data_getRelation'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Slice tolua_ret = (tolua_outside Slice)  Data_getRelation(self,groupA,groupB);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.getRelation'.",&tolua_err);
 return 0;
#endif
}
/* method: Data_getRelation of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_getRelation01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.Data_getRelation'", NULL);
#endif
  TOLUA_TRY
  {
   tolua_outside Slice tolua_ret = (tolua_outside Slice)  Data_getRelation(self,bodyA,bodyB);
   tolua_pushslice(tolua_S,(Slice)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Data_getRelation00(tolua_S);
}
/* method: isEnemy of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isEnemy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isEnemy'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isEnemy(groupA,groupB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.isEnemy'.",&tolua_err);
 return 0;
#endif
}
/* method: isEnemy of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isEnemy01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isEnemy'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isEnemy(bodyA,bodyB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Data_isEnemy00(tolua_S);
}
/* method: isFriend of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isFriend00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isFriend'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isFriend(groupA,groupB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.isFriend'.",&tolua_err);
 return 0;
#endif
}
/* method: isFriend of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isFriend01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isFriend'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isFriend(bodyA,bodyB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Data_isFriend00(tolua_S);
}
/* method: isNeutral of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isNeutral00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint8_t groupA =  static_cast< uint8_t>(tolua_tointeger(tolua_S,2,0));
  uint8_t groupB =  static_cast< uint8_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isNeutral'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isNeutral(groupA,groupB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.isNeutral'.",&tolua_err);
 return 0;
#endif
}
/* method: isNeutral of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isNeutral01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,3,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* bodyA =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
  Body* bodyB =  static_cast< Body*>(tolua_tousertype(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isNeutral'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isNeutral(bodyA,bodyB);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_Platformer_Data_isNeutral00(tolua_S);
}
/* method: setDamageFactor of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_setDamageFactor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint16_t damageType =  static_cast< uint16_t>(tolua_tointeger(tolua_S,2,0));
  uint16_t defenceType =  static_cast< uint16_t>(tolua_tointeger(tolua_S,3,0));
  float bounus =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.setDamageFactor'", NULL);
#endif
  TOLUA_TRY
  {
   self->setDamageFactor(damageType,defenceType,bounus);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.setDamageFactor'.",&tolua_err);
 return 0;
#endif
}
/* method: getDamageFactor of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_getDamageFactor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  uint16_t damageType =  static_cast< uint16_t>(tolua_tointeger(tolua_S,2,0));
  uint16_t defenceType =  static_cast< uint16_t>(tolua_tointeger(tolua_S,3,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.getDamageFactor'", NULL);
#endif
  TOLUA_TRY
  {
   float tolua_ret = (float)  self->getDamageFactor(damageType,defenceType);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.getDamageFactor'.",&tolua_err);
 return 0;
#endif
}
/* method: isPlayer of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isPlayer00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* body =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isPlayer'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isPlayer(body);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.isPlayer'.",&tolua_err);
 return 0;
#endif
}
/* method: isTerrain of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_isTerrain00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Body"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
  Body* body =  static_cast< Body*>(tolua_tousertype(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.isTerrain'", NULL);
#endif
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  self->isTerrain(body);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.isTerrain'.",&tolua_err);
 return 0;
#endif
}
/* method: clear of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_clear00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Platformer::Data"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Platformer::Data* self = (Platformer::Data*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Platformer::Data.clear'", NULL);
#endif
  TOLUA_TRY
  {
   self->clear();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.clear'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  Platformer::Data */
static int tolua_LuaBinding_Platformer_Data_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   tolua_outside Platformer::Data* tolua_ret = (tolua_outside Platformer::Data*)  Platformer::Data_shared();
  tolua_pushusertype(tolua_S,(void*)tolua_ret,LuaType<Platformer::Data>());
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Platformer::Data.new'.",&tolua_err);
 return 0;
#endif
}
/* method: resize of class  Buffer */
static int tolua_LuaBinding_Buffer_resize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Buffer"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Buffer* self = (Buffer*)  tolua_tousertype(tolua_S,1,0);
  uint32_t size =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Buffer.resize'", NULL);
#endif
  TOLUA_TRY
  {
   self->resize(size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Buffer.resize'.",&tolua_err);
 return 0;
#endif
}
/* method: zeroMemory of class  Buffer */
static int tolua_LuaBinding_Buffer_zeroMemory00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Buffer"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Buffer* self = (Buffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'Buffer.zeroMemory'", NULL);
#endif
  TOLUA_TRY
  {
   self->zeroMemory();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Buffer.zeroMemory'.",&tolua_err);
 return 0;
#endif
}
/* get function: size of class  Buffer */
static int tolua_get_Buffer_size(lua_State* tolua_S){
  Buffer* self = (Buffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'size'",NULL);
#endif
  tolua_pushinteger(tolua_S,(lua_Integer)self->size());
 return 1;
}
/* get function: text of class  Buffer */
static int tolua_get_Buffer_text(lua_State* tolua_S){
  Buffer* self = (Buffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'text'",NULL);
#endif
  tolua_pushslice(tolua_S,(Slice)self->getText());
 return 1;
}
/* set function: text of class  Buffer */
static int tolua_set_Buffer_text(lua_State* tolua_S){
  Buffer* self = (Buffer*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  tolua_Error tolua_err;
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'Buffer.text'",NULL);
  if (!tolua_isslice(tolua_S,2,0,&tolua_err)) tolua_error(tolua_S,"#vinvalid type in variable assignment for 'Buffer.text'",&tolua_err);
#endif
  TOLUA_TRY
  self->setText(static_cast< string>(tolua_toslice(tolua_S,2,0)));
  TOLUA_CATCH
  return 0;
}
/* method: new_local of class  Buffer */
static int tolua_LuaBinding_Buffer_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  uint32_t size =  static_cast< uint32_t>(tolua_tointeger(tolua_S,2,0));
  TOLUA_TRY
  {
   Buffer* tolua_ret = (Buffer*)  Buffer::create(size);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Buffer.new'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetDefaultFont */
static int tolua_LuaBinding_ImGui_SetDefaultFont00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice ttfFontFile =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  float fontSize =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::SetDefaultFont(ttfFontFile,fontSize);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetDefaultFont'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ShowStats */
static int tolua_LuaBinding_ImGui_ShowStats00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,3,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool pOpen =  static_cast< bool>(tolua_toboolean(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* windowFlags = Mtolua_new_dim(Slice, tolua_len);
  LuaFunction<void> handler(tolua_ref_function(tolua_S,3));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    windowFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::Binding::ShowStats(&pOpen,windowFlags,tolua_len,handler);
   tolua_pushboolean(tolua_S,(bool)pOpen);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(windowFlags);
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowStats'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ShowStats */
static int tolua_LuaBinding_ImGui_ShowStats01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  TOLUA_TRY
  {
   ImGui::Binding::ShowStats();
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ShowStats00(tolua_S);
}
/* function: ImGui::Binding::ShowConsole */
static int tolua_LuaBinding_ImGui_ShowConsole00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool initOnly =  static_cast< bool>(tolua_toboolean(tolua_S,1,false));
  TOLUA_TRY
  {
   ImGui::Binding::ShowConsole(initOnly);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowConsole'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Begin */
static int tolua_LuaBinding_ImGui_Begin00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Begin(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Begin'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Begin */
static int tolua_LuaBinding_ImGui_Begin01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* windowsFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    windowsFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Begin(name,windowsFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(windowsFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Begin00(tolua_S);
}
/* function: ImGui::Binding::Begin */
static int tolua_LuaBinding_ImGui_Begin02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Begin(name,&p_open);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Begin01(tolua_S);
}
/* function: ImGui::Binding::Begin */
static int tolua_LuaBinding_ImGui_Begin03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* windowsFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    windowsFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Begin(name,&p_open,windowsFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(windowsFlags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Begin02(tolua_S);
}
/* function: ImGui::Binding::BeginChild */
static int tolua_LuaBinding_ImGui_BeginChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginChild(str_id,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginChild'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginChild */
static int tolua_LuaBinding_ImGui_BeginChild01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* childFlags = Mtolua_new_dim(Slice, tolua_len);
  int tolua_len_1 = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* windowFlags = Mtolua_new_dim(Slice, tolua_len_1);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    childFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len_1,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len_1;i++)    windowFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginChild(str_id,size,childFlags,tolua_len,windowFlags,tolua_len_1);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(childFlags);
  Mtolua_delete_dim(windowFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginChild00(tolua_S);
}
/* function: ImGui::Binding::BeginChild */
static int tolua_LuaBinding_ImGui_BeginChild02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  unsigned int id =  static_cast< unsigned int>(tolua_tointeger(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginChild(id,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginChild01(tolua_S);
}
/* function: ImGui::Binding::BeginChild */
static int tolua_LuaBinding_ImGui_BeginChild03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  unsigned int id =  static_cast< unsigned int>(tolua_tointeger(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* childFlags = Mtolua_new_dim(Slice, tolua_len);
  int tolua_len_1 = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* windowFlags = Mtolua_new_dim(Slice, tolua_len_1);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    childFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len_1,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len_1;i++)    windowFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginChild(id,size,childFlags,tolua_len,windowFlags,tolua_len_1);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(childFlags);
  Mtolua_delete_dim(windowFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginChild02(tolua_S);
}
/* function: ImGui::Binding::SetNextWindowPos */
static int tolua_LuaBinding_ImGui_SetNextWindowPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 pos = tolua_tolight(tolua_S,1);
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  Vec2 pivot = tolua_tolight(tolua_S,3,Vec2::zero);
  TOLUA_TRY
  {
   ImGui::Binding::SetNextWindowPos(pos,setCond,pivot);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetNextWindowPosCenter */
static int tolua_LuaBinding_ImGui_SetNextWindowPosCenter00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,1,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,1,nullptr));
  Vec2 pivot = tolua_tolight(tolua_S,2,Vec2::zero);
  TOLUA_TRY
  {
   ImGui::Binding::SetNextWindowPosCenter(setCond,pivot);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowPosCenter'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetNextWindowSize */
static int tolua_LuaBinding_ImGui_SetNextWindowSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 size = tolua_tolight(tolua_S,1);
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetNextWindowSize(size,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowSize'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetNextWindowCollapsed */
static int tolua_LuaBinding_ImGui_SetNextWindowCollapsed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool collapsed =  static_cast< bool>(tolua_toboolean(tolua_S,1,0));
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetNextWindowCollapsed(collapsed,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowCollapsed'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetWindowPos */
static int tolua_LuaBinding_ImGui_SetWindowPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 pos = tolua_tolight(tolua_S,2);
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,3,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetWindowPos(name,pos,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWindowPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetWindowSize */
static int tolua_LuaBinding_ImGui_SetWindowSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,3,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetWindowSize(name,size,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWindowSize'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetWindowCollapsed */
static int tolua_LuaBinding_ImGui_SetWindowCollapsed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool collapsed =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,3,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetWindowCollapsed(name,collapsed,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWindowCollapsed'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetColorEditOptions */
static int tolua_LuaBinding_ImGui_SetColorEditOptions00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
   Slice* colorEditFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,1,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    colorEditFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::Binding::SetColorEditOptions(colorEditFlags,tolua_len);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(colorEditFlags);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetColorEditOptions'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputText */
static int tolua_LuaBinding_ImGui_InputText00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Buffer"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Buffer* buffer =  static_cast< Buffer*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputText(label,buffer);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputText'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputText */
static int tolua_LuaBinding_ImGui_InputText01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Buffer"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Buffer* buffer =  static_cast< Buffer*>(tolua_tousertype(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* inputTextFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    inputTextFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputText(label,buffer,inputTextFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(inputTextFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputText00(tolua_S);
}
/* function: ImGui::Binding::InputTextMultiline */
static int tolua_LuaBinding_ImGui_InputTextMultiline00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Buffer"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Buffer* buffer =  static_cast< Buffer*>(tolua_tousertype(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputTextMultiline(label,buffer,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputTextMultiline'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputTextMultiline */
static int tolua_LuaBinding_ImGui_InputTextMultiline01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isobject(tolua_S,2,"Buffer"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Buffer* buffer =  static_cast< Buffer*>(tolua_tousertype(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* inputTextFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    inputTextFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputTextMultiline(label,buffer,size,inputTextFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(inputTextFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputTextMultiline00(tolua_S);
}
/* function: ImGui::Binding::TreeNodeEx */
static int tolua_LuaBinding_ImGui_TreeNodeEx00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TreeNodeEx(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TreeNodeEx'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TreeNodeEx */
static int tolua_LuaBinding_ImGui_TreeNodeEx01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* treeNodeFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    treeNodeFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TreeNodeEx(label,treeNodeFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(treeNodeFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TreeNodeEx00(tolua_S);
}
/* function: ImGui::Binding::TreeNodeEx */
static int tolua_LuaBinding_ImGui_TreeNodeEx02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TreeNodeEx(str_id,text);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TreeNodeEx01(tolua_S);
}
/* function: ImGui::Binding::TreeNodeEx */
static int tolua_LuaBinding_ImGui_TreeNodeEx03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* treeNodeFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    treeNodeFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TreeNodeEx(str_id,text,treeNodeFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(treeNodeFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TreeNodeEx02(tolua_S);
}
/* function: ImGui::Binding::SetNextItemOpen */
static int tolua_LuaBinding_ImGui_SetNextItemOpen00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isboolean(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  bool is_open =  static_cast< bool>(tolua_toboolean(tolua_S,1,0));
   Slice setCond =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::SetNextItemOpen(is_open,setCond);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextItemOpen'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::CollapsingHeader */
static int tolua_LuaBinding_ImGui_CollapsingHeader00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::CollapsingHeader(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CollapsingHeader'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::CollapsingHeader */
static int tolua_LuaBinding_ImGui_CollapsingHeader01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* treeNodeFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    treeNodeFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::CollapsingHeader(label,treeNodeFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(treeNodeFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_CollapsingHeader00(tolua_S);
}
/* function: ImGui::Binding::CollapsingHeader */
static int tolua_LuaBinding_ImGui_CollapsingHeader02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::CollapsingHeader(label,&p_open);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_CollapsingHeader01(tolua_S);
}
/* function: ImGui::Binding::CollapsingHeader */
static int tolua_LuaBinding_ImGui_CollapsingHeader03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* treeNodeFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    treeNodeFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::CollapsingHeader(label,&p_open,treeNodeFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(treeNodeFlags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_CollapsingHeader02(tolua_S);
}
/* function: ImGui::Binding::Selectable */
static int tolua_LuaBinding_ImGui_Selectable00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Selectable(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Selectable'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Selectable */
static int tolua_LuaBinding_ImGui_Selectable01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* selectableFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    selectableFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Selectable(label,selectableFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(selectableFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Selectable00(tolua_S);
}
/* function: ImGui::Binding::Selectable */
static int tolua_LuaBinding_ImGui_Selectable02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_selected =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Selectable(label,&p_selected,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_selected);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Selectable01(tolua_S);
}
/* function: ImGui::Binding::Selectable */
static int tolua_LuaBinding_ImGui_Selectable03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_selected =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3);
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* selectableFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    selectableFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Selectable(label,&p_selected,size,selectableFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_selected);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(selectableFlags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Selectable02(tolua_S);
}
/* function: ImGui::Binding::BeginPopupModal */
static int tolua_LuaBinding_ImGui_BeginPopupModal00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupModal(name);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPopupModal'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginPopupModal */
static int tolua_LuaBinding_ImGui_BeginPopupModal01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* windowsFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    windowsFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupModal(name,windowsFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(windowsFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupModal00(tolua_S);
}
/* function: ImGui::Binding::BeginPopupModal */
static int tolua_LuaBinding_ImGui_BeginPopupModal02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupModal(name,&p_open);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupModal01(tolua_S);
}
/* function: ImGui::Binding::BeginPopupModal */
static int tolua_LuaBinding_ImGui_BeginPopupModal03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* windowsFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    windowsFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupModal(name,&p_open,windowsFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(windowsFlags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupModal02(tolua_S);
}
/* function: ImGui::Binding::PushStyleColor */
static int tolua_LuaBinding_ImGui_PushStyleColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::PushStyleColor(name,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushStyleColor'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::PushStyleVar */
static int tolua_LuaBinding_ImGui_PushStyleVar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  float val =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::PushStyleVar(name,val);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushStyleVar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::PushStyleVar */
static int tolua_LuaBinding_ImGui_PushStyleVar01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Vec2 val = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   ImGui::Binding::PushStyleVar(name,val);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_PushStyleVar00(tolua_S);
}
/* function: ImGui::Binding::Text */
static int tolua_LuaBinding_ImGui_Text00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::Binding::Text(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Text'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TextColored */
static int tolua_LuaBinding_ImGui_TextColored00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color"_slice,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,1,0));
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::TextColored(color,text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextColored'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TextDisabled */
static int tolua_LuaBinding_ImGui_TextDisabled00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::Binding::TextDisabled(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextDisabled'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TextWrapped */
static int tolua_LuaBinding_ImGui_TextWrapped00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::Binding::TextWrapped(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextWrapped'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::LabelText */
static int tolua_LuaBinding_ImGui_LabelText00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::LabelText(label,text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LabelText'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BulletText */
static int tolua_LuaBinding_ImGui_BulletText00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::Binding::BulletText(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BulletText'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TreeNode */
static int tolua_LuaBinding_ImGui_TreeNode00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TreeNode(str_id,text);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TreeNode'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetTooltip */
static int tolua_LuaBinding_ImGui_SetTooltip00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::Binding::SetTooltip(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTooltip'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ColorEdit3 */
static int tolua_LuaBinding_ImGui_ColorEdit300(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color3"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color3* color3 =  static_cast< Color3*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorEdit3(label,color3);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ColorEdit3'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ColorEdit3 */
static int tolua_LuaBinding_ImGui_ColorEdit301(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color3"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color3* color3 =  static_cast< Color3*>(tolua_tousertype(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* colorEditFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    colorEditFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorEdit3(label,color3,colorEditFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(colorEditFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ColorEdit300(tolua_S);
}
/* function: ImGui::Binding::ColorEdit4 */
static int tolua_LuaBinding_ImGui_ColorEdit400(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color* color =  static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorEdit4(label,color);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ColorEdit4'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ColorEdit4 */
static int tolua_LuaBinding_ImGui_ColorEdit401(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color* color =  static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* colorEditFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    colorEditFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorEdit4(label,color,colorEditFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(colorEditFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ColorEdit400(tolua_S);
}
/* function: ImGui::Binding::Image */
static int tolua_LuaBinding_ImGui_Image00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   ImGui::Binding::Image(clipStr,size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Image'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Image */
static int tolua_LuaBinding_ImGui_Image01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  Color bg_col = * static_cast< Color*>(tolua_tousertype(tolua_S,3,0));
  TOLUA_TRY
  {
   ImGui::Binding::Image(clipStr,size,bg_col);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Image00(tolua_S);
}
/* function: ImGui::Binding::Image */
static int tolua_LuaBinding_ImGui_Image02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Color"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  Color bg_col = * static_cast< Color*>(tolua_tousertype(tolua_S,3,0));
  Color tint_col = * static_cast< Color*>(tolua_tousertype(tolua_S,4,0));
  TOLUA_TRY
  {
   ImGui::Binding::Image(clipStr,size,bg_col,tint_col);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Image01(tolua_S);
}
/* function: ImGui::Binding::ImageButton */
static int tolua_LuaBinding_ImGui_ImageButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  const char* str_id =  static_cast< const char*>(tolua_tostring(tolua_S,1,0));
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ImageButton(str_id,clipStr,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ImageButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ImageButton */
static int tolua_LuaBinding_ImGui_ImageButton01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  const char* str_id =  static_cast< const char*>(tolua_tostring(tolua_S,1,0));
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3);
  Color bg_col = * static_cast< Color*>(tolua_tousertype(tolua_S,4,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ImageButton(str_id,clipStr,size,bg_col);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ImageButton00(tolua_S);
}
/* function: ImGui::Binding::ImageButton */
static int tolua_LuaBinding_ImGui_ImageButton02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Color"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  const char* str_id =  static_cast< const char*>(tolua_tostring(tolua_S,1,0));
   Slice clipStr =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  Vec2 size = tolua_tolight(tolua_S,3);
  Color bg_col = * static_cast< Color*>(tolua_tousertype(tolua_S,4,0));
  Color tint_col = * static_cast< Color*>(tolua_tousertype(tolua_S,5,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ImageButton(str_id,clipStr,size,bg_col,tint_col);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ImageButton01(tolua_S);
}
/* function: ImGui::Binding::ColorButton */
static int tolua_LuaBinding_ImGui_ColorButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring desc_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color col = * static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorButton(desc_id,col);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ColorButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::ColorButton */
static int tolua_LuaBinding_ImGui_ColorButton01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring desc_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Color col = * static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* colorEditFlags = Mtolua_new_dim(Slice, tolua_len);
  Vec2 size = tolua_tolight(tolua_S,4,Vec2::zero);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    colorEditFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::ColorButton(desc_id,col,colorEditFlags,tolua_len,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(colorEditFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ColorButton00(tolua_S);
}
/* function: ImGui::Binding::Columns */
static int tolua_LuaBinding_ImGui_Columns00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int count =  static_cast< int>(tolua_tointeger(tolua_S,1,1));
  bool border =  static_cast< bool>(tolua_toboolean(tolua_S,2,true));
  TOLUA_TRY
  {
   ImGui::Binding::Columns(count,border);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Columns'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Columns */
static int tolua_LuaBinding_ImGui_Columns01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isstring(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  int count =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  bool border =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
   _cstring id =  static_cast<  _cstring>(tolua_tostring(tolua_S,3,0));
  TOLUA_TRY
  {
   ImGui::Binding::Columns(count,border,id);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Columns00(tolua_S);
}
/* function: ImGui::Binding::BeginTable */
static int tolua_LuaBinding_ImGui_BeginTable00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int column =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 outer_size = tolua_tolight(tolua_S,3,Vec2::zero);
  float inner_width =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTable(str_id,column,outer_size,inner_width);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginTable'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginTable */
static int tolua_LuaBinding_ImGui_BeginTable01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,3,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_istable(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int column =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  Vec2 outer_size = tolua_tolight(tolua_S,3);
  float inner_width =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,5));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,5,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,5,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTable(str_id,column,outer_size,inner_width,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginTable00(tolua_S);
}
/* function: ImGui::Binding::TableNextRow */
static int tolua_LuaBinding_ImGui_TableNextRow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isslice(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float min_row_height =  static_cast< float>(tolua_tonumber(tolua_S,1,0.0f));
   Slice row_flag =  static_cast<  Slice>(tolua_toslice(tolua_S,2,nullptr));
  TOLUA_TRY
  {
   ImGui::Binding::TableNextRow(min_row_height,row_flag);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableNextRow'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TableSetupColumn */
static int tolua_LuaBinding_ImGui_TableSetupColumn00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float init_width_or_weight =  static_cast< float>(tolua_tonumber(tolua_S,2,0.0f));
  uint32_t user_id =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  TOLUA_TRY
  {
   ImGui::Binding::TableSetupColumn(label,init_width_or_weight,user_id);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableSetupColumn'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TableSetupColumn */
static int tolua_LuaBinding_ImGui_TableSetupColumn01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float init_width_or_weight =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  uint32_t user_id =  static_cast< uint32_t>(tolua_tointeger(tolua_S,3,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::Binding::TableSetupColumn(label,init_width_or_weight,user_id,flags,tolua_len);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TableSetupColumn00(tolua_S);
}
/* function: ImGui::Binding::SetStyleVar */
static int tolua_LuaBinding_ImGui_SetStyleVar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  bool var =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::SetStyleVar(name,var);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStyleVar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SetStyleVar */
static int tolua_LuaBinding_ImGui_SetStyleVar01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  float var =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::SetStyleVar(name,var);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SetStyleVar00(tolua_S);
}
/* function: ImGui::Binding::SetStyleVar */
static int tolua_LuaBinding_ImGui_SetStyleVar02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Vec2 var = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   ImGui::Binding::SetStyleVar(name,var);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SetStyleVar01(tolua_S);
}
/* function: ImGui::Binding::SetStyleColor */
static int tolua_LuaBinding_ImGui_SetStyleColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Binding::SetStyleColor(name,color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetStyleColor'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::Combo */
static int tolua_LuaBinding_ImGui_Combo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int current_item =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   _cstring* items = Mtolua_new_dim(_cstring, tolua_len);
  int height_in_items =  static_cast< int>(tolua_tointeger(tolua_S,4,-1));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isstringarray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    items[i] = ((_cstring)  tolua_tofieldstring(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::Combo(label,&current_item,items,tolua_len,height_in_items);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)current_item);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(items);
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Combo'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragFloat */
static int tolua_LuaBinding_ImGui_DragFloat00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloat(label,&v,v_speed,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragFloat'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragFloat */
static int tolua_LuaBinding_ImGui_DragFloat01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloat(label,&v,v_speed,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragFloat00(tolua_S);
}
/* function: ImGui::Binding::DragFloat2 */
static int tolua_LuaBinding_ImGui_DragFloat200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isstring(tolua_S,7,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloat2(label,&v1,&v2,v_speed,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragFloat2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragFloat2 */
static int tolua_LuaBinding_ImGui_DragFloat201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isstring(tolua_S,7,0,&tolua_err) ||
  !tolua_istable(tolua_S,8,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,8));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,8,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,8,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloat2(label,&v1,&v2,v_speed,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragFloat200(tolua_S);
}
/* function: ImGui::Binding::DragInt */
static int tolua_LuaBinding_ImGui_DragInt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%d"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragInt(label,&v,v_speed,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragInt'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragInt */
static int tolua_LuaBinding_ImGui_DragInt01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragInt(label,&v,v_speed,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragInt00(tolua_S);
}
/* function: ImGui::Binding::DragInt2 */
static int tolua_LuaBinding_ImGui_DragInt200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,6,1,&tolua_err) ||
  !tolua_isstring(tolua_S,7,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,6,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,"%d"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragInt2(label,&v1,&v2,v_speed,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragInt2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragInt2 */
static int tolua_LuaBinding_ImGui_DragInt201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,6,0,&tolua_err) ||
  !tolua_isstring(tolua_S,7,0,&tolua_err) ||
  !tolua_istable(tolua_S,8,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,6,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,8));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,8,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,8,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragInt2(label,&v1,&v2,v_speed,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragInt200(tolua_S);
}
/* function: ImGui::Binding::InputFloat */
static int tolua_LuaBinding_ImGui_InputFloat00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isstring(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float step =  static_cast< float>(tolua_tonumber(tolua_S,3,0.0f));
  float step_fast =  static_cast< float>(tolua_tonumber(tolua_S,4,0.0f));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputFloat(label,&v,step,step_fast,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputFloat'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputFloat */
static int tolua_LuaBinding_ImGui_InputFloat01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isstring(tolua_S,5,0,&tolua_err) ||
  !tolua_istable(tolua_S,6,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float step =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float step_fast =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,6));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,6,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,6,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputFloat(label,&v,step,step_fast,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputFloat00(tolua_S);
}
/* function: ImGui::Binding::InputFloat2 */
static int tolua_LuaBinding_ImGui_InputFloat200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isstring(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,4,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputFloat2(label,&v1,&v2,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputFloat2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputFloat2 */
static int tolua_LuaBinding_ImGui_InputFloat201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isstring(tolua_S,4,0,&tolua_err) ||
  !tolua_istable(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,4,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,5));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,5,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,5,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputFloat2(label,&v1,&v2,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputFloat200(tolua_S);
}
/* function: ImGui::Binding::InputInt */
static int tolua_LuaBinding_ImGui_InputInt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int step =  static_cast< int>(tolua_tointeger(tolua_S,3,1));
  int step_fast =  static_cast< int>(tolua_tointeger(tolua_S,4,100));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputInt(label,&v,step,step_fast);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputInt'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputInt */
static int tolua_LuaBinding_ImGui_InputInt01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_istable(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int step =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int step_fast =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,5));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,5,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,5,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputInt(label,&v,step,step_fast,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputInt00(tolua_S);
}
/* function: ImGui::Binding::InputInt2 */
static int tolua_LuaBinding_ImGui_InputInt200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputInt2(label,&v1,&v2);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InputInt2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::InputInt2 */
static int tolua_LuaBinding_ImGui_InputInt201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::InputInt2(label,&v1,&v2,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_InputInt200(tolua_S);
}
/* function: ImGui::Binding::SliderFloat */
static int tolua_LuaBinding_ImGui_SliderFloat00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isstring(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderFloat(label,&v,v_min,v_max,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SliderFloat'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SliderFloat */
static int tolua_LuaBinding_ImGui_SliderFloat01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isstring(tolua_S,5,0,&tolua_err) ||
  !tolua_istable(tolua_S,6,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,6));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,6,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,6,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderFloat(label,&v,v_min,v_max,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SliderFloat00(tolua_S);
}
/* function: ImGui::Binding::SliderFloat2 */
static int tolua_LuaBinding_ImGui_SliderFloat200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderFloat2(label,&v1,&v2,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SliderFloat2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SliderFloat2 */
static int tolua_LuaBinding_ImGui_SliderFloat201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderFloat2(label,&v1,&v2,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v1);
   tolua_pushnumber(tolua_S,(lua_Number)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SliderFloat200(tolua_S);
}
/* function: ImGui::Binding::SliderInt */
static int tolua_LuaBinding_ImGui_SliderInt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isstring(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,"%d"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderInt(label,&v,v_min,v_max,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SliderInt'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SliderInt */
static int tolua_LuaBinding_ImGui_SliderInt01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isstring(tolua_S,5,0,&tolua_err) ||
  !tolua_istable(tolua_S,6,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,5,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,6));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,6,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,6,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderInt(label,&v,v_min,v_max,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SliderInt00(tolua_S);
}
/* function: ImGui::Binding::SliderInt2 */
static int tolua_LuaBinding_ImGui_SliderInt200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%d"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderInt2(label,&v1,&v2,v_min,v_max,display_format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SliderInt2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::SliderInt2 */
static int tolua_LuaBinding_ImGui_SliderInt201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v1 =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v2 =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring display_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::SliderInt2(label,&v1,&v2,v_min,v_max,display_format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v1);
   tolua_pushinteger(tolua_S,(lua_Integer)v2);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_SliderInt200(tolua_S);
}
/* function: ImGui::Binding::DragFloatRange2 */
static int tolua_LuaBinding_ImGui_DragFloatRange200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isstring(tolua_S,7,1,&tolua_err) ||
  !tolua_isstring(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v_current_min =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_current_max =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,5,0.0f));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,6,0.0f));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,"%.2f"));
   _cstring format_max =  static_cast<  _cstring>(tolua_tostring(tolua_S,8,nullptr));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloatRange2(label,&v_current_min,&v_current_max,v_speed,v_min,v_max,format,format_max);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v_current_min);
   tolua_pushnumber(tolua_S,(lua_Number)v_current_max);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragFloatRange2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragFloatRange2 */
static int tolua_LuaBinding_ImGui_DragFloatRange201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isstring(tolua_S,7,0,&tolua_err) ||
  !tolua_isstring(tolua_S,8,0,&tolua_err) ||
  !tolua_istable(tolua_S,9,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v_current_min =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_current_max =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,0));
   _cstring format_max =  static_cast<  _cstring>(tolua_tostring(tolua_S,8,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,9));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,9,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,9,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragFloatRange2(label,&v_current_min,&v_current_max,v_speed,v_min,v_max,format,format_max,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v_current_min);
   tolua_pushnumber(tolua_S,(lua_Number)v_current_max);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragFloatRange200(tolua_S);
}
/* function: ImGui::Binding::DragIntRange2 */
static int tolua_LuaBinding_ImGui_DragIntRange200(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,6,1,&tolua_err) ||
  !tolua_isstring(tolua_S,7,1,&tolua_err) ||
  !tolua_isstring(tolua_S,8,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v_current_min =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v_current_max =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,6,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,"%d"));
   _cstring format_max =  static_cast<  _cstring>(tolua_tostring(tolua_S,8,nullptr));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragIntRange2(label,&v_current_min,&v_current_max,v_speed,v_min,v_max,format,format_max);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v_current_min);
   tolua_pushinteger(tolua_S,(lua_Integer)v_current_max);
  }
  TOLUA_CATCH
 }
 return 3;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DragIntRange2'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::DragIntRange2 */
static int tolua_LuaBinding_ImGui_DragIntRange201(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,6,0,&tolua_err) ||
  !tolua_isstring(tolua_S,7,0,&tolua_err) ||
  !tolua_isstring(tolua_S,8,0,&tolua_err) ||
  !tolua_istable(tolua_S,9,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,10,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v_current_min =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v_current_max =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  float v_speed =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,6,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,7,0));
   _cstring format_max =  static_cast<  _cstring>(tolua_tostring(tolua_S,8,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,9));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,9,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,9,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::DragIntRange2(label,&v_current_min,&v_current_max,v_speed,v_min,v_max,format,format_max,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v_current_min);
   tolua_pushinteger(tolua_S,(lua_Integer)v_current_max);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 3;
tolua_lerror:
 return tolua_LuaBinding_ImGui_DragIntRange200(tolua_S);
}
/* function: ImGui::Binding::VSliderFloat */
static int tolua_LuaBinding_ImGui_VSliderFloat00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  float v =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%.2f"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::VSliderFloat(label,size,&v,v_min,v_max,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'VSliderFloat'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::VSliderFloat */
static int tolua_LuaBinding_ImGui_VSliderFloat01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  float v =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float v_min =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float v_max =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::VSliderFloat(label,size,&v,v_min,v_max,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_VSliderFloat00(tolua_S);
}
/* function: ImGui::Binding::VSliderInt */
static int tolua_LuaBinding_ImGui_VSliderInt00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  int v =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,"%d"));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::VSliderInt(label,size,&v,v_min,v_max,format);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'VSliderInt'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::VSliderInt */
static int tolua_LuaBinding_ImGui_VSliderInt01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,0,&tolua_err) ||
  !tolua_isstring(tolua_S,6,0,&tolua_err) ||
  !tolua_istable(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  int v =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  int v_min =  static_cast< int>(tolua_tointeger(tolua_S,4,0));
  int v_max =  static_cast< int>(tolua_tointeger(tolua_S,5,0));
   _cstring format =  static_cast<  _cstring>(tolua_tostring(tolua_S,6,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,7));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,7,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,7,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::VSliderInt(label,size,&v,v_min,v_max,format,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_VSliderInt00(tolua_S);
}
/* function: ImGui::Binding::ScrollWhenDraggingOnVoid */
static int tolua_LuaBinding_ImGui_ScrollWhenDraggingOnVoid00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::Binding::ScrollWhenDraggingOnVoid();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ScrollWhenDraggingOnVoid'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextWindowBgAlpha */
static int tolua_LuaBinding_ImGui_SetNextWindowBgAlpha00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float alpha =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetNextWindowBgAlpha(alpha);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowBgAlpha'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::ShowDemoWindow */
static int tolua_LuaBinding_ImGui_ShowDemoWindow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::ShowDemoWindow();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ShowDemoWindow'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::End */
static int tolua_LuaBinding_ImGui_End00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::End();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'End'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndChild */
static int tolua_LuaBinding_ImGui_EndChild00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndChild();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndChild'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetContentRegionAvail */
static int tolua_LuaBinding_ImGui_GetContentRegionAvail00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetContentRegionAvail();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetContentRegionAvail'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetWindowPos */
static int tolua_LuaBinding_ImGui_GetWindowPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetWindowPos();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetWindowSize */
static int tolua_LuaBinding_ImGui_GetWindowSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetWindowSize();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowSize'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetWindowWidth */
static int tolua_LuaBinding_ImGui_GetWindowWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetWindowWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetWindowHeight */
static int tolua_LuaBinding_ImGui_GetWindowHeight00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetWindowHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetWindowHeight'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsWindowCollapsed */
static int tolua_LuaBinding_ImGui_IsWindowCollapsed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsWindowCollapsed();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsWindowCollapsed'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextWindowSizeConstraints */
static int tolua_LuaBinding_ImGui_SetNextWindowSizeConstraints00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 size_min = tolua_tolight(tolua_S,1);
  Vec2 size_max = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   ImGui::SetNextWindowSizeConstraints(size_min,size_max);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowSizeConstraints'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextWindowContentSize */
static int tolua_LuaBinding_ImGui_SetNextWindowContentSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 size = tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   ImGui::SetNextWindowContentSize(size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowContentSize'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextWindowFocus */
static int tolua_LuaBinding_ImGui_SetNextWindowFocus00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::SetNextWindowFocus();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextWindowFocus'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetWindowFocus */
static int tolua_LuaBinding_ImGui_SetWindowFocus00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring name =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetWindowFocus(name);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetWindowFocus'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetScrollX */
static int tolua_LuaBinding_ImGui_GetScrollX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetScrollX();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScrollX'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetScrollY */
static int tolua_LuaBinding_ImGui_GetScrollY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetScrollY();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScrollY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetScrollMaxX */
static int tolua_LuaBinding_ImGui_GetScrollMaxX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetScrollMaxX();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScrollMaxX'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetScrollMaxY */
static int tolua_LuaBinding_ImGui_GetScrollMaxY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetScrollMaxY();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetScrollMaxY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetScrollX */
static int tolua_LuaBinding_ImGui_SetScrollX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float scroll_x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetScrollX(scroll_x);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScrollX'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetScrollY */
static int tolua_LuaBinding_ImGui_SetScrollY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float scroll_y =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetScrollY(scroll_y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScrollY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetScrollHereY */
static int tolua_LuaBinding_ImGui_SetScrollHereY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float center_y_ratio =  static_cast< float>(tolua_tonumber(tolua_S,1,0.5f));
  TOLUA_TRY
  {
   ImGui::SetScrollHereY(center_y_ratio);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScrollHereY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetScrollFromPosY */
static int tolua_LuaBinding_ImGui_SetScrollFromPosY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float pos_y =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float center_y_ratio =  static_cast< float>(tolua_tonumber(tolua_S,2,0.5f));
  TOLUA_TRY
  {
   ImGui::SetScrollFromPosY(pos_y,center_y_ratio);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetScrollFromPosY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetKeyboardFocusHere */
static int tolua_LuaBinding_ImGui_SetKeyboardFocusHere00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int offset =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetKeyboardFocusHere(offset);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetKeyboardFocusHere'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopStyleColor */
static int tolua_LuaBinding_ImGui_PopStyleColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int count =  static_cast< int>(tolua_tointeger(tolua_S,1,1));
  TOLUA_TRY
  {
   ImGui::PopStyleColor(count);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopStyleColor'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopStyleVar */
static int tolua_LuaBinding_ImGui_PopStyleVar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int count =  static_cast< int>(tolua_tointeger(tolua_S,1,1));
  TOLUA_TRY
  {
   ImGui::PopStyleVar(count);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopStyleVar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextItemWidth */
static int tolua_LuaBinding_ImGui_SetNextItemWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float item_width =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetNextItemWidth(item_width);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextItemWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PushItemWidth */
static int tolua_LuaBinding_ImGui_PushItemWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float item_width =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::PushItemWidth(item_width);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushItemWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopItemWidth */
static int tolua_LuaBinding_ImGui_PopItemWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::PopItemWidth();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopItemWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::CalcItemWidth */
static int tolua_LuaBinding_ImGui_CalcItemWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::CalcItemWidth();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CalcItemWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PushTextWrapPos */
static int tolua_LuaBinding_ImGui_PushTextWrapPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float wrap_pos_x =  static_cast< float>(tolua_tonumber(tolua_S,1,0.0f));
  TOLUA_TRY
  {
   ImGui::PushTextWrapPos(wrap_pos_x);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushTextWrapPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopTextWrapPos */
static int tolua_LuaBinding_ImGui_PopTextWrapPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::PopTextWrapPos();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopTextWrapPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::PushItemFlag */
static int tolua_LuaBinding_ImGui_PushItemFlag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_istable(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,1));
   Slice* options = Mtolua_new_dim(Slice, tolua_len);
  bool enabled =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,1,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    options[i] = ((Slice)  tolua_tofieldslice(tolua_S,1,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::Binding::PushItemFlag(options,tolua_len,enabled);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(options);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushItemFlag'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopItemFlag */
static int tolua_LuaBinding_ImGui_PopItemFlag00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::PopItemFlag();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopItemFlag'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Separator */
static int tolua_LuaBinding_ImGui_Separator00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::Separator();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Separator'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SeparatorText */
static int tolua_LuaBinding_ImGui_SeparatorText00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring text =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SeparatorText(text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SeparatorText'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SameLine */
static int tolua_LuaBinding_ImGui_SameLine00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float pos_x =  static_cast< float>(tolua_tonumber(tolua_S,1,0.0f));
  float spacing_w =  static_cast< float>(tolua_tonumber(tolua_S,2,-1.0f));
  TOLUA_TRY
  {
   ImGui::SameLine(pos_x,spacing_w);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SameLine'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::NewLine */
static int tolua_LuaBinding_ImGui_NewLine00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::NewLine();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NewLine'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Spacing */
static int tolua_LuaBinding_ImGui_Spacing00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::Spacing();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Spacing'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Dummy */
static int tolua_LuaBinding_ImGui_Dummy00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 size = tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   ImGui::Dummy(size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Dummy'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Indent */
static int tolua_LuaBinding_ImGui_Indent00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float indent_w =  static_cast< float>(tolua_tonumber(tolua_S,1,0.0f));
  TOLUA_TRY
  {
   ImGui::Indent(indent_w);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Indent'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Unindent */
static int tolua_LuaBinding_ImGui_Unindent00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float indent_w =  static_cast< float>(tolua_tonumber(tolua_S,1,0.0f));
  TOLUA_TRY
  {
   ImGui::Unindent(indent_w);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Unindent'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginGroup */
static int tolua_LuaBinding_ImGui_BeginGroup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::BeginGroup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginGroup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndGroup */
static int tolua_LuaBinding_ImGui_EndGroup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndGroup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndGroup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetCursorPos */
static int tolua_LuaBinding_ImGui_GetCursorPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetCursorPos();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetCursorPosX */
static int tolua_LuaBinding_ImGui_GetCursorPosX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetCursorPosX();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorPosX'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetCursorPosY */
static int tolua_LuaBinding_ImGui_GetCursorPosY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetCursorPosY();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorPosY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetCursorPos */
static int tolua_LuaBinding_ImGui_SetCursorPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 local_pos = tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   ImGui::SetCursorPos(local_pos);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCursorPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetCursorPosX */
static int tolua_LuaBinding_ImGui_SetCursorPosX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetCursorPosX(x);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCursorPosX'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetCursorPosY */
static int tolua_LuaBinding_ImGui_SetCursorPosY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float y =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetCursorPosY(y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCursorPosY'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetCursorStartPos */
static int tolua_LuaBinding_ImGui_GetCursorStartPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetCursorStartPos();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorStartPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetCursorScreenPos */
static int tolua_LuaBinding_ImGui_GetCursorScreenPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetCursorScreenPos();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetCursorScreenPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetCursorScreenPos */
static int tolua_LuaBinding_ImGui_SetCursorScreenPos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 pos = tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   ImGui::SetCursorScreenPos(pos);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetCursorScreenPos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::AlignTextToFramePadding */
static int tolua_LuaBinding_ImGui_AlignTextToFramePadding00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::AlignTextToFramePadding();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AlignTextToFramePadding'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetTextLineHeight */
static int tolua_LuaBinding_ImGui_GetTextLineHeight00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetTextLineHeight();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTextLineHeight'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetTextLineHeightWithSpacing */
static int tolua_LuaBinding_ImGui_GetTextLineHeightWithSpacing00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetTextLineHeightWithSpacing();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTextLineHeightWithSpacing'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::NextColumn */
static int tolua_LuaBinding_ImGui_NextColumn00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::NextColumn();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'NextColumn'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetColumnIndex */
static int tolua_LuaBinding_ImGui_GetColumnIndex00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   int tolua_ret = (int)  ImGui::GetColumnIndex();
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColumnIndex'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetColumnOffset */
static int tolua_LuaBinding_ImGui_GetColumnOffset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int column_index =  static_cast< int>(tolua_tointeger(tolua_S,1,-1));
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetColumnOffset(column_index);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColumnOffset'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetColumnOffset */
static int tolua_LuaBinding_ImGui_SetColumnOffset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int column_index =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  float offset_x =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::SetColumnOffset(column_index,offset_x);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetColumnOffset'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetColumnWidth */
static int tolua_LuaBinding_ImGui_GetColumnWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int column_index =  static_cast< int>(tolua_tointeger(tolua_S,1,-1));
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetColumnWidth(column_index);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColumnWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetColumnsCount */
static int tolua_LuaBinding_ImGui_GetColumnsCount00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   int tolua_ret = (int)  ImGui::GetColumnsCount();
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetColumnsCount'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndTable */
static int tolua_LuaBinding_ImGui_EndTable00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndTable();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndTable'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TableNextColumn */
static int tolua_LuaBinding_ImGui_TableNextColumn00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::TableNextColumn();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableNextColumn'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TableSetColumnIndex */
static int tolua_LuaBinding_ImGui_TableSetColumnIndex00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int column_n =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::TableSetColumnIndex(column_n);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableSetColumnIndex'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TableSetupScrollFreeze */
static int tolua_LuaBinding_ImGui_TableSetupScrollFreeze00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int cols =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  int rows =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::TableSetupScrollFreeze(cols,rows);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableSetupScrollFreeze'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TableHeadersRow */
static int tolua_LuaBinding_ImGui_TableHeadersRow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::TableHeadersRow();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableHeadersRow'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TableHeader */
static int tolua_LuaBinding_ImGui_TableHeader00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::TableHeader(label);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TableHeader'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PushID */
static int tolua_LuaBinding_ImGui_PushID00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::PushID(str_id);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushID'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PushID */
static int tolua_LuaBinding_ImGui_PushID01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  int int_id =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::PushID(int_id);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_PushID00(tolua_S);
}
/* function: ImGui::PopID */
static int tolua_LuaBinding_ImGui_PopID00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::PopID();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopID'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetID */
static int tolua_LuaBinding_ImGui_GetID00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   unsigned int tolua_ret = ( unsigned int)  ImGui::GetID(str_id);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetID'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Bullet */
static int tolua_LuaBinding_ImGui_BulletItem00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::Bullet();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BulletItem'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TextLink */
static int tolua_LuaBinding_ImGui_TextLink00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::TextLink(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextLink'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Button */
static int tolua_LuaBinding_ImGui_Button00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Button(label,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Button'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SmallButton */
static int tolua_LuaBinding_ImGui_SmallButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::SmallButton(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SmallButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::InvisibleButton */
static int tolua_LuaBinding_ImGui_InvisibleButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::InvisibleButton(str_id,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'InvisibleButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Checkbox */
static int tolua_LuaBinding_ImGui_Checkbox00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool v =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Checkbox(label,&v);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Checkbox'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::RadioButton */
static int tolua_LuaBinding_ImGui_RadioButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int v_button =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::RadioButton(label,&v,v_button);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)v);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RadioButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::RadioButton */
static int tolua_LuaBinding_ImGui_RadioButton01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool active =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::RadioButton(label,active);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_RadioButton00(tolua_S);
}
/* function: ImGui::PlotLines */
static int tolua_LuaBinding_ImGui_PlotLines00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,1,&tolua_err) ||
  !tolua_isstring(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isusertype(tolua_S,7,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  float* values = Mtolua_new_dim(float, tolua_len);
  int values_offset =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
   _cstring overlay_text =  static_cast<  _cstring>(tolua_tostring(tolua_S,4,nullptr));
  float scale_min =  static_cast< float>(tolua_tonumber(tolua_S,5,FLT_MAX));
  float scale_max =  static_cast< float>(tolua_tonumber(tolua_S,6,FLT_MAX));
  Vec2 graph_size = tolua_tolight(tolua_S,7,Vec2::zero);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isnumberarray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    values[i] = ((float)  tolua_tofieldnumber(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::PlotLines(label,values,tolua_len,values_offset,overlay_text,scale_min,scale_max,graph_size);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(values);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlotLines'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PlotHistogram */
static int tolua_LuaBinding_ImGui_PlotHistogram00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,3,1,&tolua_err) ||
  !tolua_isstring(tolua_S,4,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,1,&tolua_err) ||
  !tolua_isusertype(tolua_S,7,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
  float* values = Mtolua_new_dim(float, tolua_len);
  int values_offset =  static_cast< int>(tolua_tointeger(tolua_S,3,0));
   _cstring overlay_text =  static_cast<  _cstring>(tolua_tostring(tolua_S,4,nullptr));
  float scale_min =  static_cast< float>(tolua_tonumber(tolua_S,5,FLT_MAX));
  float scale_max =  static_cast< float>(tolua_tonumber(tolua_S,6,FLT_MAX));
  Vec2 graph_size = tolua_tolight(tolua_S,7,Vec2::zero);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isnumberarray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    values[i] = ((float)  tolua_tofieldnumber(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   ImGui::PlotHistogram(label,values,tolua_len,values_offset,overlay_text,scale_min,scale_max,graph_size);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(values);
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PlotHistogram'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::ProgressBar */
static int tolua_LuaBinding_ImGui_ProgressBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float fraction =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::ProgressBar(fraction);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ProgressBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::ProgressBar */
static int tolua_LuaBinding_ImGui_ProgressBar01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isstring(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  float fraction =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  Vec2 size_arg = tolua_tolight(tolua_S,2);
   _cstring overlay =  static_cast<  _cstring>(tolua_tostring(tolua_S,3,nullptr));
  TOLUA_TRY
  {
   ImGui::ProgressBar(fraction,size_arg,overlay);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_ProgressBar00(tolua_S);
}
/* function: ImGui::ListBox */
static int tolua_LuaBinding_ImGui_ListBox00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int current_item =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   _cstring* items = Mtolua_new_dim(_cstring, tolua_len);
  int height_in_items =  static_cast< int>(tolua_tointeger(tolua_S,4,-1));
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isstringarray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    items[i] = ((_cstring)  tolua_tofieldstring(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::ListBox(label,&current_item,items,tolua_len,height_in_items);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushinteger(tolua_S,(lua_Integer)current_item);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(items);
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ListBox'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SliderAngle */
static int tolua_LuaBinding_ImGui_SliderAngle00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v_rad =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float v_degrees_min =  static_cast< float>(tolua_tonumber(tolua_S,3,-360.0f));
  float v_degrees_max =  static_cast< float>(tolua_tonumber(tolua_S,4,360.0f));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::SliderAngle(label,&v_rad,v_degrees_min,v_degrees_max);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushnumber(tolua_S,(lua_Number)v_rad);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SliderAngle'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TreeNode */
static int tolua_LuaBinding_ImGui_TreeNode01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::TreeNode(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TreeNode00(tolua_S);
}
/* function: ImGui::TreePush */
static int tolua_LuaBinding_ImGui_TreePush00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,nullptr));
  TOLUA_TRY
  {
   ImGui::TreePush(str_id);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TreePush'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::TreePop */
static int tolua_LuaBinding_ImGui_TreePop00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::TreePop();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TreePop'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetTreeNodeToLabelSpacing */
static int tolua_LuaBinding_ImGui_GetTreeNodeToLabelSpacing00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   float tolua_ret = (float)  ImGui::GetTreeNodeToLabelSpacing();
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetTreeNodeToLabelSpacing'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginListBox */
static int tolua_LuaBinding_ImGui_BeginListBox00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  Vec2 size = tolua_tolight(tolua_S,2,Vec2::zero);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginListBox(label,size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginListBox'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndListBox */
static int tolua_LuaBinding_ImGui_EndListBox00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndListBox();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndListBox'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Value */
static int tolua_LuaBinding_ImGui_Value00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring prefix =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool b =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Value(prefix,b);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Value'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Value */
static int tolua_LuaBinding_ImGui_Value01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring prefix =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int v =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  TOLUA_TRY
  {
   ImGui::Value(prefix,v);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Value00(tolua_S);
}
/* function: ImGui::Value */
static int tolua_LuaBinding_ImGui_Value02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isstring(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring prefix =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  float v =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
   _cstring float_format =  static_cast<  _cstring>(tolua_tostring(tolua_S,3,nullptr));
  TOLUA_TRY
  {
   ImGui::Value(prefix,v,float_format);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_ImGui_Value01(tolua_S);
}
/* function: ImGui::BeginDisabled */
static int tolua_LuaBinding_ImGui_BeginDisabled00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::BeginDisabled();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginDisabled'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndDisabled */
static int tolua_LuaBinding_ImGui_EndDisabled00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndDisabled();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndDisabled'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginTooltip */
static int tolua_LuaBinding_ImGui_BeginTooltip00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginTooltip();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginTooltip'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndTooltip */
static int tolua_LuaBinding_ImGui_EndTooltip00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndTooltip();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndTooltip'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginMainMenuBar */
static int tolua_LuaBinding_ImGui_BeginMainMenuBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginMainMenuBar();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginMainMenuBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndMainMenuBar */
static int tolua_LuaBinding_ImGui_EndMainMenuBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndMainMenuBar();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndMainMenuBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginMenuBar */
static int tolua_LuaBinding_ImGui_BeginMenuBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginMenuBar();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginMenuBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndMenuBar */
static int tolua_LuaBinding_ImGui_EndMenuBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndMenuBar();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndMenuBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginMenu */
static int tolua_LuaBinding_ImGui_BeginMenu00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool enabled =  static_cast< bool>(tolua_toboolean(tolua_S,2,true));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginMenu(label,enabled);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginMenu'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::EndMenu */
static int tolua_LuaBinding_ImGui_EndMenu00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndMenu();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndMenu'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::MenuItem */
static int tolua_LuaBinding_ImGui_MenuItem00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,1,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring shortcut =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,nullptr));
  bool selected =  static_cast< bool>(tolua_toboolean(tolua_S,3,false));
  bool enabled =  static_cast< bool>(tolua_toboolean(tolua_S,4,true));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::MenuItem(label,shortcut,selected,enabled);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MenuItem'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::MenuItem */
static int tolua_LuaBinding_ImGui_MenuItemToggle00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isstring(tolua_S,2,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,4,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
   _cstring shortcut =  static_cast<  _cstring>(tolua_tostring(tolua_S,2,0));
  bool p_selected =  static_cast< bool>(tolua_toboolean(tolua_S,3,0));
  bool enabled =  static_cast< bool>(tolua_toboolean(tolua_S,4,true));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::MenuItem(label,shortcut,&p_selected,enabled);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_selected);
  }
  TOLUA_CATCH
 }
 return 2;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MenuItemToggle'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::OpenPopup */
static int tolua_LuaBinding_ImGui_OpenPopup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::OpenPopup(str_id);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'OpenPopup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::BeginPopup */
static int tolua_LuaBinding_ImGui_BeginPopup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::BeginPopup(str_id);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPopup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginPopupContextItem */
static int tolua_LuaBinding_ImGui_BeginPopupContextItem00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,nullptr));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextItem(str_id);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPopupContextItem'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginPopupContextItem */
static int tolua_LuaBinding_ImGui_BeginPopupContextItem01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* popupFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    popupFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextItem(str_id,popupFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(popupFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupContextItem00(tolua_S);
}
/* function: ImGui::Binding::BeginPopupContextWindow */
static int tolua_LuaBinding_ImGui_BeginPopupContextWindow00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,nullptr));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextWindow(str_id);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPopupContextWindow'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginPopupContextWindow */
static int tolua_LuaBinding_ImGui_BeginPopupContextWindow01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* popupFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    popupFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextWindow(str_id,popupFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(popupFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupContextWindow00(tolua_S);
}
/* function: ImGui::Binding::BeginPopupContextVoid */
static int tolua_LuaBinding_ImGui_BeginPopupContextVoid00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,nullptr));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextVoid(str_id);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPopupContextVoid'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginPopupContextVoid */
static int tolua_LuaBinding_ImGui_BeginPopupContextVoid01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,1,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,nullptr));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* popupFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    popupFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginPopupContextVoid(str_id,popupFlags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(popupFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginPopupContextVoid00(tolua_S);
}
/* function: ImGui::EndPopup */
static int tolua_LuaBinding_ImGui_EndPopup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndPopup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndPopup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::CloseCurrentPopup */
static int tolua_LuaBinding_ImGui_CloseCurrentPopup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::CloseCurrentPopup();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CloseCurrentPopup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PushClipRect */
static int tolua_LuaBinding_ImGui_PushClipRect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 clip_rect_min = tolua_tolight(tolua_S,1);
  Vec2 clip_rect_max = tolua_tolight(tolua_S,2);
  bool intersect_with_current_clip_rect =  static_cast< bool>(tolua_toboolean(tolua_S,3,0));
  TOLUA_TRY
  {
   ImGui::PushClipRect(clip_rect_min,clip_rect_max,intersect_with_current_clip_rect);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PushClipRect'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::PopClipRect */
static int tolua_LuaBinding_ImGui_PopClipRect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::PopClipRect();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PopClipRect'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsItemHovered */
static int tolua_LuaBinding_ImGui_IsItemHovered00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsItemHovered();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsItemHovered'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsItemActive */
static int tolua_LuaBinding_ImGui_IsItemActive00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsItemActive();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsItemActive'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsItemClicked */
static int tolua_LuaBinding_ImGui_IsItemClicked00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int mouse_button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsItemClicked(mouse_button);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsItemClicked'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsItemVisible */
static int tolua_LuaBinding_ImGui_IsItemVisible00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsItemVisible();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsItemVisible'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsAnyItemHovered */
static int tolua_LuaBinding_ImGui_IsAnyItemHovered00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsAnyItemHovered();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAnyItemHovered'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsAnyItemActive */
static int tolua_LuaBinding_ImGui_IsAnyItemActive00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsAnyItemActive();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsAnyItemActive'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetItemRectMin */
static int tolua_LuaBinding_ImGui_GetItemRectMin00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetItemRectMin();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetItemRectMin'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetItemRectMax */
static int tolua_LuaBinding_ImGui_GetItemRectMax00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetItemRectMax();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetItemRectMax'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetItemRectSize */
static int tolua_LuaBinding_ImGui_GetItemRectSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetItemRectSize();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetItemRectSize'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::SetNextItemAllowOverlap */
static int tolua_LuaBinding_ImGui_SetNextItemAllowOverlap00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::SetNextItemAllowOverlap();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetNextItemAllowOverlap'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsWindowHovered */
static int tolua_LuaBinding_ImGui_IsWindowHovered00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsWindowHovered();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsWindowHovered'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsWindowFocused */
static int tolua_LuaBinding_ImGui_IsWindowFocused00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsWindowFocused();
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsWindowFocused'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsRectVisible */
static int tolua_LuaBinding_ImGui_IsRectVisible00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 size = tolua_tolight(tolua_S,1);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsRectVisible(size);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsRectVisible'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsRectVisible */
static int tolua_LuaBinding_ImGui_IsRectVisible01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Vec2 rect_min = tolua_tolight(tolua_S,1);
  Vec2 rect_max = tolua_tolight(tolua_S,2);
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsRectVisible(rect_min,rect_max);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_IsRectVisible00(tolua_S);
}
/* function: ImGui::IsMouseDown */
static int tolua_LuaBinding_ImGui_IsMouseDown00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseDown(button);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseDown'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsMouseClicked */
static int tolua_LuaBinding_ImGui_IsMouseClicked00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  bool repeat =  static_cast< bool>(tolua_toboolean(tolua_S,2,false));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseClicked(button,repeat);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseClicked'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsMouseDoubleClicked */
static int tolua_LuaBinding_ImGui_IsMouseDoubleClicked00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseDoubleClicked(button);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseDoubleClicked'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsMouseReleased */
static int tolua_LuaBinding_ImGui_IsMouseReleased00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseReleased(button);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseReleased'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsMouseHoveringRect */
static int tolua_LuaBinding_ImGui_IsMouseHoveringRect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,2,"Vec2"_slice,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,3,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Vec2 r_min = tolua_tolight(tolua_S,1);
  Vec2 r_max = tolua_tolight(tolua_S,2);
  bool clip =  static_cast< bool>(tolua_toboolean(tolua_S,3,true));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseHoveringRect(r_min,r_max,clip);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseHoveringRect'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::IsMouseDragging */
static int tolua_LuaBinding_ImGui_IsMouseDragging00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  float lock_threshold =  static_cast< float>(tolua_tonumber(tolua_S,2,-1.0f));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::IsMouseDragging(button,lock_threshold);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IsMouseDragging'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetMousePos */
static int tolua_LuaBinding_ImGui_GetMousePos00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetMousePos();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMousePos'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetMousePosOnOpeningCurrentPopup */
static int tolua_LuaBinding_ImGui_GetMousePosOnOpeningCurrentPopup00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetMousePosOnOpeningCurrentPopup();
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMousePosOnOpeningCurrentPopup'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::GetMouseDragDelta */
static int tolua_LuaBinding_ImGui_GetMouseDragDelta00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  float lock_threshold =  static_cast< float>(tolua_tonumber(tolua_S,2,-1.0f));
  TOLUA_TRY
  {
   Vec2 tolua_ret = (Vec2)  ImGui::GetMouseDragDelta(button,lock_threshold);
   {
  tolua_pushlight(tolua_S,tolua_ret);
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetMouseDragDelta'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::ResetMouseDragDelta */
static int tolua_LuaBinding_ImGui_ResetMouseDragDelta00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int button =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::ResetMouseDragDelta(button);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ResetMouseDragDelta'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginTabBar */
static int tolua_LuaBinding_ImGui_BeginTabBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabBar(str_id);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginTabBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginTabBar */
static int tolua_LuaBinding_ImGui_BeginTabBar01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring str_id =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabBar(str_id,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginTabBar00(tolua_S);
}
/* function: ImGui::EndTabBar */
static int tolua_LuaBinding_ImGui_EndTabBar00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndTabBar();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndTabBar'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginTabItem */
static int tolua_LuaBinding_ImGui_BeginTabItem00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabItem(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginTabItem'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::BeginTabItem */
static int tolua_LuaBinding_ImGui_BeginTabItem01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabItem(label,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginTabItem00(tolua_S);
}
/* function: ImGui::Binding::BeginTabItem */
static int tolua_LuaBinding_ImGui_BeginTabItem02(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabItem(label,&p_open);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginTabItem01(tolua_S);
}
/* function: ImGui::Binding::BeginTabItem */
static int tolua_LuaBinding_ImGui_BeginTabItem03(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isboolean(tolua_S,2,0,&tolua_err) ||
  !tolua_istable(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  bool p_open =  static_cast< bool>(tolua_toboolean(tolua_S,2,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,3));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,3,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,3,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::BeginTabItem(label,&p_open,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
   tolua_pushboolean(tolua_S,(bool)p_open);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 2;
tolua_lerror:
 return tolua_LuaBinding_ImGui_BeginTabItem02(tolua_S);
}
/* function: ImGui::EndTabItem */
static int tolua_LuaBinding_ImGui_EndTabItem00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   ImGui::EndTabItem();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'EndTabItem'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TabItemButton */
static int tolua_LuaBinding_ImGui_TabItemButton00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TabItemButton(label);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TabItemButton'.",&tolua_err);
 return 0;
#endif
}
/* function: ImGui::Binding::TabItemButton */
static int tolua_LuaBinding_ImGui_TabItemButton01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_istable(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
 {
   _cstring label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,2));
   Slice* flags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,2,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    flags[i] = ((Slice)  tolua_tofieldslice(tolua_S,2,i+1,0));
   }
  }
  TOLUA_TRY
  {
   bool tolua_ret = (bool)  ImGui::Binding::TabItemButton(label,flags,tolua_len);
   tolua_pushboolean(tolua_S,(bool)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(flags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_ImGui_TabItemButton00(tolua_S);
}
/* function: ImGui::SetTabItemClosed */
static int tolua_LuaBinding_ImGui_SetTabItemClosed00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isstring(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   _cstring tab_or_docked_window_label =  static_cast<  _cstring>(tolua_tostring(tolua_S,1,0));
  TOLUA_TRY
  {
   ImGui::SetTabItemClosed(tab_or_docked_window_label);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SetTabItemClosed'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Save */
static int tolua_LuaBinding_nvg_Save00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::Save();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Save'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Restore */
static int tolua_LuaBinding_nvg_Restore00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::Restore();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Restore'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Reset */
static int tolua_LuaBinding_nvg_Reset00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::Reset();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Reset'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::CreateImage */
static int tolua_LuaBinding_nvg_CreateImage00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int w =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  int h =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::CreateImage(w,h,filename);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateImage'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::CreateImage */
static int tolua_LuaBinding_nvg_CreateImage01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_istable(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  int w =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  int h =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
   Slice filename =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  int tolua_len = static_cast<int>(lua_rawlen(tolua_S,4));
   Slice* imageFlags = Mtolua_new_dim(Slice, tolua_len);
  {
#ifndef TOLUA_RELEASE
   if (!tolua_isslicearray(tolua_S,4,tolua_len,0,&tolua_err)) goto tolua_lerror;
   else
#endif
   {
 for (int i=0;i<(int)tolua_len;i++)    imageFlags[i] = ((Slice)  tolua_tofieldslice(tolua_S,4,i+1,0));
   }
  }
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::CreateImage(w,h,filename,imageFlags,tolua_len);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
  Mtolua_delete_dim(imageFlags);
 }
 return 1;
tolua_lerror:
 return tolua_LuaBinding_nvg_CreateImage00(tolua_S);
}
/* function: nvg::CreateFont */
static int tolua_LuaBinding_nvg_CreateFont00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::CreateFont(name);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'CreateFont'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextBounds */
static int tolua_LuaBinding_nvg_TextBounds00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,4,"Rect"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  Rect bounds = * static_cast< Rect*>(tolua_tousertype(tolua_S,4,0));
  TOLUA_TRY
  {
   float tolua_ret = (float)  nvg::TextBounds(x,y,text,bounds);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextBounds'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextBoxBounds */
static int tolua_LuaBinding_nvg_TextBoxBounds00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float breakRowWidth =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  TOLUA_TRY
  {
   Rect tolua_ret = (Rect)  nvg::TextBoxBounds(x,y,breakRowWidth,text);
   {
 void* tolua_obj = Mtolua_new((Rect)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Rect>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextBoxBounds'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Text */
static int tolua_LuaBinding_nvg_Text00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isslice(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,3,0));
  TOLUA_TRY
  {
   float tolua_ret = (float)  nvg::Text(x,y,text);
   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Text'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextBox */
static int tolua_LuaBinding_nvg_TextBox00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isslice(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float breakRowWidth =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
   Slice text =  static_cast<  Slice>(tolua_toslice(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::TextBox(x,y,breakRowWidth,text);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextBox'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::StrokeColor */
static int tolua_LuaBinding_nvg_StrokeColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  uint32_t color =  static_cast< uint32_t>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::StrokeColor(color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StrokeColor'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::StrokeColor */
static int tolua_LuaBinding_nvg_StrokeColor01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::StrokeColor(color);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_nvg_StrokeColor00(tolua_S);
}
/* function: nvg::StrokePaint */
static int tolua_LuaBinding_nvg_StrokePaint00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"NVGpaint"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  NVGpaint paint = * static_cast< NVGpaint*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::StrokePaint(paint);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StrokePaint'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FillColor */
static int tolua_LuaBinding_nvg_FillColor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  uint32_t color =  static_cast< uint32_t>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FillColor(color);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FillColor'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FillColor */
static int tolua_LuaBinding_nvg_FillColor01(lua_State* tolua_S){
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
 {
  Color color = * static_cast< Color*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FillColor(color);
  }
  TOLUA_CATCH
 }
 return 0;
tolua_lerror:
 return tolua_LuaBinding_nvg_FillColor00(tolua_S);
}
/* function: nvg::FillPaint */
static int tolua_LuaBinding_nvg_FillPaint00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isusertype(tolua_S,1,"NVGpaint"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  NVGpaint paint = * static_cast< NVGpaint*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FillPaint(paint);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FillPaint'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::MiterLimit */
static int tolua_LuaBinding_nvg_MiterLimit00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float limit =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::MiterLimit(limit);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MiterLimit'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::StrokeWidth */
static int tolua_LuaBinding_nvg_StrokeWidth00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float size =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::StrokeWidth(size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'StrokeWidth'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::LineCap */
static int tolua_LuaBinding_nvg_LineCap00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice cap =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::LineCap(cap);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LineCap'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::LineJoin */
static int tolua_LuaBinding_nvg_LineJoin00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice join =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::LineJoin(join);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LineJoin'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::GlobalAlpha */
static int tolua_LuaBinding_nvg_GlobalAlpha00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float alpha =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::GlobalAlpha(alpha);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GlobalAlpha'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ResetTransform */
static int tolua_LuaBinding_nvg_ResetTransform00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::ResetTransform();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ResetTransform'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ApplyTransform */
static int tolua_LuaBinding_nvg_ApplyTransform00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"Node"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  Node* node =  static_cast< Node*>(tolua_tousertype(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::ApplyTransform(node);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ApplyTransform'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Translate */
static int tolua_LuaBinding_nvg_Translate00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   nvg::Translate(x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Translate'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Rotate */
static int tolua_LuaBinding_nvg_Rotate00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::Rotate(angle);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rotate'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::SkewX */
static int tolua_LuaBinding_nvg_SkewX00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::SkewX(angle);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SkewX'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::SkewY */
static int tolua_LuaBinding_nvg_SkewY00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::SkewY(angle);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'SkewY'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Scale */
static int tolua_LuaBinding_nvg_Scale00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   nvg::Scale(x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Scale'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ImageSize */
static int tolua_LuaBinding_nvg_ImageSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int image =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   Size tolua_ret = (Size)  nvg::ImageSize(image);
   {
 void* tolua_obj = Mtolua_new((Size)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<Size>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ImageSize'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::DeleteImage */
static int tolua_LuaBinding_nvg_DeleteImage00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int image =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::DeleteImage(image);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DeleteImage'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::LinearGradient */
static int tolua_LuaBinding_nvg_LinearGradient00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Color"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float sx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float sy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float ex =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float ey =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  Color icol = * static_cast< Color*>(tolua_tousertype(tolua_S,5,0));
  Color ocol = * static_cast< Color*>(tolua_tousertype(tolua_S,6,0));
  TOLUA_TRY
  {
   NVGpaint tolua_ret = (NVGpaint)  nvg::LinearGradient(sx,sy,ex,ey,icol,ocol);
   {
 void* tolua_obj = Mtolua_new((NVGpaint)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<NVGpaint>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LinearGradient'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::BoxGradient */
static int tolua_LuaBinding_nvg_BoxGradient00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,7,"Color"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,8,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float r =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float f =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  Color icol = * static_cast< Color*>(tolua_tousertype(tolua_S,7,0));
  Color ocol = * static_cast< Color*>(tolua_tousertype(tolua_S,8,0));
  TOLUA_TRY
  {
   NVGpaint tolua_ret = (NVGpaint)  nvg::BoxGradient(x,y,w,h,r,f,icol,ocol);
   {
 void* tolua_obj = Mtolua_new((NVGpaint)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<NVGpaint>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BoxGradient'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::RadialGradient */
static int tolua_LuaBinding_nvg_RadialGradient00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,5,"Color"_slice,0,&tolua_err) ||
  !tolua_isusertype(tolua_S,6,"Color"_slice,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float cx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float cy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float inr =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float outr =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  Color icol = * static_cast< Color*>(tolua_tousertype(tolua_S,5,0));
  Color ocol = * static_cast< Color*>(tolua_tousertype(tolua_S,6,0));
  TOLUA_TRY
  {
   NVGpaint tolua_ret = (NVGpaint)  nvg::RadialGradient(cx,cy,inr,outr,icol,ocol);
   {
 void* tolua_obj = Mtolua_new((NVGpaint)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<NVGpaint>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RadialGradient'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ImagePattern */
static int tolua_LuaBinding_nvg_ImagePattern00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,8,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float ox =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float oy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float ex =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float ey =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float angle =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  int image =  static_cast< int>(tolua_tointeger(tolua_S,6,0));
  float alpha =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  TOLUA_TRY
  {
   NVGpaint tolua_ret = (NVGpaint)  nvg::ImagePattern(ox,oy,ex,ey,angle,image,alpha);
   {
 void* tolua_obj = Mtolua_new((NVGpaint)(tolua_ret));
  tolua_pushusertype(tolua_S,tolua_obj,LuaType<NVGpaint>());
   }
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ImagePattern'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Scissor */
static int tolua_LuaBinding_nvg_Scissor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::Scissor(x,y,w,h);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Scissor'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::IntersectScissor */
static int tolua_LuaBinding_nvg_IntersectScissor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::IntersectScissor(x,y,w,h);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'IntersectScissor'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ResetScissor */
static int tolua_LuaBinding_nvg_ResetScissor00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::ResetScissor();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ResetScissor'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::BeginPath */
static int tolua_LuaBinding_nvg_BeginPath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::BeginPath();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BeginPath'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::MoveTo */
static int tolua_LuaBinding_nvg_MoveTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   nvg::MoveTo(x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'MoveTo'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::LineTo */
static int tolua_LuaBinding_nvg_LineTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  TOLUA_TRY
  {
   nvg::LineTo(x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'LineTo'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::BezierTo */
static int tolua_LuaBinding_nvg_BezierTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float c1x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float c1y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float c2x =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float c2y =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float x =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  TOLUA_TRY
  {
   nvg::BezierTo(c1x,c1y,c2x,c2y,x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'BezierTo'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::QuadTo */
static int tolua_LuaBinding_nvg_QuadTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float cx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float cy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float x =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::QuadTo(cx,cy,x,y);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'QuadTo'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ArcTo */
static int tolua_LuaBinding_nvg_ArcTo00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x1 =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y1 =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float x2 =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float y2 =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float radius =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  TOLUA_TRY
  {
   nvg::ArcTo(x1,y1,x2,y2,radius);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ArcTo'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::ClosePath */
static int tolua_LuaBinding_nvg_ClosePath00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::ClosePath();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'ClosePath'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::PathWinding */
static int tolua_LuaBinding_nvg_PathWinding00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice dir =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::PathWinding(dir);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'PathWinding'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Arc */
static int tolua_LuaBinding_nvg_Arc00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isslice(tolua_S,6,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,7,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float cx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float cy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float r =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float a0 =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float a1 =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
   Slice dir =  static_cast<  Slice>(tolua_toslice(tolua_S,6,0));
  TOLUA_TRY
  {
   nvg::Arc(cx,cy,r,a0,a1,dir);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Arc'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Rectangle */
static int tolua_LuaBinding_nvg_Rect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::Rectangle(x,y,w,h);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Rect'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::RoundedRect */
static int tolua_LuaBinding_nvg_RoundedRect00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float r =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  TOLUA_TRY
  {
   nvg::RoundedRect(x,y,w,h,r);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RoundedRect'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::RoundedRectVarying */
static int tolua_LuaBinding_nvg_RoundedRectVarying00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,7,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,8,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,9,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float x =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float y =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float w =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float h =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  float radTopLeft =  static_cast< float>(tolua_tonumber(tolua_S,5,0));
  float radTopRight =  static_cast< float>(tolua_tonumber(tolua_S,6,0));
  float radBottomRight =  static_cast< float>(tolua_tonumber(tolua_S,7,0));
  float radBottomLeft =  static_cast< float>(tolua_tonumber(tolua_S,8,0));
  TOLUA_TRY
  {
   nvg::RoundedRectVarying(x,y,w,h,radTopLeft,radTopRight,radBottomRight,radBottomLeft);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'RoundedRectVarying'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Ellipse */
static int tolua_LuaBinding_nvg_Ellipse00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,5,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float cx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float cy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float rx =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float ry =  static_cast< float>(tolua_tonumber(tolua_S,4,0));
  TOLUA_TRY
  {
   nvg::Ellipse(cx,cy,rx,ry);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Ellipse'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Circle */
static int tolua_LuaBinding_nvg_Circle00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,4,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float cx =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  float cy =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float r =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  TOLUA_TRY
  {
   nvg::Circle(cx,cy,r);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Circle'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Fill */
static int tolua_LuaBinding_nvg_Fill00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::Fill();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Fill'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::Stroke */
static int tolua_LuaBinding_nvg_Stroke00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::Stroke();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'Stroke'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FindFont */
static int tolua_LuaBinding_nvg_FindFont00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice name =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::FindFont(name);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FindFont'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::AddFallbackFontId */
static int tolua_LuaBinding_nvg_AddFallbackFontId00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isinteger(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int baseFont =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  int fallbackFont =  static_cast< int>(tolua_tointeger(tolua_S,2,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::AddFallbackFontId(baseFont,fallbackFont);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddFallbackFontId'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::AddFallbackFont */
static int tolua_LuaBinding_nvg_AddFallbackFont00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice baseFont =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
   Slice fallbackFont =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   int tolua_ret = (int)  nvg::AddFallbackFont(baseFont,fallbackFont);
   tolua_pushinteger(tolua_S,(lua_Integer)tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'AddFallbackFont'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FontSize */
static int tolua_LuaBinding_nvg_FontSize00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float size =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FontSize(size);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FontSize'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FontBlur */
static int tolua_LuaBinding_nvg_FontBlur00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float blur =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FontBlur(blur);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FontBlur'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextLetterSpacing */
static int tolua_LuaBinding_nvg_TextLetterSpacing00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float spacing =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::TextLetterSpacing(spacing);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextLetterSpacing'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextLineHeight */
static int tolua_LuaBinding_nvg_TextLineHeight00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float lineHeight =  static_cast< float>(tolua_tonumber(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::TextLineHeight(lineHeight);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextLineHeight'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::TextAlign */
static int tolua_LuaBinding_nvg_TextAlign00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isslice(tolua_S,2,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice hAlign =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
   Slice vAlign =  static_cast<  Slice>(tolua_toslice(tolua_S,2,0));
  TOLUA_TRY
  {
   nvg::TextAlign(hAlign,vAlign);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'TextAlign'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FontFaceId */
static int tolua_LuaBinding_nvg_FontFaceId00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isinteger(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  int font =  static_cast< int>(tolua_tointeger(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FontFaceId(font);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FontFaceId'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::FontFace */
static int tolua_LuaBinding_nvg_FontFace00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isslice(tolua_S,1,0,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
   Slice font =  static_cast<  Slice>(tolua_toslice(tolua_S,1,0));
  TOLUA_TRY
  {
   nvg::FontFace(font);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'FontFace'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::DoraSSR */
static int tolua_LuaBinding_nvg_DoraSSR00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnoobj(tolua_S,1,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  TOLUA_TRY
  {
   nvg::DoraSSR();
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'DoraSSR'.",&tolua_err);
 return 0;
#endif
}
/* function: nvg::GetDoraSSR */
static int tolua_LuaBinding_nvg_GetDoraSSR00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,1,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,2,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float scale =  static_cast< float>(tolua_tonumber(tolua_S,1,1.0f));
  TOLUA_TRY
  {
   Texture2D* tolua_ret = (Texture2D*)  nvg::GetDoraSSR(scale);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'GetDoraSSR'.",&tolua_err);
 return 0;
#endif
}
/* get function: surface of class  VGNode */
static int tolua_get_VGNode_surface_ptr(lua_State* tolua_S){
  VGNode* self = (VGNode*)  tolua_tousertype(tolua_S,1,0);
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable 'surface'",NULL);
#endif
  tolua_pushobject(tolua_S,self->getSurface());
 return 1;
}
/* method: render of class  VGNode */
static int tolua_LuaBinding_VGNode_render00(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isobject(tolua_S,1,"VGNode"_slice,0,&tolua_err) ||
  !tolua_isfunction(tolua_S,2,&tolua_err) ||
  !tolua_isnoobj(tolua_S,3,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  VGNode* self = (VGNode*)  tolua_tousertype(tolua_S,1,0);
  LuaFunction<void> func(tolua_ref_function(tolua_S,2));
#ifndef TOLUA_RELEASE
  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'VGNode.render'", NULL);
#endif
  TOLUA_TRY
  {
   self->render(func);
  }
  TOLUA_CATCH
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'VGNode.render'.",&tolua_err);
 return 0;
#endif
}
/* method: new_local of class  VGNode */
static int tolua_LuaBinding_VGNode_new00_local(lua_State* tolua_S){
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
  !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
  !tolua_isnumber(tolua_S,4,1,&tolua_err) ||
  !tolua_isinteger(tolua_S,5,1,&tolua_err) ||
  !tolua_isnoobj(tolua_S,6,&tolua_err)
 ) goto tolua_lerror;
 else
#endif
 {
  float width =  static_cast< float>(tolua_tonumber(tolua_S,2,0));
  float height =  static_cast< float>(tolua_tonumber(tolua_S,3,0));
  float scale =  static_cast< float>(tolua_tonumber(tolua_S,4,1.0f));
  int edgeAA =  static_cast< int>(tolua_tointeger(tolua_S,5,1));
  TOLUA_TRY
  {
   VGNode* tolua_ret = (VGNode*)  VGNode::create(width,height,scale,edgeAA);
  tolua_pushobject(tolua_S,tolua_ret);
  }
  TOLUA_CATCH
 }
 return 1;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function 'VGNode.new'.",&tolua_err);
 return 0;
#endif
}

/* Open function */
TOLUA_API int tolua_LuaBinding_open (lua_State* tolua_S){
 tolua_open(tolua_S);
 tolua_reg_types(tolua_S);
 tolua_module(tolua_S,NULL,0);
 tolua_beginmodule(tolua_S,NULL);
  tolua_cclass(tolua_S,"Profiler","Profiler","",NULL);
  tolua_beginmodule(tolua_S,"Profiler");
   tolua_variable(tolua_S,"EventName",tolua_get_Profiler_EventName,NULL);
   tolua_variable(tolua_S,"level",tolua_get_Profiler_level,tolua_set_Profiler_level);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Color3","Color3","",tolua_collect_Color3);
  tolua_beginmodule(tolua_S,"Color3");
   tolua_variable(tolua_S,"r",tolua_get_Color3_r,tolua_set_Color3_r);
   tolua_variable(tolua_S,"g",tolua_get_Color3_g,tolua_set_Color3_g);
   tolua_variable(tolua_S,"b",tolua_get_Color3_b,tolua_set_Color3_b);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Color3_new00_local);
   tolua_function(tolua_S,"toRGB",tolua_LuaBinding_Color3_toRGB00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Color3_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Color","Color","",tolua_collect_Color);
  tolua_beginmodule(tolua_S,"Color");
   tolua_variable(tolua_S,"r",tolua_get_Color_r,tolua_set_Color_r);
   tolua_variable(tolua_S,"g",tolua_get_Color_g,tolua_set_Color_g);
   tolua_variable(tolua_S,"b",tolua_get_Color_b,tolua_set_Color_b);
   tolua_variable(tolua_S,"a",tolua_get_Color_a,tolua_set_Color_a);
   tolua_variable(tolua_S,"opacity",tolua_get_Color_opacity,tolua_set_Color_opacity);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Color_new01_local);
   tolua_function(tolua_S,"toColor3",tolua_LuaBinding_Color_toColor300);
   tolua_function(tolua_S,"toARGB",tolua_LuaBinding_Color_toARGB00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Color_new03_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Vec2","Vec2","",tolua_collect_Vec2);
  tolua_beginmodule(tolua_S,"Vec2");
   tolua_variable(tolua_S,"x",tolua_get_Vec2_x,NULL);
   tolua_variable(tolua_S,"y",tolua_get_Vec2_y,NULL);
   tolua_variable(tolua_S,"length",tolua_get_Vec2_length,NULL);
   tolua_variable(tolua_S,"lengthSquared",tolua_get_Vec2_lengthSquared,NULL);
   tolua_variable(tolua_S,"angle",tolua_get_Vec2_angle,NULL);
   tolua_call(tolua_S,MT_ADD,tolua_LuaBinding_Vec2__add00);
   tolua_call(tolua_S,MT_SUB,tolua_LuaBinding_Vec2__sub00);
   tolua_call(tolua_S,MT_MUL,tolua_LuaBinding_Vec2__mul00);
   tolua_call(tolua_S,MT_MUL,tolua_LuaBinding_Vec2__mul01);
   tolua_call(tolua_S,MT_MUL,tolua_LuaBinding_Vec2__mul02);
   tolua_call(tolua_S,MT_DIV,tolua_LuaBinding_Vec2__div00);
   tolua_function(tolua_S,"distance",tolua_LuaBinding_Vec2_distance00);
   tolua_function(tolua_S,"distanceSquared",tolua_LuaBinding_Vec2_distanceSquared00);
   tolua_function(tolua_S,"normalize",tolua_LuaBinding_Vec2_normalize00);
   tolua_function(tolua_S,"perp",tolua_LuaBinding_Vec2_perp00);
   tolua_function(tolua_S,"clamp",tolua_LuaBinding_Vec2_clamp00);
   tolua_function(tolua_S,"dot",tolua_LuaBinding_Vec2_dot00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Vec2_new01_local);
   tolua_variable(tolua_S,"zero",tolua_get_Vec2_zero,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Size","Size","",tolua_collect_Size);
  tolua_beginmodule(tolua_S,"Size");
   tolua_variable(tolua_S,"width",tolua_get_Size_width,tolua_set_Size_width);
   tolua_variable(tolua_S,"height",tolua_get_Size_height,tolua_set_Size_height);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Size_new00_local);
   tolua_function(tolua_S,"set",tolua_LuaBinding_Size_set00);
   tolua_call(tolua_S,MT_EQ,tolua_LuaBinding_Size__eq00);
   tolua_call(tolua_S,MT_MUL,tolua_LuaBinding_Size__mul00);
   tolua_variable(tolua_S,"zero",tolua_get_Size_zero,NULL);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Size_new02_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Rect","Rect","",tolua_collect_Rect);
  tolua_beginmodule(tolua_S,"Rect");
   tolua_variable(tolua_S,"origin",tolua_get_Rect_origin,tolua_set_Rect_origin);
   tolua_variable(tolua_S,"size",tolua_get_Rect_size,tolua_set_Rect_size);
   tolua_variable(tolua_S,"x",tolua_get_Rect_x,tolua_set_Rect_x);
   tolua_variable(tolua_S,"y",tolua_get_Rect_y,tolua_set_Rect_y);
   tolua_variable(tolua_S,"width",tolua_get_Rect_width,tolua_set_Rect_width);
   tolua_variable(tolua_S,"height",tolua_get_Rect_height,tolua_set_Rect_height);
   tolua_variable(tolua_S,"left",tolua_get_Rect_left,tolua_set_Rect_left);
   tolua_variable(tolua_S,"right",tolua_get_Rect_right,tolua_set_Rect_right);
   tolua_variable(tolua_S,"centerX",tolua_get_Rect_centerX,tolua_set_Rect_centerX);
   tolua_variable(tolua_S,"centerY",tolua_get_Rect_centerY,tolua_set_Rect_centerY);
   tolua_variable(tolua_S,"bottom",tolua_get_Rect_bottom,tolua_set_Rect_bottom);
   tolua_variable(tolua_S,"top",tolua_get_Rect_top,tolua_set_Rect_top);
   tolua_variable(tolua_S,"lowerBound",tolua_get_Rect_lowerBound,tolua_set_Rect_lowerBound);
   tolua_variable(tolua_S,"upperBound",tolua_get_Rect_upperBound,tolua_set_Rect_upperBound);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Rect_new03_local);
   tolua_call(tolua_S,MT_EQ,tolua_LuaBinding_Rect__eq00);
   tolua_function(tolua_S,"set",tolua_LuaBinding_Rect_set00);
   tolua_function(tolua_S,"containsPoint",tolua_LuaBinding_Rect_containsPoint00);
   tolua_function(tolua_S,"intersectsRect",tolua_LuaBinding_Rect_intersectsRect00);
   tolua_variable(tolua_S,"zero",tolua_get_Rect_zero,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Application","Application","",NULL);
  tolua_beginmodule(tolua_S,"Application");
   tolua_variable(tolua_S,"frame",tolua_get_Application_frame,NULL);
   tolua_variable(tolua_S,"bufferSize",tolua_get_Application_bufferSize,NULL);
   tolua_variable(tolua_S,"visualSize",tolua_get_Application_visualSize,NULL);
   tolua_variable(tolua_S,"devicePixelRatio",tolua_get_Application_devicePixelRatio,NULL);
   tolua_variable(tolua_S,"platform",tolua_get_Application_platform,NULL);
   tolua_variable(tolua_S,"version",tolua_get_Application_version,NULL);
   tolua_variable(tolua_S,"deps",tolua_get_Application_deps,NULL);
   tolua_variable(tolua_S,"deltaTime",tolua_get_Application_deltaTime,NULL);
   tolua_variable(tolua_S,"elapsedTime",tolua_get_Application_elapsedTime,NULL);
   tolua_variable(tolua_S,"totalTime",tolua_get_Application_totalTime,NULL);
   tolua_variable(tolua_S,"runningTime",tolua_get_Application_runningTime,NULL);
   tolua_variable(tolua_S,"rand",tolua_get_Application_rand,NULL);
   tolua_variable(tolua_S,"maxFPS",tolua_get_Application_maxFPS,NULL);
   tolua_variable(tolua_S,"debugging",tolua_get_Application_debugging,NULL);
   tolua_variable(tolua_S,"locale",tolua_get_Application_locale,tolua_set_Application_locale);
   tolua_variable(tolua_S,"themeColor",tolua_get_Application_themeColor,tolua_set_Application_themeColor);
   tolua_variable(tolua_S,"seed",tolua_get_Application_unsigned_seed,tolua_set_Application_unsigned_seed);
   tolua_variable(tolua_S,"targetFPS",tolua_get_Application_targetFPS,tolua_set_Application_targetFPS);
   tolua_variable(tolua_S,"winSize",tolua_get_Application_winSize,tolua_set_Application_winSize);
   tolua_variable(tolua_S,"winPosition",tolua_get_Application_winPosition,tolua_set_Application_winPosition);
   tolua_variable(tolua_S,"fpsLimited",tolua_get_Application_fpsLimited,tolua_set_Application_fpsLimited);
   tolua_variable(tolua_S,"idled",tolua_get_Application_idled,tolua_set_Application_idled);
   tolua_variable(tolua_S,"fullScreen",tolua_get_Application_fullScreen,tolua_set_Application_fullScreen);
   tolua_variable(tolua_S,"alwaysOnTop",tolua_get_Application_alwaysOnTop,tolua_set_Application_alwaysOnTop);
   tolua_variable(tolua_S,"devMode",tolua_get_Application_devMode,tolua_set_Application_devMode);
   tolua_function(tolua_S,"openURL",tolua_LuaBinding_Application_openURL00);
   tolua_function(tolua_S,"install",tolua_LuaBinding_Application_install00);
   tolua_function(tolua_S,"saveLog",tolua_LuaBinding_Application_saveLog00);
   tolua_function(tolua_S,"openFileDialog",tolua_LuaBinding_Application_openFileDialog00);
   tolua_function(tolua_S,"shutdown",tolua_LuaBinding_Application_shutdown00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Application_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Object","Object","",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Object");
   tolua_variable(tolua_S,"id",tolua_get_Object_id,NULL);
   tolua_variable(tolua_S,"ref",tolua_get_Object_ref,NULL);
   tolua_variable(tolua_S,"count",tolua_get_Object_count,NULL);
   tolua_variable(tolua_S,"maxCount",tolua_get_Object_maxCount,NULL);
   tolua_variable(tolua_S,"luaRefCount",tolua_get_Object_luaRefCount,NULL);
   tolua_variable(tolua_S,"maxLuaRefCount",tolua_get_Object_maxLuaRefCount,NULL);
   tolua_variable(tolua_S,"callRefCount",tolua_get_Object_callRefCount,NULL);
   tolua_variable(tolua_S,"maxCallRefCount",tolua_get_Object_maxCallRefCount,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Array","Array","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Array");
   tolua_variable(tolua_S,"count",tolua_get_Array_count,NULL);
   tolua_variable(tolua_S,"empty",tolua_get_Array_empty,NULL);
   tolua_function(tolua_S,"addRange",tolua_LuaBinding_Array_addRange00);
   tolua_function(tolua_S,"removeFrom",tolua_LuaBinding_Array_removeFrom00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Array_clear00);
   tolua_function(tolua_S,"reverse",tolua_LuaBinding_Array_reverse00);
   tolua_function(tolua_S,"shrink",tolua_LuaBinding_Array_shrink00);
   tolua_function(tolua_S,"swap",tolua_LuaBinding_Array_swap00);
   tolua_function(tolua_S,"removeAt",tolua_LuaBinding_Array_removeAt00);
   tolua_function(tolua_S,"fastRemoveAt",tolua_LuaBinding_Array_fastRemoveAt00);
   tolua_function(tolua_S,"each",tolua_LuaBinding_Array_each00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Dictionary","Dictionary","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Dictionary");
   tolua_variable(tolua_S,"count",tolua_get_Dictionary_count,NULL);
   tolua_function(tolua_S,"each",tolua_LuaBinding_Dictionary_each00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Dictionary_clear00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Dictionary_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Entity","Entity","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Entity");
   tolua_variable(tolua_S,"count",tolua_get_Entity_count,NULL);
   tolua_variable(tolua_S,"index",tolua_get_Entity_index,NULL);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Entity_clear00);
   tolua_function(tolua_S,"getComIndex",tolua_LuaBinding_Entity_getComIndex00);
   tolua_function(tolua_S,"tryGetComIndex",tolua_LuaBinding_Entity_tryGetComIndex00);
   tolua_function(tolua_S,"destroy",tolua_LuaBinding_Entity_destroy00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"EntityGroup","Group","",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Group");
   tolua_variable(tolua_S,"count",tolua_get_EntityGroup_count,NULL);
   tolua_variable(tolua_S,"first",tolua_get_EntityGroup_first_ptr,NULL);
   tolua_function(tolua_S,"each",tolua_LuaBinding_Group_each00);
   tolua_function(tolua_S,"find",tolua_LuaBinding_Group_find00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Group_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"EntityObserver","Observer","",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Observer");
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Observer_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Path","Path","",NULL);
  tolua_beginmodule(tolua_S,"Path");
   tolua_function(tolua_S,"getExt",tolua_LuaBinding_Path_getExt00);
   tolua_function(tolua_S,"getPath",tolua_LuaBinding_Path_getPath00);
   tolua_function(tolua_S,"getName",tolua_LuaBinding_Path_getName00);
   tolua_function(tolua_S,"getFilename",tolua_LuaBinding_Path_getFilename00);
   tolua_function(tolua_S,"getRelative",tolua_LuaBinding_Path_getRelative00);
   tolua_function(tolua_S,"replaceExt",tolua_LuaBinding_Path_replaceExt00);
   tolua_function(tolua_S,"replaceFilename",tolua_LuaBinding_Path_replaceFilename00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Content","Content","",NULL);
  tolua_beginmodule(tolua_S,"Content");
   tolua_variable(tolua_S,"assetPath",tolua_get_Content_assetPath,tolua_set_Content_assetPath);
   tolua_variable(tolua_S,"writablePath",tolua_get_Content_writablePath,tolua_set_Content_writablePath);
   tolua_variable(tolua_S,"appPath",tolua_get_Content_appPath,NULL);
   tolua_function(tolua_S,"save",tolua_LuaBinding_Content_save00);
   tolua_function(tolua_S,"exist",tolua_LuaBinding_Content_exist00);
   tolua_function(tolua_S,"mkdir",tolua_LuaBinding_Content_mkdir00);
   tolua_function(tolua_S,"isdir",tolua_LuaBinding_Content_isdir00);
   tolua_function(tolua_S,"isAbsolutePath",tolua_LuaBinding_Content_isAbsolutePath00);
   tolua_function(tolua_S,"copy",tolua_LuaBinding_Content_copy00);
   tolua_function(tolua_S,"move",tolua_LuaBinding_Content_move00);
   tolua_function(tolua_S,"remove",tolua_LuaBinding_Content_remove00);
   tolua_function(tolua_S,"getFullPath",tolua_LuaBinding_Content_getFullPath00);
   tolua_function(tolua_S,"insertSearchPath",tolua_LuaBinding_Content_insertSearchPath00);
   tolua_function(tolua_S,"addSearchPath",tolua_LuaBinding_Content_addSearchPath00);
   tolua_function(tolua_S,"removeSearchPath",tolua_LuaBinding_Content_removeSearchPath00);
   tolua_function(tolua_S,"loadAsync",tolua_LuaBinding_Content_loadAsync00);
   tolua_function(tolua_S,"saveAsync",tolua_LuaBinding_Content_saveAsync00);
   tolua_function(tolua_S,"copyAsync",tolua_LuaBinding_Content_copyAsync00);
   tolua_function(tolua_S,"zipAsync",tolua_LuaBinding_Content_zipAsync00);
   tolua_function(tolua_S,"unzipAsync",tolua_LuaBinding_Content_unzipAsync00);
   tolua_function(tolua_S,"clearPathCache",tolua_LuaBinding_Content_clearPathCache00);
   tolua_function(tolua_S,"getDirs",tolua_LuaBinding_Content_getDirs00);
   tolua_function(tolua_S,"getFiles",tolua_LuaBinding_Content_getFiles00);
   tolua_function(tolua_S,"getAllFiles",tolua_LuaBinding_Content_getAllFiles00);
   tolua_function(tolua_S,"load",tolua_LuaBinding_Content_load00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Content_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Listener","GSlot","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"GSlot");
   tolua_variable(tolua_S,"name",tolua_get_Listener_name,NULL);
   tolua_variable(tolua_S,"enabled",tolua_get_Listener_enabled,tolua_set_Listener_enabled);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Scheduler","Scheduler","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Scheduler");
   tolua_variable(tolua_S,"timeScale",tolua_get_Scheduler_timeScale,tolua_set_Scheduler_timeScale);
   tolua_variable(tolua_S,"fixedFPS",tolua_get_Scheduler_fixedFPS,tolua_set_Scheduler_fixedFPS);
   tolua_function(tolua_S,"schedule",tolua_LuaBinding_Scheduler_schedule00);
   tolua_function(tolua_S,"update",tolua_LuaBinding_Scheduler_update00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Scheduler_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Camera","Camera","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Camera");
   tolua_variable(tolua_S,"name",tolua_get_Camera_name,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Camera2D","Camera2D","Camera",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Camera2D");
   tolua_variable(tolua_S,"rotation",tolua_get_Camera2D_rotation,tolua_set_Camera2D_rotation);
   tolua_variable(tolua_S,"zoom",tolua_get_Camera2D_zoom,tolua_set_Camera2D_zoom);
   tolua_variable(tolua_S,"position",tolua_get_Camera2D_position,tolua_set_Camera2D_position);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Camera2D_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"CameraOtho","CameraOtho","Camera",NULL);
  tolua_beginmodule(tolua_S,"CameraOtho");
   tolua_variable(tolua_S,"position",tolua_get_CameraOtho_position,tolua_set_CameraOtho_position);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_CameraOtho_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Director","Director","",NULL);
  tolua_beginmodule(tolua_S,"Director");
   tolua_variable(tolua_S,"clearColor",tolua_get_Director_clearColor,tolua_set_Director_clearColor);
   tolua_variable(tolua_S,"scheduler",tolua_get_Director_scheduler_ptr,tolua_set_Director_scheduler_ptr);
   tolua_variable(tolua_S,"ui",tolua_get_Director_ui_ptr,NULL);
   tolua_variable(tolua_S,"ui3D",tolua_get_Director_ui3D_ptr,NULL);
   tolua_variable(tolua_S,"entry",tolua_get_Director_entry_ptr,NULL);
   tolua_variable(tolua_S,"postNode",tolua_get_Director_postNode_ptr,NULL);
   tolua_variable(tolua_S,"systemScheduler",tolua_get_Director_systemScheduler_ptr,NULL);
   tolua_variable(tolua_S,"postScheduler",tolua_get_Director_postScheduler_ptr,NULL);
   tolua_variable(tolua_S,"currentCamera",tolua_get_Director_currentCamera_ptr,NULL);
   tolua_variable(tolua_S,"frustumCulling",tolua_get_Director_frustumCulling,tolua_set_Director_frustumCulling);
   tolua_variable(tolua_S,"profilerSending",tolua_get_Director_profilerSending,tolua_set_Director_profilerSending);
   tolua_function(tolua_S,"pushCamera",tolua_LuaBinding_Director_pushCamera00);
   tolua_function(tolua_S,"popCamera",tolua_LuaBinding_Director_popCamera00);
   tolua_function(tolua_S,"removeCamera",tolua_LuaBinding_Director_removeCamera00);
   tolua_function(tolua_S,"clearCamera",tolua_LuaBinding_Director_clearCamera00);
   tolua_function(tolua_S,"cleanup",tolua_LuaBinding_Director_cleanup00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Director_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"View","View","",NULL);
  tolua_beginmodule(tolua_S,"View");
   tolua_variable(tolua_S,"size",tolua_get_View_size,NULL);
   tolua_variable(tolua_S,"standardDistance",tolua_get_View_standardDistance,NULL);
   tolua_variable(tolua_S,"aspectRatio",tolua_get_View_aspectRatio,NULL);
   tolua_variable(tolua_S,"nearPlaneDistance",tolua_get_View_nearPlaneDistance,tolua_set_View_nearPlaneDistance);
   tolua_variable(tolua_S,"farPlaneDistance",tolua_get_View_farPlaneDistance,tolua_set_View_farPlaneDistance);
   tolua_variable(tolua_S,"fieldOfView",tolua_get_View_fieldOfView,tolua_set_View_fieldOfView);
   tolua_variable(tolua_S,"scale",tolua_get_View_scale,tolua_set_View_scale);
   tolua_variable(tolua_S,"postEffect",tolua_get_View_postEffect_ptr,tolua_set_View_postEffect_ptr);
   tolua_variable(tolua_S,"vsync",tolua_get_View_vsync,tolua_set_View_vsync);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_View_new00_local);
  tolua_endmodule(tolua_S);
  tolua_function(tolua_S,"Log",tolua_LuaBinding_Log00);
  tolua_cclass(tolua_S,"Slot","Slot","",NULL);
  tolua_beginmodule(tolua_S,"Slot");
   tolua_function(tolua_S,"add",tolua_LuaBinding_Slot_add00);
   tolua_function(tolua_S,"set",tolua_LuaBinding_Slot_set00);
   tolua_function(tolua_S,"remove",tolua_LuaBinding_Slot_remove00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Slot_clear00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Action","Action","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Action");
   tolua_variable(tolua_S,"duration",tolua_get_Action_duration,NULL);
   tolua_variable(tolua_S,"running",tolua_get_Action_running,NULL);
   tolua_variable(tolua_S,"paused",tolua_get_Action_paused,NULL);
   tolua_variable(tolua_S,"reversed",tolua_get_Action_reversed,tolua_set_Action_reversed);
   tolua_variable(tolua_S,"speed",tolua_get_Action_speed,tolua_set_Action_speed);
   tolua_function(tolua_S,"pause",tolua_LuaBinding_Action_pause00);
   tolua_function(tolua_S,"resume",tolua_LuaBinding_Action_resume00);
   tolua_function(tolua_S,"updateTo",tolua_LuaBinding_Action_updateTo00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Node","Node","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Node");
   tolua_variable(tolua_S,"order",tolua_get_Node_order,tolua_set_Node_order);
   tolua_variable(tolua_S,"angle",tolua_get_Node_angle,tolua_set_Node_angle);
   tolua_variable(tolua_S,"angleX",tolua_get_Node_angleX,tolua_set_Node_angleX);
   tolua_variable(tolua_S,"angleY",tolua_get_Node_angleY,tolua_set_Node_angleY);
   tolua_variable(tolua_S,"scaleX",tolua_get_Node_scaleX,tolua_set_Node_scaleX);
   tolua_variable(tolua_S,"scaleY",tolua_get_Node_scaleY,tolua_set_Node_scaleY);
   tolua_variable(tolua_S,"scaleZ",tolua_get_Node_scaleZ,tolua_set_Node_scaleZ);
   tolua_variable(tolua_S,"x",tolua_get_Node_x,tolua_set_Node_x);
   tolua_variable(tolua_S,"y",tolua_get_Node_y,tolua_set_Node_y);
   tolua_variable(tolua_S,"z",tolua_get_Node_z,tolua_set_Node_z);
   tolua_variable(tolua_S,"position",tolua_get_Node_position,tolua_set_Node_position);
   tolua_variable(tolua_S,"skewX",tolua_get_Node_skewX,tolua_set_Node_skewX);
   tolua_variable(tolua_S,"skewY",tolua_get_Node_skewY,tolua_set_Node_skewY);
   tolua_variable(tolua_S,"visible",tolua_get_Node_visible,tolua_set_Node_visible);
   tolua_variable(tolua_S,"anchor",tolua_get_Node_anchor,tolua_set_Node_anchor);
   tolua_variable(tolua_S,"width",tolua_get_Node_width,tolua_set_Node_width);
   tolua_variable(tolua_S,"height",tolua_get_Node_height,tolua_set_Node_height);
   tolua_variable(tolua_S,"size",tolua_get_Node_size,tolua_set_Node_size);
   tolua_variable(tolua_S,"tag",tolua_get_Node_tag,tolua_set_Node_tag);
   tolua_variable(tolua_S,"opacity",tolua_get_Node_opacity,tolua_set_Node_opacity);
   tolua_variable(tolua_S,"color",tolua_get_Node_color,tolua_set_Node_color);
   tolua_variable(tolua_S,"color3",tolua_get_Node_color3,tolua_set_Node_color3);
   tolua_variable(tolua_S,"passOpacity",tolua_get_Node_passOpacity,tolua_set_Node_passOpacity);
   tolua_variable(tolua_S,"passColor3",tolua_get_Node_passColor3,tolua_set_Node_passColor3);
   tolua_variable(tolua_S,"transformTarget",tolua_get_Node_transformTarget_ptr,tolua_set_Node_transformTarget_ptr);
   tolua_variable(tolua_S,"scheduler",tolua_get_Node_scheduler_ptr,tolua_set_Node_scheduler_ptr);
   tolua_variable(tolua_S,"hasChildren",tolua_get_Node_hasChildren,NULL);
   tolua_variable(tolua_S,"children",tolua_get_Node_children_ptr,NULL);
   tolua_variable(tolua_S,"parent",tolua_get_Node_parent_ptr,NULL);
   tolua_variable(tolua_S,"running",tolua_get_Node_running,NULL);
   tolua_variable(tolua_S,"scheduled",tolua_get_Node_scheduled,NULL);
   tolua_variable(tolua_S,"actionCount",tolua_get_Node_actionCount,NULL);
   tolua_variable(tolua_S,"data",tolua_get_Node_data_ptr,NULL);
   tolua_variable(tolua_S,"touchEnabled",tolua_get_Node_touchEnabled,tolua_set_Node_touchEnabled);
   tolua_variable(tolua_S,"swallowTouches",tolua_get_Node_swallowTouches,tolua_set_Node_swallowTouches);
   tolua_variable(tolua_S,"swallowMouseWheel",tolua_get_Node_swallowMouseWheel,tolua_set_Node_swallowMouseWheel);
   tolua_variable(tolua_S,"keyboardEnabled",tolua_get_Node_keyboardEnabled,tolua_set_Node_keyboardEnabled);
   tolua_variable(tolua_S,"controllerEnabled",tolua_get_Node_controllerEnabled,tolua_set_Node_controllerEnabled);
   tolua_variable(tolua_S,"renderGroup",tolua_get_Node_renderGroup,tolua_set_Node_renderGroup);
   tolua_variable(tolua_S,"showDebug",tolua_get_Node_showDebug,tolua_set_Node_showDebug);
   tolua_variable(tolua_S,"renderOrder",tolua_get_Node_renderOrder,tolua_set_Node_renderOrder);
   tolua_function(tolua_S,"addChild",tolua_LuaBinding_Node_addChild02);
   tolua_function(tolua_S,"addTo",tolua_LuaBinding_Node_addTo02);
   tolua_function(tolua_S,"removeChild",tolua_LuaBinding_Node_removeChild00);
   tolua_function(tolua_S,"removeChildByTag",tolua_LuaBinding_Node_removeChildByTag00);
   tolua_function(tolua_S,"removeAllChildren",tolua_LuaBinding_Node_removeAllChildren00);
   tolua_function(tolua_S,"removeFromParent",tolua_LuaBinding_Node_removeFromParent00);
   tolua_function(tolua_S,"moveToParent",tolua_LuaBinding_Node_moveToParent00);
   tolua_function(tolua_S,"cleanup",tolua_LuaBinding_Node_cleanup00);
   tolua_function(tolua_S,"getChildByTag",tolua_LuaBinding_Node_getChildByTag00);
   tolua_function(tolua_S,"schedule",tolua_LuaBinding_Node_schedule00);
   tolua_function(tolua_S,"unschedule",tolua_LuaBinding_Node_unschedule00);
   tolua_function(tolua_S,"onUpdate",tolua_LuaBinding_Node_onUpdate00);
   tolua_function(tolua_S,"onRender",tolua_LuaBinding_Node_onRender00);
   tolua_function(tolua_S,"convertToNodeSpace",tolua_LuaBinding_Node_convertToNodeSpace01);
   tolua_function(tolua_S,"convertToWorldSpace",tolua_LuaBinding_Node_convertToWorldSpace01);
   tolua_function(tolua_S,"convertToWindowSpace",tolua_LuaBinding_Node_convertToWindowSpace00);
   tolua_function(tolua_S,"eachChild",tolua_LuaBinding_Node_eachChild00);
   tolua_function(tolua_S,"traverse",tolua_LuaBinding_Node_traverse00);
   tolua_function(tolua_S,"traverseAll",tolua_LuaBinding_Node_traverseAll00);
   tolua_function(tolua_S,"runAction",tolua_LuaBinding_Node_runAction00);
   tolua_function(tolua_S,"stopAllActions",tolua_LuaBinding_Node_stopAllActions00);
   tolua_function(tolua_S,"perform",tolua_LuaBinding_Node_perform00);
   tolua_function(tolua_S,"stopAction",tolua_LuaBinding_Node_stopAction00);
   tolua_function(tolua_S,"alignItemsVertically",tolua_LuaBinding_Node_alignItemsVertically01);
   tolua_function(tolua_S,"alignItemsHorizontally",tolua_LuaBinding_Node_alignItemsHorizontally01);
   tolua_function(tolua_S,"alignItems",tolua_LuaBinding_Node_alignItems01);
   tolua_function(tolua_S,"moveAndCullItems",tolua_LuaBinding_Node_moveAndCullItems00);
   tolua_function(tolua_S,"attachIME",tolua_LuaBinding_Node_attachIME00);
   tolua_function(tolua_S,"detachIME",tolua_LuaBinding_Node_detachIME00);
   tolua_cclass(tolua_S,"Node::Grabber","Grabber","Object",tolua_collect_object);
   tolua_beginmodule(tolua_S,"Grabber");
    tolua_variable(tolua_S,"camera",tolua_get_Node__Grabber_camera_ptr,tolua_set_Node__Grabber_camera_ptr);
    tolua_variable(tolua_S,"effect",tolua_get_Node__Grabber_effect_ptr,tolua_set_Node__Grabber_effect_ptr);
    tolua_variable(tolua_S,"blendFunc",tolua_get_Node__Grabber_blendFunc,tolua_set_Node__Grabber_blendFunc);
    tolua_variable(tolua_S,"clearColor",tolua_get_Node__Grabber_clearColor,tolua_set_Node__Grabber_clearColor);
    tolua_function(tolua_S,"setPos",tolua_LuaBinding_Node_Grabber_setPos00);
    tolua_function(tolua_S,"getPos",tolua_LuaBinding_Node_Grabber_getPos00);
    tolua_function(tolua_S,"getColor",tolua_LuaBinding_Node_Grabber_getColor00);
    tolua_function(tolua_S,"setColor",tolua_LuaBinding_Node_Grabber_setColor00);
    tolua_function(tolua_S,"moveUV",tolua_LuaBinding_Node_Grabber_moveUV00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"grab",tolua_LuaBinding_Node_grab01);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Node_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Texture2D","Texture2D","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Texture2D");
   tolua_variable(tolua_S,"width",tolua_get_Texture2D_width,NULL);
   tolua_variable(tolua_S,"height",tolua_get_Texture2D_height,NULL);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Texture2D_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"BlendFunc","BlendFunc","",tolua_collect_BlendFunc);
  tolua_beginmodule(tolua_S,"BlendFunc");
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_BlendFunc_new00_local);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_BlendFunc_new02_local);
   tolua_function(tolua_S,"get",tolua_LuaBinding_BlendFunc_get00);
   tolua_variable(tolua_S,"Default",tolua_get_BlendFunc_Default,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Pass","Pass","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Pass");
   tolua_variable(tolua_S,"grabPass",tolua_get_Pass_grabPass,tolua_set_Pass_grabPass);
   tolua_function(tolua_S,"set",tolua_LuaBinding_Pass_set01);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Pass_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Effect","Effect","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Effect");
   tolua_function(tolua_S,"add",tolua_LuaBinding_Effect_add00);
   tolua_function(tolua_S,"get",tolua_LuaBinding_Effect_get00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Effect_clear00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Effect_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"SpriteEffect","SpriteEffect","Effect",tolua_collect_object);
  tolua_beginmodule(tolua_S,"SpriteEffect");
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_SpriteEffect_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Sprite","Sprite","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Sprite");
   tolua_variable(tolua_S,"depthWrite",tolua_get_Sprite_depthWrite,tolua_set_Sprite_depthWrite);
   tolua_variable(tolua_S,"alphaRef",tolua_get_Sprite_alphaRef,tolua_set_Sprite_alphaRef);
   tolua_variable(tolua_S,"textureRect",tolua_get_Sprite_textureRect,tolua_set_Sprite_textureRect);
   tolua_variable(tolua_S,"texture",tolua_get_Sprite_texture_ptr,NULL);
   tolua_variable(tolua_S,"blendFunc",tolua_get_Sprite_blendFunc,tolua_set_Sprite_blendFunc);
   tolua_variable(tolua_S,"effect",tolua_get_Sprite_effect_ptr,tolua_set_Sprite_effect_ptr);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Sprite_new03_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Grid","Grid","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Grid");
   tolua_variable(tolua_S,"gridX",tolua_get_Grid_gridX,NULL);
   tolua_variable(tolua_S,"gridY",tolua_get_Grid_gridY,NULL);
   tolua_variable(tolua_S,"depthWrite",tolua_get_Grid_depthWrite,tolua_set_Grid_depthWrite);
   tolua_variable(tolua_S,"blendFunc",tolua_get_Grid_blendFunc,tolua_set_Grid_blendFunc);
   tolua_variable(tolua_S,"effect",tolua_get_Grid_effect_ptr,tolua_set_Grid_effect_ptr);
   tolua_variable(tolua_S,"textureRect",tolua_get_Grid_textureRect,tolua_set_Grid_textureRect);
   tolua_variable(tolua_S,"texture",tolua_get_Grid_texture_ptr,tolua_set_Grid_texture_ptr);
   tolua_function(tolua_S,"setPos",tolua_LuaBinding_Grid_setPos00);
   tolua_function(tolua_S,"getPos",tolua_LuaBinding_Grid_getPos00);
   tolua_function(tolua_S,"getColor",tolua_LuaBinding_Grid_getColor00);
   tolua_function(tolua_S,"setColor",tolua_LuaBinding_Grid_setColor00);
   tolua_function(tolua_S,"moveUV",tolua_LuaBinding_Grid_moveUV00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Grid_new03_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Touch","Touch","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Touch");
   tolua_variable(tolua_S,"enabled",tolua_get_Touch_enabled,tolua_set_Touch_enabled);
   tolua_variable(tolua_S,"first",tolua_get_Touch_first,NULL);
   tolua_variable(tolua_S,"id",tolua_get_Touch_id,NULL);
   tolua_variable(tolua_S,"delta",tolua_get_Touch_delta,NULL);
   tolua_variable(tolua_S,"location",tolua_get_Touch_location,NULL);
   tolua_variable(tolua_S,"worldLocation",tolua_get_Touch_worldLocation,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Ease","Ease","",NULL);
  tolua_beginmodule(tolua_S,"Ease");
   tolua_constant(tolua_S,"Linear",lua_Integer(Ease::Linear));
   tolua_constant(tolua_S,"InQuad",lua_Integer(Ease::InQuad));
   tolua_constant(tolua_S,"OutQuad",lua_Integer(Ease::OutQuad));
   tolua_constant(tolua_S,"InOutQuad",lua_Integer(Ease::InOutQuad));
   tolua_constant(tolua_S,"OutInQuad",lua_Integer(Ease::OutInQuad));
   tolua_constant(tolua_S,"InCubic",lua_Integer(Ease::InCubic));
   tolua_constant(tolua_S,"OutCubic",lua_Integer(Ease::OutCubic));
   tolua_constant(tolua_S,"InOutCubic",lua_Integer(Ease::InOutCubic));
   tolua_constant(tolua_S,"OutInCubic",lua_Integer(Ease::OutInCubic));
   tolua_constant(tolua_S,"InQuart",lua_Integer(Ease::InQuart));
   tolua_constant(tolua_S,"OutQuart",lua_Integer(Ease::OutQuart));
   tolua_constant(tolua_S,"InOutQuart",lua_Integer(Ease::InOutQuart));
   tolua_constant(tolua_S,"OutInQuart",lua_Integer(Ease::OutInQuart));
   tolua_constant(tolua_S,"InQuint",lua_Integer(Ease::InQuint));
   tolua_constant(tolua_S,"OutQuint",lua_Integer(Ease::OutQuint));
   tolua_constant(tolua_S,"InOutQuint",lua_Integer(Ease::InOutQuint));
   tolua_constant(tolua_S,"OutInQuint",lua_Integer(Ease::OutInQuint));
   tolua_constant(tolua_S,"InSine",lua_Integer(Ease::InSine));
   tolua_constant(tolua_S,"OutSine",lua_Integer(Ease::OutSine));
   tolua_constant(tolua_S,"InOutSine",lua_Integer(Ease::InOutSine));
   tolua_constant(tolua_S,"OutInSine",lua_Integer(Ease::OutInSine));
   tolua_constant(tolua_S,"InExpo",lua_Integer(Ease::InExpo));
   tolua_constant(tolua_S,"OutExpo",lua_Integer(Ease::OutExpo));
   tolua_constant(tolua_S,"InOutExpo",lua_Integer(Ease::InOutExpo));
   tolua_constant(tolua_S,"OutInExpo",lua_Integer(Ease::OutInExpo));
   tolua_constant(tolua_S,"InCirc",lua_Integer(Ease::InCirc));
   tolua_constant(tolua_S,"OutCirc",lua_Integer(Ease::OutCirc));
   tolua_constant(tolua_S,"InOutCirc",lua_Integer(Ease::InOutCirc));
   tolua_constant(tolua_S,"OutInCirc",lua_Integer(Ease::OutInCirc));
   tolua_constant(tolua_S,"InElastic",lua_Integer(Ease::InElastic));
   tolua_constant(tolua_S,"OutElastic",lua_Integer(Ease::OutElastic));
   tolua_constant(tolua_S,"InOutElastic",lua_Integer(Ease::InOutElastic));
   tolua_constant(tolua_S,"OutInElastic",lua_Integer(Ease::OutInElastic));
   tolua_constant(tolua_S,"InBack",lua_Integer(Ease::InBack));
   tolua_constant(tolua_S,"OutBack",lua_Integer(Ease::OutBack));
   tolua_constant(tolua_S,"InOutBack",lua_Integer(Ease::InOutBack));
   tolua_constant(tolua_S,"OutInBack",lua_Integer(Ease::OutInBack));
   tolua_constant(tolua_S,"InBounce",lua_Integer(Ease::InBounce));
   tolua_constant(tolua_S,"OutBounce",lua_Integer(Ease::OutBounce));
   tolua_constant(tolua_S,"InOutBounce",lua_Integer(Ease::InOutBounce));
   tolua_constant(tolua_S,"OutInBounce",lua_Integer(Ease::OutInBounce));
   tolua_function(tolua_S,"func",tolua_LuaBinding_Ease_func00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Label","Label","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Label");
   tolua_variable(tolua_S,"alphaRef",tolua_get_Label_alphaRef,tolua_set_Label_alphaRef);
   tolua_variable(tolua_S,"textWidth",tolua_get_Label_textWidth,tolua_set_Label_textWidth);
   tolua_variable(tolua_S,"spacing",tolua_get_Label_spacing,tolua_set_Label_spacing);
   tolua_variable(tolua_S,"lineGap",tolua_get_Label_lineGap,tolua_set_Label_lineGap);
   tolua_variable(tolua_S,"outlineWidth",tolua_get_Label_outlineWidth,tolua_set_Label_outlineWidth);
   tolua_variable(tolua_S,"outlineColor",tolua_get_Label_outlineColor,tolua_set_Label_outlineColor);
   tolua_variable(tolua_S,"smooth",tolua_get_Label_smooth,tolua_set_Label_smooth);
   tolua_variable(tolua_S,"text",tolua_get_Label_text,tolua_set_Label_text);
   tolua_variable(tolua_S,"blendFunc",tolua_get_Label_blendFunc,tolua_set_Label_blendFunc);
   tolua_variable(tolua_S,"depthWrite",tolua_get_Label_depthWrite,tolua_set_Label_depthWrite);
   tolua_variable(tolua_S,"batched",tolua_get_Label_batched,tolua_set_Label_batched);
   tolua_variable(tolua_S,"effect",tolua_get_Label_effect_ptr,tolua_set_Label_effect_ptr);
   tolua_variable(tolua_S,"characterCount",tolua_get_Label_characterCount,NULL);
   tolua_function(tolua_S,"getCharacter",tolua_LuaBinding_Label_getCharacter00);
   tolua_variable(tolua_S,"AutomaticWidth",tolua_get_Label_AutomaticWidth,NULL);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Label_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"RenderTarget","RenderTarget","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"RenderTarget");
   tolua_variable(tolua_S,"width",tolua_get_RenderTarget_width,NULL);
   tolua_variable(tolua_S,"height",tolua_get_RenderTarget_height,NULL);
   tolua_variable(tolua_S,"camera",tolua_get_RenderTarget_camera_ptr,tolua_set_RenderTarget_camera_ptr);
   tolua_variable(tolua_S,"texture",tolua_get_RenderTarget_texture_ptr,NULL);
   tolua_function(tolua_S,"render",tolua_LuaBinding_RenderTarget_render00);
   tolua_function(tolua_S,"renderWithClear",tolua_LuaBinding_RenderTarget_renderWithClear01);
   tolua_function(tolua_S,"saveAsync",tolua_LuaBinding_RenderTarget_saveAsync00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_RenderTarget_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"ClipNode","ClipNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"ClipNode");
   tolua_variable(tolua_S,"stencil",tolua_get_ClipNode_stencil_ptr,tolua_set_ClipNode_stencil_ptr);
   tolua_variable(tolua_S,"alphaThreshold",tolua_get_ClipNode_alphaThreshold,tolua_set_ClipNode_alphaThreshold);
   tolua_variable(tolua_S,"inverted",tolua_get_ClipNode_inverted,tolua_set_ClipNode_inverted);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_ClipNode_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"DrawNode","DrawNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"DrawNode");
   tolua_variable(tolua_S,"depthWrite",tolua_get_DrawNode_depthWrite,tolua_set_DrawNode_depthWrite);
   tolua_variable(tolua_S,"blendFunc",tolua_get_DrawNode_blendFunc,tolua_set_DrawNode_blendFunc);
   tolua_function(tolua_S,"drawDot",tolua_LuaBinding_DrawNode_drawDot00);
   tolua_function(tolua_S,"drawSegment",tolua_LuaBinding_DrawNode_drawSegment00);
   tolua_function(tolua_S,"drawPolygon",tolua_LuaBinding_DrawNode_drawPolygon00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_DrawNode_clear00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_DrawNode_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Line","Line","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Line");
   tolua_variable(tolua_S,"depthWrite",tolua_get_Line_depthWrite,tolua_set_Line_depthWrite);
   tolua_variable(tolua_S,"blendFunc",tolua_get_Line_blendFunc,tolua_set_Line_blendFunc);
   tolua_function(tolua_S,"add",tolua_LuaBinding_Line_add00);
   tolua_function(tolua_S,"set",tolua_LuaBinding_Line_set00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Line_clear00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Line_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"ParticleNode","Particle","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Particle");
   tolua_variable(tolua_S,"active",tolua_get_ParticleNode_active,NULL);
   tolua_function(tolua_S,"start",tolua_LuaBinding_Particle_start00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_Particle_stop00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Particle_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Playable","Playable","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Playable");
   tolua_variable(tolua_S,"look",tolua_get_Playable_look,tolua_set_Playable_look);
   tolua_variable(tolua_S,"speed",tolua_get_Playable_speed,tolua_set_Playable_speed);
   tolua_variable(tolua_S,"recovery",tolua_get_Playable_recovery,tolua_set_Playable_recovery);
   tolua_variable(tolua_S,"fliped",tolua_get_Playable_fliped,tolua_set_Playable_fliped);
   tolua_variable(tolua_S,"current",tolua_get_Playable_current,NULL);
   tolua_variable(tolua_S,"lastCompleted",tolua_get_Playable_lastCompleted,NULL);
   tolua_function(tolua_S,"getKey",tolua_LuaBinding_Playable_getKey00);
   tolua_function(tolua_S,"play",tolua_LuaBinding_Playable_play00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_Playable_stop00);
   tolua_function(tolua_S,"setSlot",tolua_LuaBinding_Playable_setSlot00);
   tolua_function(tolua_S,"getSlot",tolua_LuaBinding_Playable_getSlot00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Playable_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Model","Model","Playable",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Model");
   tolua_variable(tolua_S,"reversed",tolua_get_Model_reversed,tolua_set_Model_reversed);
   tolua_variable(tolua_S,"duration",tolua_get_Model_duration,NULL);
   tolua_variable(tolua_S,"playing",tolua_get_Model_playing,NULL);
   tolua_variable(tolua_S,"paused",tolua_get_Model_paused,NULL);
   tolua_function(tolua_S,"hasAnimation",tolua_LuaBinding_Model_hasAnimation00);
   tolua_function(tolua_S,"pause",tolua_LuaBinding_Model_pause00);
   tolua_function(tolua_S,"resume",tolua_LuaBinding_Model_resume01);
   tolua_function(tolua_S,"reset",tolua_LuaBinding_Model_reset00);
   tolua_function(tolua_S,"updateTo",tolua_LuaBinding_Model_updateTo00);
   tolua_function(tolua_S,"getNodeByName",tolua_LuaBinding_Model_getNodeByName00);
   tolua_function(tolua_S,"eachNode",tolua_LuaBinding_Model_eachNode00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Model_new00_local);
   tolua_function(tolua_S,"dummy",tolua_LuaBinding_Model_dummy00);
   tolua_function(tolua_S,"getClipFile",tolua_LuaBinding_Model_getClipFile00);
   tolua_function(tolua_S,"getLooks",tolua_LuaBinding_Model_getLooks00);
   tolua_function(tolua_S,"getAnimations",tolua_LuaBinding_Model_getAnimations00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Spine","Spine","Playable",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Spine");
   tolua_variable(tolua_S,"hitTestEnabled",tolua_get_Spine_hitTestEnabled,tolua_set_Spine_hitTestEnabled);
   tolua_function(tolua_S,"setBoneRotation",tolua_LuaBinding_Spine_setBoneRotation00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Spine_new01_local);
   tolua_function(tolua_S,"getLooks",tolua_LuaBinding_Spine_getLooks00);
   tolua_function(tolua_S,"getAnimations",tolua_LuaBinding_Spine_getAnimations00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"DragonBone","DragonBone","Playable",tolua_collect_object);
  tolua_beginmodule(tolua_S,"DragonBone");
   tolua_variable(tolua_S,"hitTestEnabled",tolua_get_DragonBone_hitTestEnabled,tolua_set_DragonBone_hitTestEnabled);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_DragonBone_new01_local);
   tolua_function(tolua_S,"getLooks",tolua_LuaBinding_DragonBone_getLooks00);
   tolua_function(tolua_S,"getAnimations",tolua_LuaBinding_DragonBone_getAnimations00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"AlignNode","AlignNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"AlignNode");
   tolua_function(tolua_S,"css",tolua_LuaBinding_AlignNode_css00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_AlignNode_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"EffekNode","EffekNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"EffekNode");
   tolua_function(tolua_S,"play",tolua_LuaBinding_EffekNode_play00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_EffekNode_stop00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_EffekNode_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"TileNode","TileNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"TileNode");
   tolua_variable(tolua_S,"depthWrite",tolua_get_TileNode_depthWrite,tolua_set_TileNode_depthWrite);
   tolua_variable(tolua_S,"blendFunc",tolua_get_TileNode_blendFunc,tolua_set_TileNode_blendFunc);
   tolua_variable(tolua_S,"effect",tolua_get_TileNode_effect_ptr,tolua_set_TileNode_effect_ptr);
   tolua_function(tolua_S,"getLayer",tolua_LuaBinding_TileNode_getLayer00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_TileNode_new02_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"PhysicsWorld","PhysicsWorld","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"PhysicsWorld");
   tolua_function(tolua_S,"query",tolua_LuaBinding_PhysicsWorld_query00);
   tolua_function(tolua_S,"raycast",tolua_LuaBinding_PhysicsWorld_raycast00);
   tolua_function(tolua_S,"setIterations",tolua_LuaBinding_PhysicsWorld_setIterations00);
   tolua_function(tolua_S,"setShouldContact",tolua_LuaBinding_PhysicsWorld_setShouldContact00);
   tolua_function(tolua_S,"getShouldContact",tolua_LuaBinding_PhysicsWorld_getShouldContact00);
   tolua_variable(tolua_S,"scaleFactor",tolua_get_PhysicsWorld_scaleFactor,tolua_set_PhysicsWorld_scaleFactor);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_PhysicsWorld_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"FixtureDef","FixtureDef","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"FixtureDef");
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"BodyDef","BodyDef","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"BodyDef");
   tolua_variable(tolua_S,"position",tolua_get_BodyDef_position,tolua_set_BodyDef_position);
   tolua_variable(tolua_S,"angle",tolua_get_BodyDef_angle,tolua_set_BodyDef_angle);
   tolua_variable(tolua_S,"face",tolua_get_BodyDef_face,tolua_set_BodyDef_face);
   tolua_variable(tolua_S,"facePos",tolua_get_BodyDef_facePos,tolua_set_BodyDef_facePos);
   tolua_variable(tolua_S,"linearDamping",tolua_get_BodyDef_linearDamping,tolua_set_BodyDef_linearDamping);
   tolua_variable(tolua_S,"angularDamping",tolua_get_BodyDef_angularDamping,tolua_set_BodyDef_angularDamping);
   tolua_variable(tolua_S,"linearAcceleration",tolua_get_BodyDef_linearAcceleration,tolua_set_BodyDef_linearAcceleration);
   tolua_variable(tolua_S,"fixedRotation",tolua_get_BodyDef_fixedRotation,tolua_set_BodyDef_fixedRotation);
   tolua_variable(tolua_S,"bullet",tolua_get_BodyDef_bullet,tolua_set_BodyDef_bullet);
   tolua_function(tolua_S,"polygon",tolua_LuaBinding_BodyDef_polygon02);
   tolua_function(tolua_S,"attachPolygon",tolua_LuaBinding_BodyDef_attachPolygon02);
   tolua_function(tolua_S,"multi",tolua_LuaBinding_BodyDef_multi00);
   tolua_function(tolua_S,"attachMulti",tolua_LuaBinding_BodyDef_attachMulti00);
   tolua_function(tolua_S,"disk",tolua_LuaBinding_BodyDef_disk01);
   tolua_function(tolua_S,"attachDisk",tolua_LuaBinding_BodyDef_attachDisk01);
   tolua_function(tolua_S,"chain",tolua_LuaBinding_BodyDef_chain00);
   tolua_function(tolua_S,"attachChain",tolua_LuaBinding_BodyDef_attachChain00);
   tolua_function(tolua_S,"attachPolygonSensor",tolua_LuaBinding_BodyDef_attachPolygonSensor02);
   tolua_function(tolua_S,"attachDiskSensor",tolua_LuaBinding_BodyDef_attachDiskSensor01);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_BodyDef_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Sensor","Sensor","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Sensor");
   tolua_variable(tolua_S,"enabled",tolua_get_Sensor_enabled,tolua_set_Sensor_enabled);
   tolua_variable(tolua_S,"tag",tolua_get_Sensor_tag,NULL);
   tolua_variable(tolua_S,"owner",tolua_get_Sensor_owner_ptr,NULL);
   tolua_variable(tolua_S,"sensed",tolua_get_Sensor_sensed,NULL);
   tolua_variable(tolua_S,"sensedBodies",tolua_get_Sensor_sensedBodies_ptr,NULL);
   tolua_function(tolua_S,"contains",tolua_LuaBinding_Sensor_contains00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Body","Body","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Body");
   tolua_variable(tolua_S,"world",tolua_get_Body_world_ptr,NULL);
   tolua_variable(tolua_S,"bodyDef",tolua_get_Body_bodyDef_ptr,NULL);
   tolua_variable(tolua_S,"mass",tolua_get_Body_mass,NULL);
   tolua_variable(tolua_S,"sensor",tolua_get_Body_sensor,NULL);
   tolua_variable(tolua_S,"velocityX",tolua_get_Body_velocityX,tolua_set_Body_velocityX);
   tolua_variable(tolua_S,"velocityY",tolua_get_Body_velocityY,tolua_set_Body_velocityY);
   tolua_variable(tolua_S,"velocity",tolua_get_Body_velocity,tolua_set_Body_velocity);
   tolua_variable(tolua_S,"angularRate",tolua_get_Body_angularRate,tolua_set_Body_angularRate);
   tolua_variable(tolua_S,"group",tolua_get_Body_group,tolua_set_Body_group);
   tolua_variable(tolua_S,"linearDamping",tolua_get_Body_linearDamping,tolua_set_Body_linearDamping);
   tolua_variable(tolua_S,"angularDamping",tolua_get_Body_angularDamping,tolua_set_Body_angularDamping);
   tolua_variable(tolua_S,"owner",tolua_get_Body_owner_ptr,tolua_set_Body_owner_ptr);
   tolua_variable(tolua_S,"receivingContact",tolua_get_Body_receivingContact,tolua_set_Body_receivingContact);
   tolua_function(tolua_S,"applyLinearImpulse",tolua_LuaBinding_Body_applyLinearImpulse00);
   tolua_function(tolua_S,"applyAngularImpulse",tolua_LuaBinding_Body_applyAngularImpulse00);
   tolua_function(tolua_S,"getSensorByTag",tolua_LuaBinding_Body_getSensorByTag00);
   tolua_function(tolua_S,"removeSensorByTag",tolua_LuaBinding_Body_removeSensorByTag00);
   tolua_function(tolua_S,"removeSensor",tolua_LuaBinding_Body_removeSensor00);
   tolua_function(tolua_S,"attach",tolua_LuaBinding_Body_attach00);
   tolua_function(tolua_S,"attachSensor",tolua_LuaBinding_Body_attachSensor00);
   tolua_function(tolua_S,"onContactFilter",tolua_LuaBinding_Body_onContactFilter00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Body_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"JointDef","JointDef","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"JointDef");
   tolua_variable(tolua_S,"center",tolua_get_JointDef_center,tolua_set_JointDef_center);
   tolua_variable(tolua_S,"position",tolua_get_JointDef_position,tolua_set_JointDef_position);
   tolua_variable(tolua_S,"angle",tolua_get_JointDef_angle,tolua_set_JointDef_angle);
   tolua_function(tolua_S,"distance",tolua_LuaBinding_JointDef_distance00);
   tolua_function(tolua_S,"friction",tolua_LuaBinding_JointDef_friction00);
   tolua_function(tolua_S,"gear",tolua_LuaBinding_JointDef_gear00);
   tolua_function(tolua_S,"spring",tolua_LuaBinding_JointDef_spring00);
   tolua_function(tolua_S,"prismatic",tolua_LuaBinding_JointDef_prismatic00);
   tolua_function(tolua_S,"pulley",tolua_LuaBinding_JointDef_pulley00);
   tolua_function(tolua_S,"revolute",tolua_LuaBinding_JointDef_revolute00);
   tolua_function(tolua_S,"rope",tolua_LuaBinding_JointDef_rope00);
   tolua_function(tolua_S,"weld",tolua_LuaBinding_JointDef_weld00);
   tolua_function(tolua_S,"wheel",tolua_LuaBinding_JointDef_wheel00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Joint","Joint","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Joint");
   tolua_function(tolua_S,"distance",tolua_LuaBinding_Joint_distance00);
   tolua_function(tolua_S,"friction",tolua_LuaBinding_Joint_friction00);
   tolua_function(tolua_S,"gear",tolua_LuaBinding_Joint_gear00);
   tolua_function(tolua_S,"spring",tolua_LuaBinding_Joint_spring00);
   tolua_function(tolua_S,"move",tolua_LuaBinding_Joint_move00);
   tolua_function(tolua_S,"prismatic",tolua_LuaBinding_Joint_prismatic00);
   tolua_function(tolua_S,"pulley",tolua_LuaBinding_Joint_pulley00);
   tolua_function(tolua_S,"revolute",tolua_LuaBinding_Joint_revolute00);
   tolua_function(tolua_S,"rope",tolua_LuaBinding_Joint_rope00);
   tolua_function(tolua_S,"weld",tolua_LuaBinding_Joint_weld00);
   tolua_function(tolua_S,"wheel",tolua_LuaBinding_Joint_wheel00);
   tolua_variable(tolua_S,"world",tolua_get_Joint_world_ptr,NULL);
   tolua_function(tolua_S,"destroy",tolua_LuaBinding_Joint_destroy00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Joint_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"MoveJoint","MoveJoint","Joint",tolua_collect_object);
  tolua_beginmodule(tolua_S,"MoveJoint");
   tolua_variable(tolua_S,"position",tolua_get_MoveJoint_position,tolua_set_MoveJoint_position);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"MotorJoint","MotorJoint","Joint",tolua_collect_object);
  tolua_beginmodule(tolua_S,"MotorJoint");
   tolua_variable(tolua_S,"enabled",tolua_get_MotorJoint_enabled,tolua_set_MotorJoint_enabled);
   tolua_variable(tolua_S,"force",tolua_get_MotorJoint_force,tolua_set_MotorJoint_force);
   tolua_variable(tolua_S,"speed",tolua_get_MotorJoint_speed,tolua_set_MotorJoint_speed);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Cache","Cache","",NULL);
  tolua_beginmodule(tolua_S,"Cache");
   tolua_function(tolua_S,"load",tolua_LuaBinding_Cache_load00);
   tolua_function(tolua_S,"loadAsync",tolua_LuaBinding_Cache_loadAsync00);
   tolua_function(tolua_S,"update",tolua_LuaBinding_Cache_update01);
   tolua_function(tolua_S,"unload",tolua_LuaBinding_Cache_unload01);
   tolua_function(tolua_S,"removeUnused",tolua_LuaBinding_Cache_removeUnused01);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Audio","Audio","",NULL);
  tolua_beginmodule(tolua_S,"Audio");
   tolua_variable(tolua_S,"soundSpeed",tolua_get_Audio_soundSpeed,tolua_set_Audio_soundSpeed);
   tolua_variable(tolua_S,"globalVolume",tolua_get_Audio_globalVolume,tolua_set_Audio_globalVolume);
   tolua_variable(tolua_S,"listener",tolua_get_Audio_listener_ptr,tolua_set_Audio_listener_ptr);
   tolua_function(tolua_S,"play",tolua_LuaBinding_Audio_play00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_Audio_stop00);
   tolua_function(tolua_S,"playStream",tolua_LuaBinding_Audio_playStream00);
   tolua_function(tolua_S,"stopStream",tolua_LuaBinding_Audio_stopStream00);
   tolua_function(tolua_S,"stopAll",tolua_LuaBinding_Audio_stopAll00);
   tolua_function(tolua_S,"setPauseAllCurrent",tolua_LuaBinding_Audio_setPauseAllCurrent00);
   tolua_function(tolua_S,"setListenerAt",tolua_LuaBinding_Audio_setListenerAt00);
   tolua_function(tolua_S,"setListenerUp",tolua_LuaBinding_Audio_setListenerUp00);
   tolua_function(tolua_S,"setListenerVelocity",tolua_LuaBinding_Audio_setListenerVelocity00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Audio_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"AudioBus","AudioBus","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"AudioBus");
   tolua_variable(tolua_S,"volume",tolua_get_AudioBus_volume,tolua_set_AudioBus_volume);
   tolua_variable(tolua_S,"pan",tolua_get_AudioBus_pan,tolua_set_AudioBus_pan);
   tolua_variable(tolua_S,"playSpeed",tolua_get_AudioBus_playSpeed,tolua_set_AudioBus_playSpeed);
   tolua_function(tolua_S,"fadeVolume",tolua_LuaBinding_AudioBus_fadeVolume00);
   tolua_function(tolua_S,"fadePan",tolua_LuaBinding_AudioBus_fadePan00);
   tolua_function(tolua_S,"fadePlaySpeed",tolua_LuaBinding_AudioBus_fadePlaySpeed00);
   tolua_function(tolua_S,"setFilter",tolua_LuaBinding_AudioBus_setFilter00);
   tolua_function(tolua_S,"setFilterParameter",tolua_LuaBinding_AudioBus_setFilterParameter00);
   tolua_function(tolua_S,"getFilterParameter",tolua_LuaBinding_AudioBus_getFilterParameter00);
   tolua_function(tolua_S,"fadeFilterParameter",tolua_LuaBinding_AudioBus_fadeFilterParameter00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_AudioBus_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"AudioSource","AudioSource","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"AudioSource");
   tolua_variable(tolua_S,"volume",tolua_get_AudioSource_volume,tolua_set_AudioSource_volume);
   tolua_variable(tolua_S,"pan",tolua_get_AudioSource_pan,tolua_set_AudioSource_pan);
   tolua_variable(tolua_S,"looping",tolua_get_AudioSource_looping,tolua_set_AudioSource_looping);
   tolua_variable(tolua_S,"playing",tolua_get_AudioSource_playing,NULL);
   tolua_function(tolua_S,"seek",tolua_LuaBinding_AudioSource_seek00);
   tolua_function(tolua_S,"scheduleStop",tolua_LuaBinding_AudioSource_scheduleStop00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_AudioSource_stop00);
   tolua_function(tolua_S,"play",tolua_LuaBinding_AudioSource_play00);
   tolua_function(tolua_S,"playBackground",tolua_LuaBinding_AudioSource_playBackground00);
   tolua_function(tolua_S,"play3D",tolua_LuaBinding_AudioSource_play3D00);
   tolua_function(tolua_S,"setProtected",tolua_LuaBinding_AudioSource_setProtected00);
   tolua_function(tolua_S,"setLoopPoint",tolua_LuaBinding_AudioSource_setLoopPoint00);
   tolua_function(tolua_S,"setVelocity",tolua_LuaBinding_AudioSource_setVelocity00);
   tolua_function(tolua_S,"setMinMaxDistance",tolua_LuaBinding_AudioSource_setMinMaxDistance00);
   tolua_function(tolua_S,"setAttenuation",tolua_LuaBinding_AudioSource_setAttenuation00);
   tolua_function(tolua_S,"setDopplerFactor",tolua_LuaBinding_AudioSource_setDopplerFactor00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_AudioSource_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Menu","Menu","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Menu");
   tolua_variable(tolua_S,"enabled",tolua_get_Menu_enabled,tolua_set_Menu_enabled);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Menu_new01_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Keyboard","Keyboard","",NULL);
  tolua_beginmodule(tolua_S,"Keyboard");
   tolua_function(tolua_S,"isKeyDown",tolua_LuaBinding_Keyboard_isKeyDown00);
   tolua_function(tolua_S,"isKeyUp",tolua_LuaBinding_Keyboard_isKeyUp00);
   tolua_function(tolua_S,"isKeyPressed",tolua_LuaBinding_Keyboard_isKeyPressed00);
   tolua_function(tolua_S,"updateIMEPosHint",tolua_LuaBinding_Keyboard_updateIMEPosHint00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Keyboard_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Mouse","Mouse","",NULL);
  tolua_beginmodule(tolua_S,"Mouse");
   tolua_variable(tolua_S,"position",tolua_get_Mouse_position,NULL);
   tolua_variable(tolua_S,"leftButtonPressed",tolua_get_Mouse_leftButtonPressed,NULL);
   tolua_variable(tolua_S,"rightButtonPressed",tolua_get_Mouse_rightButtonPressed,NULL);
   tolua_variable(tolua_S,"middleButtonPressed",tolua_get_Mouse_middleButtonPressed,NULL);
   tolua_variable(tolua_S,"wheel",tolua_get_Mouse_wheel,NULL);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Controller","Controller","",NULL);
  tolua_beginmodule(tolua_S,"Controller");
   tolua_function(tolua_S,"isButtonDown",tolua_LuaBinding_Controller_isButtonDown00);
   tolua_function(tolua_S,"isButtonUp",tolua_LuaBinding_Controller_isButtonUp00);
   tolua_function(tolua_S,"isButtonPressed",tolua_LuaBinding_Controller_isButtonPressed00);
   tolua_function(tolua_S,"getAxis",tolua_LuaBinding_Controller_getAxis00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Controller_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"SVGDef","SVG","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"SVG");
   tolua_variable(tolua_S,"width",tolua_get_SVGDef_width,NULL);
   tolua_variable(tolua_S,"height",tolua_get_SVGDef_height,NULL);
   tolua_function(tolua_S,"render",tolua_LuaBinding_SVG_render00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_SVG_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"DB","DB","",NULL);
  tolua_beginmodule(tolua_S,"DB");
   tolua_function(tolua_S,"existDB",tolua_LuaBinding_DB_existDB00);
   tolua_function(tolua_S,"exist",tolua_LuaBinding_DB_exist00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_DB_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"HttpServer","HttpServer","",NULL);
  tolua_beginmodule(tolua_S,"HttpServer");
   tolua_variable(tolua_S,"localIP",tolua_get_HttpServer_localIP,NULL);
   tolua_variable(tolua_S,"wsConnectionCount",tolua_get_HttpServer_wsConnectionCount,NULL);
   tolua_variable(tolua_S,"wwwPath",tolua_get_HttpServer_wwwPath,tolua_set_HttpServer_wwwPath);
   tolua_function(tolua_S,"start",tolua_LuaBinding_HttpServer_start00);
   tolua_function(tolua_S,"startWS",tolua_LuaBinding_HttpServer_startWS00);
   tolua_function(tolua_S,"stop",tolua_LuaBinding_HttpServer_stop00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_HttpServer_new00_local);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"HttpClient","HttpClient","",NULL);
  tolua_beginmodule(tolua_S,"HttpClient");
   tolua_function(tolua_S,"postAsync",tolua_LuaBinding_HttpClient_postAsync02);
   tolua_function(tolua_S,"getAsync",tolua_LuaBinding_HttpClient_getAsync00);
   tolua_function(tolua_S,"downloadAsync",tolua_LuaBinding_HttpClient_downloadAsync00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_HttpClient_new00_local);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"ML",0);
  tolua_beginmodule(tolua_S,"ML");
   tolua_cclass(tolua_S,"ML::QLearner","QLearner","Object",tolua_collect_object);
   tolua_beginmodule(tolua_S,"QLearner");
    tolua_function(tolua_S,"update",tolua_LuaBinding_ML_QLearner_update00);
    tolua_function(tolua_S,"getBestAction",tolua_LuaBinding_ML_QLearner_getBestAction00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_ML_QLearner_new00_local);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"BuildDecisionTreeAsync",tolua_LuaBinding_ML_BuildDecisionTreeAsync00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"WasmRuntime","Wasm","",NULL);
  tolua_beginmodule(tolua_S,"Wasm");
   tolua_function(tolua_S,"executeMainFile",tolua_LuaBinding_Wasm_executeMainFile00);
   tolua_function(tolua_S,"executeMainFileAsync",tolua_LuaBinding_Wasm_executeMainFileAsync00);
   tolua_function(tolua_S,"buildWaAsync",tolua_LuaBinding_Wasm_buildWaAsync00);
   tolua_function(tolua_S,"formatWaAsync",tolua_LuaBinding_Wasm_formatWaAsync00);
   tolua_function(tolua_S,"clear",tolua_LuaBinding_Wasm_clear00);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"Platformer",0);
  tolua_beginmodule(tolua_S,"Platformer");
   tolua_cclass(tolua_S,"Platformer::TargetAllow","TargetAllow","",tolua_collect_Platformer__TargetAllow);
   tolua_beginmodule(tolua_S,"TargetAllow");
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_TargetAllow_new00_local);
    tolua_variable(tolua_S,"terrainAllowed",tolua_get_Platformer__TargetAllow_terrainAllowed,tolua_set_Platformer__TargetAllow_terrainAllowed);
    tolua_function(tolua_S,"allow",tolua_LuaBinding_Platformer_TargetAllow_allow00);
    tolua_function(tolua_S,"isAllow",tolua_LuaBinding_Platformer_TargetAllow_isAllow00);
    tolua_function(tolua_S,"toValue",tolua_LuaBinding_Platformer_TargetAllow_toValue00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::Face","Face","Object",tolua_collect_object);
   tolua_beginmodule(tolua_S,"Face");
    tolua_function(tolua_S,"addChild",tolua_LuaBinding_Platformer_Face_addChild00);
    tolua_function(tolua_S,"toNode",tolua_LuaBinding_Platformer_Face_toNode00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Face_new01_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::BulletDef","BulletDef","Object",tolua_collect_object);
   tolua_beginmodule(tolua_S,"BulletDef");
    tolua_variable(tolua_S,"tag",tolua_get_Platformer__BulletDef_tag,tolua_set_Platformer__BulletDef_tag);
    tolua_variable(tolua_S,"endEffect",tolua_get_Platformer__BulletDef_endEffect,tolua_set_Platformer__BulletDef_endEffect);
    tolua_variable(tolua_S,"lifeTime",tolua_get_Platformer__BulletDef_lifeTime,tolua_set_Platformer__BulletDef_lifeTime);
    tolua_variable(tolua_S,"damageRadius",tolua_get_Platformer__BulletDef_damageRadius,tolua_set_Platformer__BulletDef_damageRadius);
    tolua_variable(tolua_S,"highSpeedFix",tolua_get_Platformer__BulletDef_highSpeedFix,tolua_set_Platformer__BulletDef_highSpeedFix);
    tolua_variable(tolua_S,"gravity",tolua_get_Platformer__BulletDef_gravity,tolua_set_Platformer__BulletDef_gravity);
    tolua_variable(tolua_S,"face",tolua_get_Platformer__BulletDef_face_ptr,tolua_set_Platformer__BulletDef_face_ptr);
    tolua_variable(tolua_S,"bodyDef",tolua_get_Platformer__BulletDef_bodyDef_ptr,NULL);
    tolua_variable(tolua_S,"velocity",tolua_get_Platformer__BulletDef_velocity,NULL);
    tolua_function(tolua_S,"setAsCircle",tolua_LuaBinding_Platformer_BulletDef_setAsCircle00);
    tolua_function(tolua_S,"setVelocity",tolua_LuaBinding_Platformer_BulletDef_setVelocity00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_BulletDef_new00_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::Unit","Unit","Body",tolua_collect_object);
   tolua_beginmodule(tolua_S,"Unit");
    tolua_constant(tolua_S,"GroundSensorTag",lua_Integer(Platformer::Unit::GroundSensorTag));
    tolua_constant(tolua_S,"DetectSensorTag",lua_Integer(Platformer::Unit::DetectSensorTag));
    tolua_constant(tolua_S,"AttackSensorTag",lua_Integer(Platformer::Unit::AttackSensorTag));
    tolua_variable(tolua_S,"playable",tolua_get_Platformer__Unit_playable_ptr,tolua_set_Platformer__Unit_playable_ptr);
    tolua_variable(tolua_S,"detectDistance",tolua_get_Platformer__Unit_detectDistance,tolua_set_Platformer__Unit_detectDistance);
    tolua_variable(tolua_S,"attackRange",tolua_get_Platformer__Unit_attackRange,tolua_set_Platformer__Unit_attackRange);
    tolua_variable(tolua_S,"faceRight",tolua_get_Platformer__Unit_faceRight,tolua_set_Platformer__Unit_faceRight);
    tolua_variable(tolua_S,"receivingDecisionTrace",tolua_get_Platformer__Unit_receivingDecisionTrace,tolua_set_Platformer__Unit_receivingDecisionTrace);
    tolua_variable(tolua_S,"decisionTree",tolua_get_Platformer__Unit_decisionTree,tolua_set_Platformer__Unit_decisionTree);
    tolua_variable(tolua_S,"onSurface",tolua_get_Platformer__Unit_onSurface,NULL);
    tolua_variable(tolua_S,"groundSensor",tolua_get_Platformer__Unit_groundSensor_ptr,NULL);
    tolua_variable(tolua_S,"detectSensor",tolua_get_Platformer__Unit_detectSensor_ptr,NULL);
    tolua_variable(tolua_S,"attackSensor",tolua_get_Platformer__Unit_attackSensor_ptr,NULL);
    tolua_variable(tolua_S,"unitDef",tolua_get_Platformer__Unit_unitDef_ptr,NULL);
    tolua_variable(tolua_S,"currentAction",tolua_get_Platformer__Unit_currentAction_ptr,NULL);
    tolua_variable(tolua_S,"width",tolua_get_Platformer__Unit_width,NULL);
    tolua_variable(tolua_S,"height",tolua_get_Platformer__Unit_height,NULL);
    tolua_variable(tolua_S,"entity",tolua_get_Platformer__Unit_entity_ptr,NULL);
    tolua_function(tolua_S,"attachAction",tolua_LuaBinding_Platformer_Unit_attachAction00);
    tolua_function(tolua_S,"removeAction",tolua_LuaBinding_Platformer_Unit_removeAction00);
    tolua_function(tolua_S,"removeAllActions",tolua_LuaBinding_Platformer_Unit_removeAllActions00);
    tolua_function(tolua_S,"getAction",tolua_LuaBinding_Platformer_Unit_getAction00);
    tolua_function(tolua_S,"eachAction",tolua_LuaBinding_Platformer_Unit_eachAction00);
    tolua_function(tolua_S,"start",tolua_LuaBinding_Platformer_Unit_start00);
    tolua_function(tolua_S,"stop",tolua_LuaBinding_Platformer_Unit_stop00);
    tolua_function(tolua_S,"isDoing",tolua_LuaBinding_Platformer_Unit_isDoing00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Unit_new01_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::Bullet","Bullet","Body",tolua_collect_object);
   tolua_beginmodule(tolua_S,"Bullet");
    tolua_variable(tolua_S,"targetAllow",tolua_get_Platformer__Bullet_targetAllow,tolua_set_Platformer__Bullet_targetAllow);
    tolua_variable(tolua_S,"faceRight",tolua_get_Platformer__Bullet_faceRight,NULL);
    tolua_variable(tolua_S,"hitStop",tolua_get_Platformer__Bullet_hitStop,tolua_set_Platformer__Bullet_hitStop);
    tolua_variable(tolua_S,"emitter",tolua_get_Platformer__Bullet_emitter_ptr,NULL);
    tolua_variable(tolua_S,"bulletDef",tolua_get_Platformer__Bullet_bulletDef_ptr,NULL);
    tolua_variable(tolua_S,"face",tolua_get_Platformer__Bullet_face_ptr,tolua_set_Platformer__Bullet_face_ptr);
    tolua_function(tolua_S,"destroy",tolua_LuaBinding_Platformer_Bullet_destroy00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Bullet_new00_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::Visual","Visual","Node",tolua_collect_object);
   tolua_beginmodule(tolua_S,"Visual");
    tolua_variable(tolua_S,"playing",tolua_get_Platformer__Visual_playing,NULL);
    tolua_function(tolua_S,"start",tolua_LuaBinding_Platformer_Visual_start00);
    tolua_function(tolua_S,"stop",tolua_LuaBinding_Platformer_Visual_stop00);
    tolua_function(tolua_S,"autoRemove",tolua_LuaBinding_Platformer_Visual_autoRemove00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Visual_new00_local);
   tolua_endmodule(tolua_S);
   tolua_module(tolua_S,"Behavior",0);
   tolua_beginmodule(tolua_S,"Behavior");
    tolua_cclass(tolua_S,"Platformer::Behavior::Blackboard","Blackboard","",NULL);
    tolua_beginmodule(tolua_S,"Blackboard");
     tolua_variable(tolua_S,"deltaTime",tolua_get_Platformer__Behavior__Blackboard_deltaTime,NULL);
     tolua_variable(tolua_S,"owner",tolua_get_Platformer__Behavior__Blackboard_owner_ptr,NULL);
    tolua_endmodule(tolua_S);
    tolua_cclass(tolua_S,"Platformer::Behavior::Leaf","Leaf","Object",tolua_collect_object);
    tolua_beginmodule(tolua_S,"Leaf");
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"Seq",tolua_LuaBinding_Platformer_Behavior_Seq00);
    tolua_function(tolua_S,"Sel",tolua_LuaBinding_Platformer_Behavior_Sel00);
    tolua_function(tolua_S,"Con",tolua_LuaBinding_Platformer_Behavior_Con00);
    tolua_function(tolua_S,"Act",tolua_LuaBinding_Platformer_Behavior_Act00);
    tolua_function(tolua_S,"Command",tolua_LuaBinding_Platformer_Behavior_Command00);
    tolua_function(tolua_S,"Wait",tolua_LuaBinding_Platformer_Behavior_Wait00);
    tolua_function(tolua_S,"Countdown",tolua_LuaBinding_Platformer_Behavior_Countdown00);
    tolua_function(tolua_S,"Timeout",tolua_LuaBinding_Platformer_Behavior_Timeout00);
    tolua_function(tolua_S,"Repeat",tolua_LuaBinding_Platformer_Behavior_Repeat00);
    tolua_function(tolua_S,"Repeat",tolua_LuaBinding_Platformer_Behavior_Repeat01);
    tolua_function(tolua_S,"Retry",tolua_LuaBinding_Platformer_Behavior_Retry00);
    tolua_function(tolua_S,"Retry",tolua_LuaBinding_Platformer_Behavior_Retry01);
   tolua_endmodule(tolua_S);
   tolua_module(tolua_S,"Decision",0);
   tolua_beginmodule(tolua_S,"Decision");
    tolua_cclass(tolua_S,"Platformer::Decision::Leaf","Leaf","Object",tolua_collect_object);
    tolua_beginmodule(tolua_S,"Leaf");
    tolua_endmodule(tolua_S);
    tolua_function(tolua_S,"Sel",tolua_LuaBinding_Platformer_Decision_Sel00);
    tolua_function(tolua_S,"Seq",tolua_LuaBinding_Platformer_Decision_Seq00);
    tolua_function(tolua_S,"Con",tolua_LuaBinding_Platformer_Decision_Con00);
    tolua_function(tolua_S,"Act",tolua_LuaBinding_Platformer_Decision_Act00);
    tolua_function(tolua_S,"Act",tolua_LuaBinding_Platformer_Decision_Act01);
    tolua_function(tolua_S,"Accept",tolua_LuaBinding_Platformer_Decision_Accept00);
    tolua_function(tolua_S,"Reject",tolua_LuaBinding_Platformer_Decision_Reject00);
    tolua_function(tolua_S,"Behave",tolua_LuaBinding_Platformer_Decision_Behave00);
    tolua_cclass(tolua_S,"Platformer::Decision::AI","AI","",NULL);
    tolua_beginmodule(tolua_S,"AI");
     tolua_function(tolua_S,"getUnitsByRelation",tolua_LuaBinding_Platformer_Decision_AI_getUnitsByRelation00);
     tolua_function(tolua_S,"getDetectedUnits",tolua_LuaBinding_Platformer_Decision_AI_getDetectedUnits00);
     tolua_function(tolua_S,"getDetectedBodies",tolua_LuaBinding_Platformer_Decision_AI_getDetectedBodies00);
     tolua_function(tolua_S,"getNearestUnit",tolua_LuaBinding_Platformer_Decision_AI_getNearestUnit00);
     tolua_function(tolua_S,"getNearestUnitDistance",tolua_LuaBinding_Platformer_Decision_AI_getNearestUnitDistance00);
     tolua_function(tolua_S,"getUnitsInAttackRange",tolua_LuaBinding_Platformer_Decision_AI_getUnitsInAttackRange00);
     tolua_function(tolua_S,"getBodiesInAttackRange",tolua_LuaBinding_Platformer_Decision_AI_getBodiesInAttackRange00);
     tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Decision_AI_new00_local);
    tolua_endmodule(tolua_S);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::UnitAction","UnitAction","",NULL);
   tolua_beginmodule(tolua_S,"UnitAction");
    tolua_variable(tolua_S,"reaction",tolua_get_Platformer__UnitAction_reaction,tolua_set_Platformer__UnitAction_reaction);
    tolua_variable(tolua_S,"recovery",tolua_get_Platformer__UnitAction_recovery,tolua_set_Platformer__UnitAction_recovery);
    tolua_variable(tolua_S,"name",tolua_get_Platformer__UnitAction_name,NULL);
    tolua_variable(tolua_S,"doing",tolua_get_Platformer__UnitAction_doing,NULL);
    tolua_variable(tolua_S,"owner",tolua_get_Platformer__UnitAction_owner_ptr,NULL);
    tolua_variable(tolua_S,"elapsedTime",tolua_get_Platformer__UnitAction_elapsedTime,NULL);
    tolua_function(tolua_S,"add",tolua_LuaBinding_Platformer_UnitAction_add00);
    tolua_function(tolua_S,"clear",tolua_LuaBinding_Platformer_UnitAction_clear00);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::PlatformWorld","PlatformWorld","PhysicsWorld",tolua_collect_object);
   tolua_beginmodule(tolua_S,"PlatformWorld");
    tolua_variable(tolua_S,"camera",tolua_get_Platformer__PlatformWorld_camera_ptr,NULL);
    tolua_function(tolua_S,"moveChild",tolua_LuaBinding_Platformer_PlatformWorld_moveChild00);
    tolua_function(tolua_S,"getLayer",tolua_LuaBinding_Platformer_PlatformWorld_getLayer00);
    tolua_function(tolua_S,"setLayerRatio",tolua_LuaBinding_Platformer_PlatformWorld_setLayerRatio00);
    tolua_function(tolua_S,"getLayerRatio",tolua_LuaBinding_Platformer_PlatformWorld_getLayerRatio00);
    tolua_function(tolua_S,"setLayerOffset",tolua_LuaBinding_Platformer_PlatformWorld_setLayerOffset00);
    tolua_function(tolua_S,"getLayerOffset",tolua_LuaBinding_Platformer_PlatformWorld_getLayerOffset00);
    tolua_function(tolua_S,"swapLayer",tolua_LuaBinding_Platformer_PlatformWorld_swapLayer00);
    tolua_function(tolua_S,"removeLayer",tolua_LuaBinding_Platformer_PlatformWorld_removeLayer00);
    tolua_function(tolua_S,"removeAllLayers",tolua_LuaBinding_Platformer_PlatformWorld_removeAllLayers00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_PlatformWorld_new00_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::PlatformCamera","PlatformCamera","Camera",tolua_collect_object);
   tolua_beginmodule(tolua_S,"PlatformCamera");
    tolua_variable(tolua_S,"position",tolua_get_Platformer__PlatformCamera_position,tolua_set_Platformer__PlatformCamera_position);
    tolua_variable(tolua_S,"rotation",tolua_get_Platformer__PlatformCamera_rotation,tolua_set_Platformer__PlatformCamera_rotation);
    tolua_variable(tolua_S,"zoom",tolua_get_Platformer__PlatformCamera_zoom,tolua_set_Platformer__PlatformCamera_zoom);
    tolua_variable(tolua_S,"boundary",tolua_get_Platformer__PlatformCamera_boundary,tolua_set_Platformer__PlatformCamera_boundary);
    tolua_variable(tolua_S,"followRatio",tolua_get_Platformer__PlatformCamera_followRatio,tolua_set_Platformer__PlatformCamera_followRatio);
    tolua_variable(tolua_S,"followOffset",tolua_get_Platformer__PlatformCamera_followOffset,tolua_set_Platformer__PlatformCamera_followOffset);
    tolua_variable(tolua_S,"followTarget",tolua_get_Platformer__PlatformCamera_followTarget_ptr,tolua_set_Platformer__PlatformCamera_followTarget_ptr);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_PlatformCamera_new00_local);
   tolua_endmodule(tolua_S);
   tolua_cclass(tolua_S,"Platformer::Data","Data","",NULL);
   tolua_beginmodule(tolua_S,"Data");
    tolua_variable(tolua_S,"groupFirstPlayer",tolua_get_Platformer__Data_groupFirstPlayer,NULL);
    tolua_variable(tolua_S,"groupLastPlayer",tolua_get_Platformer__Data_groupLastPlayer,NULL);
    tolua_variable(tolua_S,"groupHide",tolua_get_Platformer__Data_groupHide,NULL);
    tolua_variable(tolua_S,"groupDetectPlayer",tolua_get_Platformer__Data_groupDetectPlayer,NULL);
    tolua_variable(tolua_S,"groupTerrain",tolua_get_Platformer__Data_groupTerrain,NULL);
    tolua_variable(tolua_S,"groupDetection",tolua_get_Platformer__Data_groupDetection,NULL);
    tolua_variable(tolua_S,"store",tolua_get_Platformer__Data_store_ptr,NULL);
    tolua_function(tolua_S,"setShouldContact",tolua_LuaBinding_Platformer_Data_setShouldContact00);
    tolua_function(tolua_S,"getShouldContact",tolua_LuaBinding_Platformer_Data_getShouldContact00);
    tolua_function(tolua_S,"setRelation",tolua_LuaBinding_Platformer_Data_setRelation00);
    tolua_function(tolua_S,"getRelation",tolua_LuaBinding_Platformer_Data_getRelation01);
    tolua_function(tolua_S,"isEnemy",tolua_LuaBinding_Platformer_Data_isEnemy01);
    tolua_function(tolua_S,"isFriend",tolua_LuaBinding_Platformer_Data_isFriend01);
    tolua_function(tolua_S,"isNeutral",tolua_LuaBinding_Platformer_Data_isNeutral01);
    tolua_function(tolua_S,"setDamageFactor",tolua_LuaBinding_Platformer_Data_setDamageFactor00);
    tolua_function(tolua_S,"getDamageFactor",tolua_LuaBinding_Platformer_Data_getDamageFactor00);
    tolua_function(tolua_S,"isPlayer",tolua_LuaBinding_Platformer_Data_isPlayer00);
    tolua_function(tolua_S,"isTerrain",tolua_LuaBinding_Platformer_Data_isTerrain00);
    tolua_function(tolua_S,"clear",tolua_LuaBinding_Platformer_Data_clear00);
    tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Platformer_Data_new00_local);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"Buffer","Buffer","Object",tolua_collect_object);
  tolua_beginmodule(tolua_S,"Buffer");
   tolua_function(tolua_S,"resize",tolua_LuaBinding_Buffer_resize00);
   tolua_function(tolua_S,"zeroMemory",tolua_LuaBinding_Buffer_zeroMemory00);
   tolua_variable(tolua_S,"size",tolua_get_Buffer_size,NULL);
   tolua_variable(tolua_S,"text",tolua_get_Buffer_text,tolua_set_Buffer_text);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_Buffer_new00_local);
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"ImGui",0);
  tolua_beginmodule(tolua_S,"ImGui");
   tolua_function(tolua_S,"SetDefaultFont",tolua_LuaBinding_ImGui_SetDefaultFont00);
   tolua_function(tolua_S,"ShowStats",tolua_LuaBinding_ImGui_ShowStats00);
   tolua_function(tolua_S,"ShowStats",tolua_LuaBinding_ImGui_ShowStats01);
   tolua_function(tolua_S,"ShowConsole",tolua_LuaBinding_ImGui_ShowConsole00);
   tolua_function(tolua_S,"Begin",tolua_LuaBinding_ImGui_Begin00);
   tolua_function(tolua_S,"Begin",tolua_LuaBinding_ImGui_Begin01);
   tolua_function(tolua_S,"Begin",tolua_LuaBinding_ImGui_Begin02);
   tolua_function(tolua_S,"Begin",tolua_LuaBinding_ImGui_Begin03);
   tolua_function(tolua_S,"BeginChild",tolua_LuaBinding_ImGui_BeginChild00);
   tolua_function(tolua_S,"BeginChild",tolua_LuaBinding_ImGui_BeginChild01);
   tolua_function(tolua_S,"BeginChild",tolua_LuaBinding_ImGui_BeginChild02);
   tolua_function(tolua_S,"BeginChild",tolua_LuaBinding_ImGui_BeginChild03);
   tolua_function(tolua_S,"SetNextWindowPos",tolua_LuaBinding_ImGui_SetNextWindowPos00);
   tolua_function(tolua_S,"SetNextWindowPosCenter",tolua_LuaBinding_ImGui_SetNextWindowPosCenter00);
   tolua_function(tolua_S,"SetNextWindowSize",tolua_LuaBinding_ImGui_SetNextWindowSize00);
   tolua_function(tolua_S,"SetNextWindowCollapsed",tolua_LuaBinding_ImGui_SetNextWindowCollapsed00);
   tolua_function(tolua_S,"SetWindowPos",tolua_LuaBinding_ImGui_SetWindowPos00);
   tolua_function(tolua_S,"SetWindowSize",tolua_LuaBinding_ImGui_SetWindowSize00);
   tolua_function(tolua_S,"SetWindowCollapsed",tolua_LuaBinding_ImGui_SetWindowCollapsed00);
   tolua_function(tolua_S,"SetColorEditOptions",tolua_LuaBinding_ImGui_SetColorEditOptions00);
   tolua_function(tolua_S,"InputText",tolua_LuaBinding_ImGui_InputText00);
   tolua_function(tolua_S,"InputText",tolua_LuaBinding_ImGui_InputText01);
   tolua_function(tolua_S,"InputTextMultiline",tolua_LuaBinding_ImGui_InputTextMultiline00);
   tolua_function(tolua_S,"InputTextMultiline",tolua_LuaBinding_ImGui_InputTextMultiline01);
   tolua_function(tolua_S,"TreeNodeEx",tolua_LuaBinding_ImGui_TreeNodeEx00);
   tolua_function(tolua_S,"TreeNodeEx",tolua_LuaBinding_ImGui_TreeNodeEx01);
   tolua_function(tolua_S,"TreeNodeEx",tolua_LuaBinding_ImGui_TreeNodeEx02);
   tolua_function(tolua_S,"TreeNodeEx",tolua_LuaBinding_ImGui_TreeNodeEx03);
   tolua_function(tolua_S,"SetNextItemOpen",tolua_LuaBinding_ImGui_SetNextItemOpen00);
   tolua_function(tolua_S,"CollapsingHeader",tolua_LuaBinding_ImGui_CollapsingHeader00);
   tolua_function(tolua_S,"CollapsingHeader",tolua_LuaBinding_ImGui_CollapsingHeader01);
   tolua_function(tolua_S,"CollapsingHeader",tolua_LuaBinding_ImGui_CollapsingHeader02);
   tolua_function(tolua_S,"CollapsingHeader",tolua_LuaBinding_ImGui_CollapsingHeader03);
   tolua_function(tolua_S,"Selectable",tolua_LuaBinding_ImGui_Selectable00);
   tolua_function(tolua_S,"Selectable",tolua_LuaBinding_ImGui_Selectable01);
   tolua_function(tolua_S,"Selectable",tolua_LuaBinding_ImGui_Selectable02);
   tolua_function(tolua_S,"Selectable",tolua_LuaBinding_ImGui_Selectable03);
   tolua_function(tolua_S,"BeginPopupModal",tolua_LuaBinding_ImGui_BeginPopupModal00);
   tolua_function(tolua_S,"BeginPopupModal",tolua_LuaBinding_ImGui_BeginPopupModal01);
   tolua_function(tolua_S,"BeginPopupModal",tolua_LuaBinding_ImGui_BeginPopupModal02);
   tolua_function(tolua_S,"BeginPopupModal",tolua_LuaBinding_ImGui_BeginPopupModal03);
   tolua_function(tolua_S,"PushStyleColor",tolua_LuaBinding_ImGui_PushStyleColor00);
   tolua_function(tolua_S,"PushStyleVar",tolua_LuaBinding_ImGui_PushStyleVar00);
   tolua_function(tolua_S,"PushStyleVar",tolua_LuaBinding_ImGui_PushStyleVar01);
   tolua_function(tolua_S,"Text",tolua_LuaBinding_ImGui_Text00);
   tolua_function(tolua_S,"TextColored",tolua_LuaBinding_ImGui_TextColored00);
   tolua_function(tolua_S,"TextDisabled",tolua_LuaBinding_ImGui_TextDisabled00);
   tolua_function(tolua_S,"TextWrapped",tolua_LuaBinding_ImGui_TextWrapped00);
   tolua_function(tolua_S,"LabelText",tolua_LuaBinding_ImGui_LabelText00);
   tolua_function(tolua_S,"BulletText",tolua_LuaBinding_ImGui_BulletText00);
   tolua_function(tolua_S,"TreeNode",tolua_LuaBinding_ImGui_TreeNode00);
   tolua_function(tolua_S,"SetTooltip",tolua_LuaBinding_ImGui_SetTooltip00);
   tolua_function(tolua_S,"ColorEdit3",tolua_LuaBinding_ImGui_ColorEdit300);
   tolua_function(tolua_S,"ColorEdit3",tolua_LuaBinding_ImGui_ColorEdit301);
   tolua_function(tolua_S,"ColorEdit4",tolua_LuaBinding_ImGui_ColorEdit400);
   tolua_function(tolua_S,"ColorEdit4",tolua_LuaBinding_ImGui_ColorEdit401);
   tolua_function(tolua_S,"Image",tolua_LuaBinding_ImGui_Image00);
   tolua_function(tolua_S,"Image",tolua_LuaBinding_ImGui_Image01);
   tolua_function(tolua_S,"Image",tolua_LuaBinding_ImGui_Image02);
   tolua_function(tolua_S,"ImageButton",tolua_LuaBinding_ImGui_ImageButton00);
   tolua_function(tolua_S,"ImageButton",tolua_LuaBinding_ImGui_ImageButton01);
   tolua_function(tolua_S,"ImageButton",tolua_LuaBinding_ImGui_ImageButton02);
   tolua_function(tolua_S,"ColorButton",tolua_LuaBinding_ImGui_ColorButton00);
   tolua_function(tolua_S,"ColorButton",tolua_LuaBinding_ImGui_ColorButton01);
   tolua_function(tolua_S,"Columns",tolua_LuaBinding_ImGui_Columns00);
   tolua_function(tolua_S,"Columns",tolua_LuaBinding_ImGui_Columns01);
   tolua_function(tolua_S,"BeginTable",tolua_LuaBinding_ImGui_BeginTable00);
   tolua_function(tolua_S,"BeginTable",tolua_LuaBinding_ImGui_BeginTable01);
   tolua_function(tolua_S,"TableNextRow",tolua_LuaBinding_ImGui_TableNextRow00);
   tolua_function(tolua_S,"TableSetupColumn",tolua_LuaBinding_ImGui_TableSetupColumn00);
   tolua_function(tolua_S,"TableSetupColumn",tolua_LuaBinding_ImGui_TableSetupColumn01);
   tolua_function(tolua_S,"SetStyleVar",tolua_LuaBinding_ImGui_SetStyleVar00);
   tolua_function(tolua_S,"SetStyleVar",tolua_LuaBinding_ImGui_SetStyleVar01);
   tolua_function(tolua_S,"SetStyleVar",tolua_LuaBinding_ImGui_SetStyleVar02);
   tolua_function(tolua_S,"SetStyleColor",tolua_LuaBinding_ImGui_SetStyleColor00);
   tolua_function(tolua_S,"Combo",tolua_LuaBinding_ImGui_Combo00);
   tolua_function(tolua_S,"DragFloat",tolua_LuaBinding_ImGui_DragFloat00);
   tolua_function(tolua_S,"DragFloat",tolua_LuaBinding_ImGui_DragFloat01);
   tolua_function(tolua_S,"DragFloat2",tolua_LuaBinding_ImGui_DragFloat200);
   tolua_function(tolua_S,"DragFloat2",tolua_LuaBinding_ImGui_DragFloat201);
   tolua_function(tolua_S,"DragInt",tolua_LuaBinding_ImGui_DragInt00);
   tolua_function(tolua_S,"DragInt",tolua_LuaBinding_ImGui_DragInt01);
   tolua_function(tolua_S,"DragInt2",tolua_LuaBinding_ImGui_DragInt200);
   tolua_function(tolua_S,"DragInt2",tolua_LuaBinding_ImGui_DragInt201);
   tolua_function(tolua_S,"InputFloat",tolua_LuaBinding_ImGui_InputFloat00);
   tolua_function(tolua_S,"InputFloat",tolua_LuaBinding_ImGui_InputFloat01);
   tolua_function(tolua_S,"InputFloat2",tolua_LuaBinding_ImGui_InputFloat200);
   tolua_function(tolua_S,"InputFloat2",tolua_LuaBinding_ImGui_InputFloat201);
   tolua_function(tolua_S,"InputInt",tolua_LuaBinding_ImGui_InputInt00);
   tolua_function(tolua_S,"InputInt",tolua_LuaBinding_ImGui_InputInt01);
   tolua_function(tolua_S,"InputInt2",tolua_LuaBinding_ImGui_InputInt200);
   tolua_function(tolua_S,"InputInt2",tolua_LuaBinding_ImGui_InputInt201);
   tolua_function(tolua_S,"SliderFloat",tolua_LuaBinding_ImGui_SliderFloat00);
   tolua_function(tolua_S,"SliderFloat",tolua_LuaBinding_ImGui_SliderFloat01);
   tolua_function(tolua_S,"SliderFloat2",tolua_LuaBinding_ImGui_SliderFloat200);
   tolua_function(tolua_S,"SliderFloat2",tolua_LuaBinding_ImGui_SliderFloat201);
   tolua_function(tolua_S,"SliderInt",tolua_LuaBinding_ImGui_SliderInt00);
   tolua_function(tolua_S,"SliderInt",tolua_LuaBinding_ImGui_SliderInt01);
   tolua_function(tolua_S,"SliderInt2",tolua_LuaBinding_ImGui_SliderInt200);
   tolua_function(tolua_S,"SliderInt2",tolua_LuaBinding_ImGui_SliderInt201);
   tolua_function(tolua_S,"DragFloatRange2",tolua_LuaBinding_ImGui_DragFloatRange200);
   tolua_function(tolua_S,"DragFloatRange2",tolua_LuaBinding_ImGui_DragFloatRange201);
   tolua_function(tolua_S,"DragIntRange2",tolua_LuaBinding_ImGui_DragIntRange200);
   tolua_function(tolua_S,"DragIntRange2",tolua_LuaBinding_ImGui_DragIntRange201);
   tolua_function(tolua_S,"VSliderFloat",tolua_LuaBinding_ImGui_VSliderFloat00);
   tolua_function(tolua_S,"VSliderFloat",tolua_LuaBinding_ImGui_VSliderFloat01);
   tolua_function(tolua_S,"VSliderInt",tolua_LuaBinding_ImGui_VSliderInt00);
   tolua_function(tolua_S,"VSliderInt",tolua_LuaBinding_ImGui_VSliderInt01);
   tolua_function(tolua_S,"ScrollWhenDraggingOnVoid",tolua_LuaBinding_ImGui_ScrollWhenDraggingOnVoid00);
   tolua_function(tolua_S,"SetNextWindowBgAlpha",tolua_LuaBinding_ImGui_SetNextWindowBgAlpha00);
   tolua_function(tolua_S,"ShowDemoWindow",tolua_LuaBinding_ImGui_ShowDemoWindow00);
   tolua_function(tolua_S,"End",tolua_LuaBinding_ImGui_End00);
   tolua_function(tolua_S,"EndChild",tolua_LuaBinding_ImGui_EndChild00);
   tolua_function(tolua_S,"GetContentRegionAvail",tolua_LuaBinding_ImGui_GetContentRegionAvail00);
   tolua_function(tolua_S,"GetWindowPos",tolua_LuaBinding_ImGui_GetWindowPos00);
   tolua_function(tolua_S,"GetWindowSize",tolua_LuaBinding_ImGui_GetWindowSize00);
   tolua_function(tolua_S,"GetWindowWidth",tolua_LuaBinding_ImGui_GetWindowWidth00);
   tolua_function(tolua_S,"GetWindowHeight",tolua_LuaBinding_ImGui_GetWindowHeight00);
   tolua_function(tolua_S,"IsWindowCollapsed",tolua_LuaBinding_ImGui_IsWindowCollapsed00);
   tolua_function(tolua_S,"SetNextWindowSizeConstraints",tolua_LuaBinding_ImGui_SetNextWindowSizeConstraints00);
   tolua_function(tolua_S,"SetNextWindowContentSize",tolua_LuaBinding_ImGui_SetNextWindowContentSize00);
   tolua_function(tolua_S,"SetNextWindowFocus",tolua_LuaBinding_ImGui_SetNextWindowFocus00);
   tolua_function(tolua_S,"SetWindowFocus",tolua_LuaBinding_ImGui_SetWindowFocus00);
   tolua_function(tolua_S,"GetScrollX",tolua_LuaBinding_ImGui_GetScrollX00);
   tolua_function(tolua_S,"GetScrollY",tolua_LuaBinding_ImGui_GetScrollY00);
   tolua_function(tolua_S,"GetScrollMaxX",tolua_LuaBinding_ImGui_GetScrollMaxX00);
   tolua_function(tolua_S,"GetScrollMaxY",tolua_LuaBinding_ImGui_GetScrollMaxY00);
   tolua_function(tolua_S,"SetScrollX",tolua_LuaBinding_ImGui_SetScrollX00);
   tolua_function(tolua_S,"SetScrollY",tolua_LuaBinding_ImGui_SetScrollY00);
   tolua_function(tolua_S,"SetScrollHereY",tolua_LuaBinding_ImGui_SetScrollHereY00);
   tolua_function(tolua_S,"SetScrollFromPosY",tolua_LuaBinding_ImGui_SetScrollFromPosY00);
   tolua_function(tolua_S,"SetKeyboardFocusHere",tolua_LuaBinding_ImGui_SetKeyboardFocusHere00);
   tolua_function(tolua_S,"PopStyleColor",tolua_LuaBinding_ImGui_PopStyleColor00);
   tolua_function(tolua_S,"PopStyleVar",tolua_LuaBinding_ImGui_PopStyleVar00);
   tolua_function(tolua_S,"SetNextItemWidth",tolua_LuaBinding_ImGui_SetNextItemWidth00);
   tolua_function(tolua_S,"PushItemWidth",tolua_LuaBinding_ImGui_PushItemWidth00);
   tolua_function(tolua_S,"PopItemWidth",tolua_LuaBinding_ImGui_PopItemWidth00);
   tolua_function(tolua_S,"CalcItemWidth",tolua_LuaBinding_ImGui_CalcItemWidth00);
   tolua_function(tolua_S,"PushTextWrapPos",tolua_LuaBinding_ImGui_PushTextWrapPos00);
   tolua_function(tolua_S,"PopTextWrapPos",tolua_LuaBinding_ImGui_PopTextWrapPos00);
   tolua_function(tolua_S,"PushItemFlag",tolua_LuaBinding_ImGui_PushItemFlag00);
   tolua_function(tolua_S,"PopItemFlag",tolua_LuaBinding_ImGui_PopItemFlag00);
   tolua_function(tolua_S,"Separator",tolua_LuaBinding_ImGui_Separator00);
   tolua_function(tolua_S,"SeparatorText",tolua_LuaBinding_ImGui_SeparatorText00);
   tolua_function(tolua_S,"SameLine",tolua_LuaBinding_ImGui_SameLine00);
   tolua_function(tolua_S,"NewLine",tolua_LuaBinding_ImGui_NewLine00);
   tolua_function(tolua_S,"Spacing",tolua_LuaBinding_ImGui_Spacing00);
   tolua_function(tolua_S,"Dummy",tolua_LuaBinding_ImGui_Dummy00);
   tolua_function(tolua_S,"Indent",tolua_LuaBinding_ImGui_Indent00);
   tolua_function(tolua_S,"Unindent",tolua_LuaBinding_ImGui_Unindent00);
   tolua_function(tolua_S,"BeginGroup",tolua_LuaBinding_ImGui_BeginGroup00);
   tolua_function(tolua_S,"EndGroup",tolua_LuaBinding_ImGui_EndGroup00);
   tolua_function(tolua_S,"GetCursorPos",tolua_LuaBinding_ImGui_GetCursorPos00);
   tolua_function(tolua_S,"GetCursorPosX",tolua_LuaBinding_ImGui_GetCursorPosX00);
   tolua_function(tolua_S,"GetCursorPosY",tolua_LuaBinding_ImGui_GetCursorPosY00);
   tolua_function(tolua_S,"SetCursorPos",tolua_LuaBinding_ImGui_SetCursorPos00);
   tolua_function(tolua_S,"SetCursorPosX",tolua_LuaBinding_ImGui_SetCursorPosX00);
   tolua_function(tolua_S,"SetCursorPosY",tolua_LuaBinding_ImGui_SetCursorPosY00);
   tolua_function(tolua_S,"GetCursorStartPos",tolua_LuaBinding_ImGui_GetCursorStartPos00);
   tolua_function(tolua_S,"GetCursorScreenPos",tolua_LuaBinding_ImGui_GetCursorScreenPos00);
   tolua_function(tolua_S,"SetCursorScreenPos",tolua_LuaBinding_ImGui_SetCursorScreenPos00);
   tolua_function(tolua_S,"AlignTextToFramePadding",tolua_LuaBinding_ImGui_AlignTextToFramePadding00);
   tolua_function(tolua_S,"GetTextLineHeight",tolua_LuaBinding_ImGui_GetTextLineHeight00);
   tolua_function(tolua_S,"GetTextLineHeightWithSpacing",tolua_LuaBinding_ImGui_GetTextLineHeightWithSpacing00);
   tolua_function(tolua_S,"NextColumn",tolua_LuaBinding_ImGui_NextColumn00);
   tolua_function(tolua_S,"GetColumnIndex",tolua_LuaBinding_ImGui_GetColumnIndex00);
   tolua_function(tolua_S,"GetColumnOffset",tolua_LuaBinding_ImGui_GetColumnOffset00);
   tolua_function(tolua_S,"SetColumnOffset",tolua_LuaBinding_ImGui_SetColumnOffset00);
   tolua_function(tolua_S,"GetColumnWidth",tolua_LuaBinding_ImGui_GetColumnWidth00);
   tolua_function(tolua_S,"GetColumnsCount",tolua_LuaBinding_ImGui_GetColumnsCount00);
   tolua_function(tolua_S,"EndTable",tolua_LuaBinding_ImGui_EndTable00);
   tolua_function(tolua_S,"TableNextColumn",tolua_LuaBinding_ImGui_TableNextColumn00);
   tolua_function(tolua_S,"TableSetColumnIndex",tolua_LuaBinding_ImGui_TableSetColumnIndex00);
   tolua_function(tolua_S,"TableSetupScrollFreeze",tolua_LuaBinding_ImGui_TableSetupScrollFreeze00);
   tolua_function(tolua_S,"TableHeadersRow",tolua_LuaBinding_ImGui_TableHeadersRow00);
   tolua_function(tolua_S,"TableHeader",tolua_LuaBinding_ImGui_TableHeader00);
   tolua_function(tolua_S,"PushID",tolua_LuaBinding_ImGui_PushID00);
   tolua_function(tolua_S,"PushID",tolua_LuaBinding_ImGui_PushID01);
   tolua_function(tolua_S,"PopID",tolua_LuaBinding_ImGui_PopID00);
   tolua_function(tolua_S,"GetID",tolua_LuaBinding_ImGui_GetID00);
   tolua_function(tolua_S,"BulletItem",tolua_LuaBinding_ImGui_BulletItem00);
   tolua_function(tolua_S,"TextLink",tolua_LuaBinding_ImGui_TextLink00);
   tolua_function(tolua_S,"Button",tolua_LuaBinding_ImGui_Button00);
   tolua_function(tolua_S,"SmallButton",tolua_LuaBinding_ImGui_SmallButton00);
   tolua_function(tolua_S,"InvisibleButton",tolua_LuaBinding_ImGui_InvisibleButton00);
   tolua_function(tolua_S,"Checkbox",tolua_LuaBinding_ImGui_Checkbox00);
   tolua_function(tolua_S,"RadioButton",tolua_LuaBinding_ImGui_RadioButton00);
   tolua_function(tolua_S,"RadioButton",tolua_LuaBinding_ImGui_RadioButton01);
   tolua_function(tolua_S,"PlotLines",tolua_LuaBinding_ImGui_PlotLines00);
   tolua_function(tolua_S,"PlotHistogram",tolua_LuaBinding_ImGui_PlotHistogram00);
   tolua_function(tolua_S,"ProgressBar",tolua_LuaBinding_ImGui_ProgressBar00);
   tolua_function(tolua_S,"ProgressBar",tolua_LuaBinding_ImGui_ProgressBar01);
   tolua_function(tolua_S,"ListBox",tolua_LuaBinding_ImGui_ListBox00);
   tolua_function(tolua_S,"SliderAngle",tolua_LuaBinding_ImGui_SliderAngle00);
   tolua_function(tolua_S,"TreeNode",tolua_LuaBinding_ImGui_TreeNode01);
   tolua_function(tolua_S,"TreePush",tolua_LuaBinding_ImGui_TreePush00);
   tolua_function(tolua_S,"TreePop",tolua_LuaBinding_ImGui_TreePop00);
   tolua_function(tolua_S,"GetTreeNodeToLabelSpacing",tolua_LuaBinding_ImGui_GetTreeNodeToLabelSpacing00);
   tolua_function(tolua_S,"BeginListBox",tolua_LuaBinding_ImGui_BeginListBox00);
   tolua_function(tolua_S,"EndListBox",tolua_LuaBinding_ImGui_EndListBox00);
   tolua_function(tolua_S,"Value",tolua_LuaBinding_ImGui_Value00);
   tolua_function(tolua_S,"Value",tolua_LuaBinding_ImGui_Value01);
   tolua_function(tolua_S,"Value",tolua_LuaBinding_ImGui_Value02);
   tolua_function(tolua_S,"BeginDisabled",tolua_LuaBinding_ImGui_BeginDisabled00);
   tolua_function(tolua_S,"EndDisabled",tolua_LuaBinding_ImGui_EndDisabled00);
   tolua_function(tolua_S,"BeginTooltip",tolua_LuaBinding_ImGui_BeginTooltip00);
   tolua_function(tolua_S,"EndTooltip",tolua_LuaBinding_ImGui_EndTooltip00);
   tolua_function(tolua_S,"BeginMainMenuBar",tolua_LuaBinding_ImGui_BeginMainMenuBar00);
   tolua_function(tolua_S,"EndMainMenuBar",tolua_LuaBinding_ImGui_EndMainMenuBar00);
   tolua_function(tolua_S,"BeginMenuBar",tolua_LuaBinding_ImGui_BeginMenuBar00);
   tolua_function(tolua_S,"EndMenuBar",tolua_LuaBinding_ImGui_EndMenuBar00);
   tolua_function(tolua_S,"BeginMenu",tolua_LuaBinding_ImGui_BeginMenu00);
   tolua_function(tolua_S,"EndMenu",tolua_LuaBinding_ImGui_EndMenu00);
   tolua_function(tolua_S,"MenuItem",tolua_LuaBinding_ImGui_MenuItem00);
   tolua_function(tolua_S,"MenuItemToggle",tolua_LuaBinding_ImGui_MenuItemToggle00);
   tolua_function(tolua_S,"OpenPopup",tolua_LuaBinding_ImGui_OpenPopup00);
   tolua_function(tolua_S,"BeginPopup",tolua_LuaBinding_ImGui_BeginPopup00);
   tolua_function(tolua_S,"BeginPopupContextItem",tolua_LuaBinding_ImGui_BeginPopupContextItem00);
   tolua_function(tolua_S,"BeginPopupContextItem",tolua_LuaBinding_ImGui_BeginPopupContextItem01);
   tolua_function(tolua_S,"BeginPopupContextWindow",tolua_LuaBinding_ImGui_BeginPopupContextWindow00);
   tolua_function(tolua_S,"BeginPopupContextWindow",tolua_LuaBinding_ImGui_BeginPopupContextWindow01);
   tolua_function(tolua_S,"BeginPopupContextVoid",tolua_LuaBinding_ImGui_BeginPopupContextVoid00);
   tolua_function(tolua_S,"BeginPopupContextVoid",tolua_LuaBinding_ImGui_BeginPopupContextVoid01);
   tolua_function(tolua_S,"EndPopup",tolua_LuaBinding_ImGui_EndPopup00);
   tolua_function(tolua_S,"CloseCurrentPopup",tolua_LuaBinding_ImGui_CloseCurrentPopup00);
   tolua_function(tolua_S,"PushClipRect",tolua_LuaBinding_ImGui_PushClipRect00);
   tolua_function(tolua_S,"PopClipRect",tolua_LuaBinding_ImGui_PopClipRect00);
   tolua_function(tolua_S,"IsItemHovered",tolua_LuaBinding_ImGui_IsItemHovered00);
   tolua_function(tolua_S,"IsItemActive",tolua_LuaBinding_ImGui_IsItemActive00);
   tolua_function(tolua_S,"IsItemClicked",tolua_LuaBinding_ImGui_IsItemClicked00);
   tolua_function(tolua_S,"IsItemVisible",tolua_LuaBinding_ImGui_IsItemVisible00);
   tolua_function(tolua_S,"IsAnyItemHovered",tolua_LuaBinding_ImGui_IsAnyItemHovered00);
   tolua_function(tolua_S,"IsAnyItemActive",tolua_LuaBinding_ImGui_IsAnyItemActive00);
   tolua_function(tolua_S,"GetItemRectMin",tolua_LuaBinding_ImGui_GetItemRectMin00);
   tolua_function(tolua_S,"GetItemRectMax",tolua_LuaBinding_ImGui_GetItemRectMax00);
   tolua_function(tolua_S,"GetItemRectSize",tolua_LuaBinding_ImGui_GetItemRectSize00);
   tolua_function(tolua_S,"SetNextItemAllowOverlap",tolua_LuaBinding_ImGui_SetNextItemAllowOverlap00);
   tolua_function(tolua_S,"IsWindowHovered",tolua_LuaBinding_ImGui_IsWindowHovered00);
   tolua_function(tolua_S,"IsWindowFocused",tolua_LuaBinding_ImGui_IsWindowFocused00);
   tolua_function(tolua_S,"IsRectVisible",tolua_LuaBinding_ImGui_IsRectVisible00);
   tolua_function(tolua_S,"IsRectVisible",tolua_LuaBinding_ImGui_IsRectVisible01);
   tolua_function(tolua_S,"IsMouseDown",tolua_LuaBinding_ImGui_IsMouseDown00);
   tolua_function(tolua_S,"IsMouseClicked",tolua_LuaBinding_ImGui_IsMouseClicked00);
   tolua_function(tolua_S,"IsMouseDoubleClicked",tolua_LuaBinding_ImGui_IsMouseDoubleClicked00);
   tolua_function(tolua_S,"IsMouseReleased",tolua_LuaBinding_ImGui_IsMouseReleased00);
   tolua_function(tolua_S,"IsMouseHoveringRect",tolua_LuaBinding_ImGui_IsMouseHoveringRect00);
   tolua_function(tolua_S,"IsMouseDragging",tolua_LuaBinding_ImGui_IsMouseDragging00);
   tolua_function(tolua_S,"GetMousePos",tolua_LuaBinding_ImGui_GetMousePos00);
   tolua_function(tolua_S,"GetMousePosOnOpeningCurrentPopup",tolua_LuaBinding_ImGui_GetMousePosOnOpeningCurrentPopup00);
   tolua_function(tolua_S,"GetMouseDragDelta",tolua_LuaBinding_ImGui_GetMouseDragDelta00);
   tolua_function(tolua_S,"ResetMouseDragDelta",tolua_LuaBinding_ImGui_ResetMouseDragDelta00);
   tolua_function(tolua_S,"BeginTabBar",tolua_LuaBinding_ImGui_BeginTabBar00);
   tolua_function(tolua_S,"BeginTabBar",tolua_LuaBinding_ImGui_BeginTabBar01);
   tolua_function(tolua_S,"EndTabBar",tolua_LuaBinding_ImGui_EndTabBar00);
   tolua_function(tolua_S,"BeginTabItem",tolua_LuaBinding_ImGui_BeginTabItem00);
   tolua_function(tolua_S,"BeginTabItem",tolua_LuaBinding_ImGui_BeginTabItem01);
   tolua_function(tolua_S,"BeginTabItem",tolua_LuaBinding_ImGui_BeginTabItem02);
   tolua_function(tolua_S,"BeginTabItem",tolua_LuaBinding_ImGui_BeginTabItem03);
   tolua_function(tolua_S,"EndTabItem",tolua_LuaBinding_ImGui_EndTabItem00);
   tolua_function(tolua_S,"TabItemButton",tolua_LuaBinding_ImGui_TabItemButton00);
   tolua_function(tolua_S,"TabItemButton",tolua_LuaBinding_ImGui_TabItemButton01);
   tolua_function(tolua_S,"SetTabItemClosed",tolua_LuaBinding_ImGui_SetTabItemClosed00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"NVGpaint","VGPaint","",tolua_collect_NVGpaint);
  tolua_beginmodule(tolua_S,"VGPaint");
  tolua_endmodule(tolua_S);
  tolua_module(tolua_S,"nvg",0);
  tolua_beginmodule(tolua_S,"nvg");
   tolua_function(tolua_S,"Save",tolua_LuaBinding_nvg_Save00);
   tolua_function(tolua_S,"Restore",tolua_LuaBinding_nvg_Restore00);
   tolua_function(tolua_S,"Reset",tolua_LuaBinding_nvg_Reset00);
   tolua_function(tolua_S,"CreateImage",tolua_LuaBinding_nvg_CreateImage00);
   tolua_function(tolua_S,"CreateImage",tolua_LuaBinding_nvg_CreateImage01);
   tolua_function(tolua_S,"CreateFont",tolua_LuaBinding_nvg_CreateFont00);
   tolua_function(tolua_S,"TextBounds",tolua_LuaBinding_nvg_TextBounds00);
   tolua_function(tolua_S,"TextBoxBounds",tolua_LuaBinding_nvg_TextBoxBounds00);
   tolua_function(tolua_S,"Text",tolua_LuaBinding_nvg_Text00);
   tolua_function(tolua_S,"TextBox",tolua_LuaBinding_nvg_TextBox00);
   tolua_function(tolua_S,"StrokeColor",tolua_LuaBinding_nvg_StrokeColor00);
   tolua_function(tolua_S,"StrokeColor",tolua_LuaBinding_nvg_StrokeColor01);
   tolua_function(tolua_S,"StrokePaint",tolua_LuaBinding_nvg_StrokePaint00);
   tolua_function(tolua_S,"FillColor",tolua_LuaBinding_nvg_FillColor00);
   tolua_function(tolua_S,"FillColor",tolua_LuaBinding_nvg_FillColor01);
   tolua_function(tolua_S,"FillPaint",tolua_LuaBinding_nvg_FillPaint00);
   tolua_function(tolua_S,"MiterLimit",tolua_LuaBinding_nvg_MiterLimit00);
   tolua_function(tolua_S,"StrokeWidth",tolua_LuaBinding_nvg_StrokeWidth00);
   tolua_function(tolua_S,"LineCap",tolua_LuaBinding_nvg_LineCap00);
   tolua_function(tolua_S,"LineJoin",tolua_LuaBinding_nvg_LineJoin00);
   tolua_function(tolua_S,"GlobalAlpha",tolua_LuaBinding_nvg_GlobalAlpha00);
   tolua_function(tolua_S,"ResetTransform",tolua_LuaBinding_nvg_ResetTransform00);
   tolua_function(tolua_S,"ApplyTransform",tolua_LuaBinding_nvg_ApplyTransform00);
   tolua_function(tolua_S,"Translate",tolua_LuaBinding_nvg_Translate00);
   tolua_function(tolua_S,"Rotate",tolua_LuaBinding_nvg_Rotate00);
   tolua_function(tolua_S,"SkewX",tolua_LuaBinding_nvg_SkewX00);
   tolua_function(tolua_S,"SkewY",tolua_LuaBinding_nvg_SkewY00);
   tolua_function(tolua_S,"Scale",tolua_LuaBinding_nvg_Scale00);
   tolua_function(tolua_S,"ImageSize",tolua_LuaBinding_nvg_ImageSize00);
   tolua_function(tolua_S,"DeleteImage",tolua_LuaBinding_nvg_DeleteImage00);
   tolua_function(tolua_S,"LinearGradient",tolua_LuaBinding_nvg_LinearGradient00);
   tolua_function(tolua_S,"BoxGradient",tolua_LuaBinding_nvg_BoxGradient00);
   tolua_function(tolua_S,"RadialGradient",tolua_LuaBinding_nvg_RadialGradient00);
   tolua_function(tolua_S,"ImagePattern",tolua_LuaBinding_nvg_ImagePattern00);
   tolua_function(tolua_S,"Scissor",tolua_LuaBinding_nvg_Scissor00);
   tolua_function(tolua_S,"IntersectScissor",tolua_LuaBinding_nvg_IntersectScissor00);
   tolua_function(tolua_S,"ResetScissor",tolua_LuaBinding_nvg_ResetScissor00);
   tolua_function(tolua_S,"BeginPath",tolua_LuaBinding_nvg_BeginPath00);
   tolua_function(tolua_S,"MoveTo",tolua_LuaBinding_nvg_MoveTo00);
   tolua_function(tolua_S,"LineTo",tolua_LuaBinding_nvg_LineTo00);
   tolua_function(tolua_S,"BezierTo",tolua_LuaBinding_nvg_BezierTo00);
   tolua_function(tolua_S,"QuadTo",tolua_LuaBinding_nvg_QuadTo00);
   tolua_function(tolua_S,"ArcTo",tolua_LuaBinding_nvg_ArcTo00);
   tolua_function(tolua_S,"ClosePath",tolua_LuaBinding_nvg_ClosePath00);
   tolua_function(tolua_S,"PathWinding",tolua_LuaBinding_nvg_PathWinding00);
   tolua_function(tolua_S,"Arc",tolua_LuaBinding_nvg_Arc00);
   tolua_function(tolua_S,"Rect",tolua_LuaBinding_nvg_Rect00);
   tolua_function(tolua_S,"RoundedRect",tolua_LuaBinding_nvg_RoundedRect00);
   tolua_function(tolua_S,"RoundedRectVarying",tolua_LuaBinding_nvg_RoundedRectVarying00);
   tolua_function(tolua_S,"Ellipse",tolua_LuaBinding_nvg_Ellipse00);
   tolua_function(tolua_S,"Circle",tolua_LuaBinding_nvg_Circle00);
   tolua_function(tolua_S,"Fill",tolua_LuaBinding_nvg_Fill00);
   tolua_function(tolua_S,"Stroke",tolua_LuaBinding_nvg_Stroke00);
   tolua_function(tolua_S,"FindFont",tolua_LuaBinding_nvg_FindFont00);
   tolua_function(tolua_S,"AddFallbackFontId",tolua_LuaBinding_nvg_AddFallbackFontId00);
   tolua_function(tolua_S,"AddFallbackFont",tolua_LuaBinding_nvg_AddFallbackFont00);
   tolua_function(tolua_S,"FontSize",tolua_LuaBinding_nvg_FontSize00);
   tolua_function(tolua_S,"FontBlur",tolua_LuaBinding_nvg_FontBlur00);
   tolua_function(tolua_S,"TextLetterSpacing",tolua_LuaBinding_nvg_TextLetterSpacing00);
   tolua_function(tolua_S,"TextLineHeight",tolua_LuaBinding_nvg_TextLineHeight00);
   tolua_function(tolua_S,"TextAlign",tolua_LuaBinding_nvg_TextAlign00);
   tolua_function(tolua_S,"FontFaceId",tolua_LuaBinding_nvg_FontFaceId00);
   tolua_function(tolua_S,"FontFace",tolua_LuaBinding_nvg_FontFace00);
   tolua_function(tolua_S,"DoraSSR",tolua_LuaBinding_nvg_DoraSSR00);
   tolua_function(tolua_S,"GetDoraSSR",tolua_LuaBinding_nvg_GetDoraSSR00);
  tolua_endmodule(tolua_S);
  tolua_cclass(tolua_S,"VGNode","VGNode","Node",tolua_collect_object);
  tolua_beginmodule(tolua_S,"VGNode");
   tolua_variable(tolua_S,"surface",tolua_get_VGNode_surface_ptr,NULL);
   tolua_function(tolua_S,"render",tolua_LuaBinding_VGNode_render00);
   tolua_call(tolua_S,MT_CALL,tolua_LuaBinding_VGNode_new00_local);
  tolua_endmodule(tolua_S);
 tolua_endmodule(tolua_S);
 return 1;
}
